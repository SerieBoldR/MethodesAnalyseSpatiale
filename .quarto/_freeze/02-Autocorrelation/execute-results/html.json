{
  "hash": "75ed7b44b2cf1e8a189b1fe32d4fc98c",
  "result": {
    "engine": "knitr",
    "markdown": "# Autocorrélation spatiale {#sec-chap02}\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Première loi de la géographie proposée par Waldo Tobler**\n:::\n\n::: bloc_notes-body\n« Tout interagit avec tout, mais les objets proches ont plus de chance de le faire que les objets éloignés \\[*Everything is related to everything else, but near things are more related than distant things*\\] » [@tobler1970computer].\n:::\n:::\n\nDans ce chapitre, nous mettons en œuvre dans R différentes méthodes qui permettent d'évaluer la dépendance spatiale d'une variable, soit les mesures d'autocorrélation spatiale globale et locale. Préalablement, nous voyons comment définir des matrices de pondération spatiale -- selon la contiguïté et la proximité spatiale -- qui sont utilisées dans les mesures d'autocorrélation spatiale, mais aussi dans les modèles spatiaux autorégressifs ([chapitre @sec-chap07]).\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n\n::: bloc_package-body\n-   Pour importer et manipuler des fichiers géographiques :\n    -   `sf` pour importer et manipuler des données vectorielles.\n    -   `terra` pour importer et manipuler des données matricielles.\n-   Pour calculer des mesures d'autocorrélation spatiale :\n    -   `spdep` pour construire des matrices spatiales et calculer des mesures d'autocorrélation spatiale.\n    -   `rgeoda` pour calculer des mesures d'autocorrélation spatiale.\n    -   `geocmeans` pour calculer l'indicateur ELSA.\n-   Pour construire des cartes et des graphiques :\n    -   `tmap` pour construire des cartes thématiques.\n    -   `ggplot2` pour construire des graphiques.\n    -   `ggpubr` pour réaliser une figure combinant plusieurs graphiques construits avec `ggplot2`.\n-   Pour manipuler des données :\n    -   `dplyr` est un *package* facilitant la manipulation des données.\n:::\n:::\n\n## Notion d'autocorrélation spatiale {#sec-021}\n\nComprendre la configuration spatiale d'un phénomène donné est une démarche fondamentale en analyse spatiale. Or, l'autocorrélation spatiale permet d'estimer la corrélation d'une variable par rapport à sa localisation dans l'espace, soit la dépendance spatiale. Autrement dit, elle permet de vérifier si les entités proches ou voisines ont tendance à être (dis)semblables en fonction d'un phénomène donné (soit une variable). Tel qu'illustré à la @fig-Chap02NotionAutocorrSpatiale (données fictives), on distingue trois formes d'autocorrélation spatiale :\n\n-   **(a) Autocorrélation spatiale positive** : lorsque les entités spatiales voisines ou proches se ressemblent davantage que celles non contiguës ou éloignées. Cela renvoie ainsi à la première loi de la géographie : « tout interagit avec tout, mais les objets proches ont plus de chance de le faire que les objets éloignés » (traduction libre) [@tobler1970computer].\n\n-   **(b) Autocorrélation spatiale négative** : lorsque les entités spatiales voisines ou proches ont tendance à être dissemblables, comparativement à celles non contiguës ou éloignées.\n\n-   **(c) Absence d'autocorrélation spatiale** : lorsque les valeurs de la variable sont distribuées aléatoirement dans l'espace; autrement dit, lorsqu'il n'y a pas de relation entre le voisinage ou la proximité des entités spatiales et leur degré de ressemblance.\n\n![Autocorrélation spatiale](images/Chap02/NotionAutocorrSpatiale.png){#fig-Chap02NotionAutocorrSpatiale width=\"65%\" fig-align=\"center\"}\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Analyse de la @fig-FigureExo1**\n:::\n\n::: bloc_exercice-body\nQuelle est la variable pour laquelle le voisinage joue un rôle important dans sa distribution? L'autocorrélation pour cette variable est-elle positive ou négative? Pourquoi?\n\n![Illustration de l'autocorrélation spatiale de deux variables pour les aires de diffusion de la ville de Sherbrooke](images/Chap02/FigureExo1.png){#fig-FigureExo1 width=\"70%\" fig-align=\"center\"}\n\n*Réponse :* L'autocorrélation spatiale semble bien plus forte pour le pourcentage des logements construits avant 1960. Les aires de diffusion (AD) contiguës ou proches dans la partie centrale de la ville ont clairement des pourcentages élevés (rouge foncé) tandis que celles voisines ou proches dans les périphéries présentent des pourcentages faibles. Cela traduit donc une forte autocorrélation spatiale positive. Par contre, la distribution spatiale du pourcentage de personnes de 65 ans et plus semble plus aléatoire, traduisant ainsi une faible autocorrélation spatiale (dépendance spatiale).\n:::\n:::\n\nVous avez compris que la simple cartographie d'une variable vous donne une indication de l'autocorrélation spatiale. Pour contre, pour « chiffrer » l'intensité de l'autocorrélation spatiale, il convient de : 1) choisir une matrice de pondération spatiale (selon le voisinage ou la distance) ([section @sec-022]), 2) calculer une mesure d'autocorrélation spatiale à partir de cette matrice (comme l'indice de Moran) ([section @sec-023]).\n\n## Matrices de pondération spatiale {#sec-022}\n\nLes mesures d'autocorrélation spatiale visent à vérifier si les entités spatiales contiguës ou proches ont tendance à être semblables (autocorrélation positive) ou dissemblables (autocorrélation négative) en fonction d'un phénomène donné (en fonction d'une variable). Il convient donc avant tout de définir la manière de mesurer la relation d'adjacence ou de proximité entre deux entités spatiales.\n\nIl existe huit principales matrices de pondération spatiale regroupées en deux grandes catégories : celles de contiguïté (basées sur l'adjacence) et celles de proximité (basées sur la distance) (@tbl-TabMatricesSpatiales). Lorsque la couche géographique est composée de points, seules les matrices de proximité peuvent être utilisées.\n\n\n\n\n\n\n::: {#tbl-TabMatricesSpatiales .cell tbl-cap='Matrices de pondération spatiale selon la géométrie'}\n::: {.cell-output-display}\n`````{=html}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Matrice </th>\n   <th style=\"text-align:center;\"> Points </th>\n   <th style=\"text-align:center;\"> Lignes </th>\n   <th style=\"text-align:center;\"> Polyg. </th>\n   <th style=\"text-align:center;\"> Raster </th>\n  </tr>\n </thead>\n<tbody>\n  <tr grouplength=\"4\"><td colspan=\"5\" style=\"border-bottom: 1px solid;\"><strong>Matrices de contiguïté (basées sur l'adjacence)</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> Partage d'un nœud (Queen) </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> Partage d'un segment (Rook) </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> Partage d'un nœud et ordre d'adjacence (Queen) </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> Partage d'un segment et ordre d'adjacence (Rook) </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"5\" style=\"border-bottom: 1px solid;\"><strong>Matrices de proximité (basées sur la distance)</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> Connectivité selon la distance </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> Inverse de la distance </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> Inverse de la distance au carré </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> Nombre de plus proches voisins </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n   <td style=\"text-align:center;\"> X </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n\n\n\n### Matrices de contiguïté {#sec-0221}\n\nLa relation d'adjacence (de contiguïté) vise à déterminer si deux entités spatiales sont ou non voisines selon le partage soit d'un nœud, soit d'un segment (frontière commune). La contiguïté est liée à la notion de topologie qui prend en compte les relations de voisinage entre des entités spatiales, sans tenir compte de leurs tailles et de leurs formes géométriques. Elle peut être représentée à partir d'une **matrice de contiguïté** (avec une valeur de 1 quand deux entités sont voisines et de 0 pour une situation inverse) ou d'un **graphe** (formé de points représentant les entités spatiales et de lignes reliant les entités voisines) (@fig-Chap02Contiguity1).\n\n![Relation topologique entre des entités spatiales polygonales](images/Chap02/FigureTopologie.png){#fig-Chap02Contiguity1 width=\"60%\" fig-align=\"center\"}\n\nTrois évaluations de la contiguïté sont représentées à la @fig-Chap02Contiguity2 :\n\n-   **Adjacence selon le partage d'un segment**, soit d'une frontière commune entre les polygones (A).\n\n-   **Adjacence selon le partage d'un nœud** (B).\n\n-   **Ordre d'adjacence selon le partage d'un segment** (C). L'ordre d'adjacence indique le nombre de frontières à traverser pour se rendre à l'entité spatiale contiguë, soit :\n\n    -   **Ordre 1** : une frontière à traverser pour se rendre dans l'entité spatiale adjacente.\n\n    -   **Ordre 2** : deux frontières à traverser pour atteindre les entités de la deuxième couronne.\n\n    -   **Ordre 3** : trois frontières à traverser pour atteindre les entités de la troisième couronne.\n\n    -   Etc.\n\nBien entendu, les ordres d'adjacence peuvent être également définis selon le partage d'un nœud commun.\n\n![Relations de voisinage et évaluation de la contiguïté](images/Chap02/FigureAdjacence.png){#fig-Chap02Contiguity2 width=\"60%\" fig-align=\"center\"}\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Applicabilité des ordres d'adjacence**\n:::\n\n::: bloc_astuce-body\nLes matrices d'adjacence sont souvent utilisées dans les analyses de diffusion spatiale. Prenons un exemple concret : imaginons que le polygone en gris à la @fig-Chap02Contiguity2 est un parc. Nous pourrions évaluer le prix moyen des maisons dans les îlots qui font face au parc (ordre 1), toutes choses étant égales par ailleurs (superficie du terrain, superficie habitable, nombre de pièces, etc.). Puis, nous pourrions comparer ce prix moyen à ceux calculés pour les ordres suivants. Il est probable que le prix au premier ordre soit significativement plus élevé qu'au deuxième ordre, voire au troisième ordre. Autre exemple, nous pourrions réaliser un exercice similaire pour des maisons dans des îlots adjacents à un tronçon autoroutier. La relation est probablement inverse : un prix moyen plus bas à l'ordre 1 comparativement aux ordres suivants.\n:::\n:::\n\nHabituellement appelée $W$, la matrice de contiguïté est binaire selon le partage tant d'un nœud (*Queen* en anglais) (@eq-ContiguiteQueen) que d'un segment commun (*Rook* en anglais) (@eq-ContiguiteRook).\n\n$$\n w_{ij} = \n \\begin{cases} \n   1 & \\text{si les entités spatiales }i \\text{ et }j \\text{ ont au moins un nœud commun; } i   \\ne j\\\\\n   0 & \\text{sinon} \n  \\end{cases}\n$$ {#eq-ContiguiteQueen}\n\n$$ \n w_{ij} = \n \\begin{cases} \n   1 & \\text{si les entités spatiales }i \\text{ et }j \\text{ partagent une frontière commune; } i   \\ne j\\\\\n   0 & \\text{sinon} \n  \\end{cases}\n$$ {#eq-ContiguiteRook}\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 1.** Compléter des matrices de contiguïté\n:::\n\n::: bloc_exercice-body\nPetit conseil pour la partie A : une matrice de contiguïté est symétrique c'est-à-dire que si le polygone A est voisin du polygone B, alors B est voisin de A! Par conséquent, pour gagner du temps, complétez une ligne et transposez-la en colonne.\n\n![Exercice sur la contiguïté et les ordres d'adjacence](images/Chap02/ExoMatriceDeContiguite.png){#fig-ExoMatriceDeContiguiteCorrection width=\"60%\" fig-align=\"center\"}\n\nCorrection à la [section @sec-12021].\n:::\n:::\n\n### Matrices de proximité spatiale {#sec-0222}\n\n#### Bref retour sur les différents types de distance {#sec-02221}\n\nPour calculer des mesures d'autocorrélation spatiale, nous pouvons aussi utiliser des matrices de pondération spatiale basées sur la proximité spatiale. Cette fois, nous ne cherchons pas à vérifier si les entités spatiales adjacentes se ressemblent, mais plutôt à vérifier si les entités spatiales proches les unes des autres se ressemblent. Pour ce faire, nous devons calculer les distances entre les entités spatiales.\n\nPour construire une matrice de pondération spatiale selon la proximité, nous pouvons utiliser plusieurs types de distance [@ApparicioGelbrevisited] : certaines sont cartésiennes, d'autres, dites réticulaires, sont calculées à partir d'un réseau de rues (@fig-Chap02TypesDistances).\n\nLes distances cartésiennes -- euclidienne et de Manhattan (@eq-DistEuc et @eq-DistManh) -- sont facilement calculables à partir des coordonnées géographiques (*x*,*y*) dans un SIG ou dans n'importe quel logiciel tableur, de statistique ou de gestion de base de données, etc. Pour cela, la couche géographique doit être dans un système de projection plane. La distance euclidienne représente ainsi la distance à vol d'oiseau entre deux points, tandis que la distance de Manhattan est la somme des deux côtés formant l'angle droit d'un triangle rectangle (l'hypoténuse, le plus grand des côtés du triangle, étant la distance euclidienne) (@fig-Chap02TypesDistances, a). Si la projection de la couche est sphérique (longitude/latitude), il convient d'utiliser la formule de haversine (basée sur la trigonométrie sphérique) pour obtenir la distance à vol d'oiseau (@eq-DistLongLat).\n\nPar contre, comme leurs noms l'indiquent, les distances réticulaires nécessitent un réseau de rues dans un SIG (notamment avec l'extension *Network Analyst* d'ArcGIS Pro) ou dans R (notamment avec le *package* R5R) pour calculer le chemin le plus rapide ([chapitre @sec-chap05]).\n\n$$\n d_{ij} = \\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\n$$ {#eq-DistEuc}\n\n$$\n d_{ij} = \\lvert x_i-x_j \\rvert + \\lvert y_i-y_j \\rvert\n$$ {#eq-DistManh}\n\n$$\n d_{ij} = 2R \\cdot \\text{ arcsin} \\left( \\sqrt{\\text{sin}^2 \\left( \\frac{\\delta _i - \\delta _j}{2} \\right) + \\text{cos }\\delta _i \\cdot \\text{cos }\\delta _j \\cdot \\text{sin}^2 \\left( \\frac{\\phi _i - \\phi _j}{2} \\right)} \\right)\n$$ {#eq-DistLongLat}\n\navec $R$ étant le rayon de la terre; $\\delta _i$ et $\\delta _j$ les coordonnées de longitude pour les points $i$ et $j$; $\\phi _i$ et $\\phi _j$ les coordonnées de latitude pour les points $i$ et $j$.\n\n![Les différents types de distance](images/Chap02/FigureDistances.png){#fig-Chap02TypesDistances width=\"80%\" fig-align=\"center\"}\n\n#### Matrice de distance binaire (de connectivité) {#sec-02222}\n\nÀ partir d'une matrice de distance entre les entités spatiales d'une couche géographique, il est possible de créer une matrice de pondération binaire (@eq-MatriceDistanceNonBinaire). Ce type de matrice est habituellement appelée **matrice de connectivité**. Il convient alors de fixer un seuil de distance maximal. Par exemple, avec un seuil de 500 mètres, $w_{ij}=1$ si la distance entre les entités spatiales $i$ et $j$ est inférieure ou égale à 500 mètres; sinon $w_{ij}=0$. Notez que pour des lignes et des polygones, la distance est habituellement calculée à partir de leurs centroïdes.\n\n$$\n w_{ij} = \n \\begin{cases} \n   1 & \\text{si }d_{ij}\\leq{\\bar{d}}\\text{; } i \\ne j\\\\\n   0 & \\text{sinon} \n  \\end{cases}\n$$ {#eq-MatriceDistanceNonBinaire}\n\navec $d_{ij}$ étant la distance entre les entités spatiales $i$ et $j$, et $\\bar{d}$ étant un seuil de distance maximal fixé par la personne utilisatrice (par exemple, 500 mètres).\n\nEn guise d'exemple, à la @fig-Connectivite, seuls les polygones jaunes seraient considérés comme voisins du polygone bleu avec un seuil de distance maximal fixé à 2,5 kilomètres (valeur de 1); les roses se verraient affecter la valeur de 0.\n\n![Illustration de la connectivité basée sur la distance](images/Chap02/FigureConnectivite.png){#fig-Connectivite width=\"50%\" fig-align=\"center\"}\n\n#### Matrices basées sur la distance {#sec-02223}\n\nÀ partir d'une matrice de distance entre les entités spatiales, les pondérations peuvent être calculées avec l'inverse de la distance ($1/d_{ij}$) ou l'inverse de la distance au carré ($1/d_{ij^2}$) (@eq-MatriceDistance1). Analysons le graphique à la @fig-PonderationInvDistInvDist2.\n\n-   Premièrement, nous constatons que plus la distance est grande, plus la valeur de la pondération est faible et inversement. De la sorte, nous accordons un rôle plus important aux entités spatiales proches les unes des autres que celles éloignées.\n\n-   Deuxièmement, les pondérations chutent beaucoup plus rapidement avec l'inverse de la distance au carré qu'avec l'inverse de la distance. Autrement dit, le recours à une matrice de pondération calculée avec l'inverse de la distance au carré a comme effet d'accorder un poids plus important aux entités géographiques très proches.\n\n$$\nw_{ij} = \n \\begin{cases} \n  \\frac{1}{d_{ij}^{\\gamma}} &\\\\\n   0 & \\text{si } i=j\n  \\end{cases}\n$$ {#eq-MatriceDistance1}\n\navec $\\gamma = 1$ pour une matrice de l'inverse de la distance et $\\gamma = 2$ pour l'inverse de la distance au carré.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Comparaison des matrices inverse de la distance et inverse de la distance au carré](02-Autocorrelation_files/figure-html/fig-PonderationInvDistInvDist2-1.png){#fig-PonderationInvDistInvDist2 fig-align='center' width=75%}\n:::\n:::\n\n\n\n\n\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Pondération avec l'exponentielle inverse**\n:::\n\n::: bloc_aller_loin-body\nDans un excellent livre intitulé *Économétrie spatiale appliquée des microdonnées*, Jean Dubé et Diego Legros [-@dube2014econometrie] proposent de transformer la matrice des distances avec l'inverse de l'exponentielle (ou l'exponentielle négative de la distance) (@eq-MatriceDistancEexp). Comparativement à l'inverse de la distance au carré, cette opération fait chuter encore plus rapidement les pondérations.\n\n$$\n w_{ij} = \n \\begin{cases} \n  \\frac{1}{e^{d_{ij}}} = e^{-d_{ij}} &\\\\\n   0 & \\text{si } i=j\n  \\end{cases}\n$$ {#eq-MatriceDistancEexp}\n:::\n:::\n\nNotez que l'@eq-MatriceDistance1 peut être légèrement modifiée en introduisant un seuil maximal de la distance au-delà duquel les pondérations sont mises à 0 (@eq-MatriceDistance2). Autrement dit, cela permet de ne pas tenir compte des entités spatiales distantes à plus d'un seuil fixé par l'analyste, ce qui est particulièrement intéressant lorsque vous analysez un phénomène dont la diffusion (ou propagation) cesse ou est très minime au-delà d'une certaine distance. Par exemple, pour la propagation du bruit routier, le seuil de 300 mètres est souvent utilisé. Par conséquent, une mesure d'autocorrélation spatiale sur des mesures de bruit routier devrait probablement recourir à un seuil maximal de 300 mètres. Autre exemple, la superficie du territoire vital diffère selon les espèces animales (cerf, caribou, ours et loup, par exemple). Par conséquent, une ou un biologiste calculant des mesures d'autocorrélation spatiale risque aussi de fixer un seuil maximal différent selon l'espèce étudiée.\n\n$$\n w_{ij} = \n \\begin{cases} \n   \\frac{1}{d_{ij}^{\\gamma}} & \\text{si }d_{ij}\\leq{\\bar{d}}\\\\\n   0 & \\text{si }d_{ij}>{\\bar{d}}\\\\\n   0 & \\text{si } i=j\n  \\end{cases}\n$$ {#eq-MatriceDistance2}\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Calculer le rayon maximal à partir d'une aire**\n:::\n\n::: bloc_astuce-body\nAdmettons que la superficie du territoire vital d'une espèce soit de 50 hectares, soit 0,5 km^2^ ou 500 000 m^2^. La formule bien connue pour calculer la superficie d'un cercle est $S = \\pi r^2$ avec $S$ et $r$ étant respectivement la superficie et le rayon. Par conséquent, celle du rayon est $r = \\sqrt{\\frac{S}{\\pi}}$. Pour trouver le rayon, vous devez taper `sqrt(500000 / pi)` dans la console de R et obtenir ainsi une distance de `398.9423` qui pourrait être arrondie à 400 mètres.\n:::\n:::\n\n#### Matrices selon le critère des plus proches voisins {#sec-02224}\n\nUne autre façon très utilisée pour définir une matrice de proximité à partir d'une matrice de distance consiste à retenir uniquement les *n* plus proches voisins. La matrice est aussi binaire avec les valeurs de 1 si les observations sont parmi les *n* plus proches de l'entité spatiale $i$ et de 0 pour une situation inverse.\n\n### Standardisation des matrices de pondération spatiale en ligne {#sec-0223}\n\nIl est recommandé de standardiser les matrices de pondération en ligne. La somme de la matrice de pondération sera alors égale au nombre d'entités spatiales de la couche géographique.\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Quel est l'intérêt de la standardisation?**\n:::\n\n::: bloc_attention-body\nNous verrons dans les sections suivantes que ces matrices sont utilisées pour évaluer le degré d'autocorrélation spatiale globale et locale. Or, il est fréquent de comparer les valeurs des mesures d'autocorrélation spatiale obtenues avec différentes matrices d'adjacence et de proximité (contiguïté selon le partage d'un nœud, d'une frontière commune; inverse de la distance, inverse de la distance au carré, etc.). Autrement dit, la standardisation des matrices de pondération spatiale permet de vérifier si le degré de (dis)ressemblance des entités spatiales en fonction d'une variable donnée est plus fort avec une matrice de contiguïté, d'inverse de la distance ou encore d'inverse de la distance au carré, etc.\n:::\n:::\n\nPour illustrer comment réaliser une standardisation, nous utilisons une couche géographique comprenant peu d'entités spatiales, soit celle des quatre arrondissements de la ville de Sherbrooke (@fig-Arrond).\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n![Arrondissements de la ville de Sherbrooke](images/Chap02/Arrondissements.png){#fig-Arrond width=\"50%\" fig-align=\"center\"}\n\nAu @tbl-StandardisationMatrice, différentes matrices de contiguïté et de distance ont été calculées, puis standardisées. Voici comment interpréter les différentes sections du tableau :\n\n-   **Contiguïté selon le partage d'une frontière commune.** La valeur de 1 signale que deux arrondissements sont voisins, sinon la valeur est à 0. Tel qu'indiqué aux @eq-ContiguiteQueen et @eq-ContiguiteRook, un arrondissement ne peut être voisin de lui-même (ex.: valeur de 0 pour la cellule `Bro.` et `Bro.`). L'arrondissement de Brompton--Rock Forest--Saint-Élie--Deauville (`Bro.`) a deux voisins, soit ceux des Nations et de Fleurimont (`Nat.` et `Fle.`), comme indiqué par la valeur 2 dans la colonne `total`. Par contre, les arrondissements des Nations et de Fleurimont sont voisins de tous les autres (valeur de 3 dans la colonne `total`).\n\n-   **Standardisation de la matrice de contiguïté.** Il suffit de diviser chaque valeur de la matrice de contiguïté par la somme de la ligne correspondante. De la sorte, la somme de chaque ligne est égale à 1 et la somme de l'ensemble des valeurs de la matrice est égale au nombre d'entités spatiales (ici 4).\n\n-   **Distance (km).** Nous avons calculé la distance euclidienne en kilomètres entre les centroïdes des arrondissements.\n\n-   **Inverse de la distance.** Les valeurs sont obtenues avec la formule $1/_{dij}$. Par exemple, entre `Bro.` et `Nat.`, nous avons $1/7,9930 = 0,1251$.\n\n-   **Inverse de la distance au carré.** Les valeurs sont obtenues avec la formule $1/_{dij^2}$. Par exemple, entre `Bro.` et `Nat.`, nous avons $1/7,9930^2 = 0,0160$.\n\n-   **Standardisation de l'inverse de la distance.** Comme précédemment, il suffit de diviser chaque valeur de la matrice par la somme de la ligne correspondante. Par exemple, pour `Bro.` et `Nat.`, nous avons $0,1251 / 0,3241 = 0,3860$. Remarquez que la somme des lignes est bien égale à 1.\n\n-   **Standardisation de l'inverse de la distance au carré.** Comme précédemment, il suffit de diviser chaque valeur de la matrice par la somme de la ligne correspondante. Par exemple, pour `Bro.` et `Nat.`, nous avons $0,0160 / 0,0360 = 0,4440$. Remarquez que la somme des lignes est bien égale à 1.\n\n\n\n\n\n\n::: {#tbl-StandardisationMatrice .cell tbl-cap='Standardisation de matrices de pondération spatiale'}\n::: {.cell-output-display}\n`````{=html}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:right;\"> Arrondissement </th>\n   <th style=\"text-align:right;\"> Bro. </th>\n   <th style=\"text-align:right;\"> Nat. </th>\n   <th style=\"text-align:right;\"> Len. </th>\n   <th style=\"text-align:right;\"> Fle. </th>\n   <th style=\"text-align:right;\"> Somme (lignes) </th>\n  </tr>\n </thead>\n<tbody>\n  <tr grouplength=\"4\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>Matrice de contiguïté selon le partage d'une frontière commune</strong></td></tr>\n<tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Bro. </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 2,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Nat. </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 3,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Len. </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 2,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Fle. </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 3,0000 </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>Standardisation de la matrice de contiguïté</strong></td></tr>\n<tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Bro. </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,5000 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,5000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Nat. </td>\n   <td style=\"text-align:right;\"> 0,3330 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,3330 </td>\n   <td style=\"text-align:right;\"> 0,3330 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Len. </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,5000 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,5000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Fle. </td>\n   <td style=\"text-align:right;\"> 0,3330 </td>\n   <td style=\"text-align:right;\"> 0,3330 </td>\n   <td style=\"text-align:right;\"> 0,3330 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>Distance (km)</strong></td></tr>\n<tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Bro. </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 7,9930 </td>\n   <td style=\"text-align:right;\"> 18,9940 </td>\n   <td style=\"text-align:right;\"> 16,1140 </td>\n   <td style=\"text-align:right;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Nat. </td>\n   <td style=\"text-align:right;\"> 7,9930 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 11,1190 </td>\n   <td style=\"text-align:right;\"> 9,1650 </td>\n   <td style=\"text-align:right;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Len. </td>\n   <td style=\"text-align:right;\"> 18,9940 </td>\n   <td style=\"text-align:right;\"> 11,1190 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 9,2590 </td>\n   <td style=\"text-align:right;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Fle. </td>\n   <td style=\"text-align:right;\"> 16,1140 </td>\n   <td style=\"text-align:right;\"> 9,1650 </td>\n   <td style=\"text-align:right;\"> 9,2590 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\">  </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>Matrice selon l'inverse de la distance</strong></td></tr>\n<tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Bro. </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,1251 </td>\n   <td style=\"text-align:right;\"> 0,0526 </td>\n   <td style=\"text-align:right;\"> 0,0621 </td>\n   <td style=\"text-align:right;\"> 0,2398 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Nat. </td>\n   <td style=\"text-align:right;\"> 0,1251 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,0899 </td>\n   <td style=\"text-align:right;\"> 0,1091 </td>\n   <td style=\"text-align:right;\"> 0,3241 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Len. </td>\n   <td style=\"text-align:right;\"> 0,0526 </td>\n   <td style=\"text-align:right;\"> 0,0899 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,1080 </td>\n   <td style=\"text-align:right;\"> 0,2505 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Fle. </td>\n   <td style=\"text-align:right;\"> 0,0621 </td>\n   <td style=\"text-align:right;\"> 0,1091 </td>\n   <td style=\"text-align:right;\"> 0,1080 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,2792 </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>Matrice selon l'inverse de la distance au carré</strong></td></tr>\n<tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Bro. </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,0160 </td>\n   <td style=\"text-align:right;\"> 0,0030 </td>\n   <td style=\"text-align:right;\"> 0,0040 </td>\n   <td style=\"text-align:right;\"> 0,0230 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Nat. </td>\n   <td style=\"text-align:right;\"> 0,0160 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,0080 </td>\n   <td style=\"text-align:right;\"> 0,0120 </td>\n   <td style=\"text-align:right;\"> 0,0360 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Len. </td>\n   <td style=\"text-align:right;\"> 0,0030 </td>\n   <td style=\"text-align:right;\"> 0,0080 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,0120 </td>\n   <td style=\"text-align:right;\"> 0,0230 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Fle. </td>\n   <td style=\"text-align:right;\"> 0,0040 </td>\n   <td style=\"text-align:right;\"> 0,0120 </td>\n   <td style=\"text-align:right;\"> 0,0120 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,0280 </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>Standardisation de l'inverse de la distance</strong></td></tr>\n<tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Bro. </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,5220 </td>\n   <td style=\"text-align:right;\"> 0,2190 </td>\n   <td style=\"text-align:right;\"> 0,2590 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Nat. </td>\n   <td style=\"text-align:right;\"> 0,3860 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,2770 </td>\n   <td style=\"text-align:right;\"> 0,3370 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Len. </td>\n   <td style=\"text-align:right;\"> 0,2100 </td>\n   <td style=\"text-align:right;\"> 0,3590 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,4310 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Fle. </td>\n   <td style=\"text-align:right;\"> 0,2220 </td>\n   <td style=\"text-align:right;\"> 0,3910 </td>\n   <td style=\"text-align:right;\"> 0,3870 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>Standardisation de l'inverse de la distance au carré</strong></td></tr>\n<tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Bro. </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,6960 </td>\n   <td style=\"text-align:right;\"> 0,1300 </td>\n   <td style=\"text-align:right;\"> 0,1740 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Nat. </td>\n   <td style=\"text-align:right;\"> 0,4440 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,2220 </td>\n   <td style=\"text-align:right;\"> 0,3330 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Len. </td>\n   <td style=\"text-align:right;\"> 0,1300 </td>\n   <td style=\"text-align:right;\"> 0,3480 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 0,5220 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;padding-left: 2em;\" indentlevel=\"1\"> Fle. </td>\n   <td style=\"text-align:right;\"> 0,1430 </td>\n   <td style=\"text-align:right;\"> 0,4290 </td>\n   <td style=\"text-align:right;\"> 0,4290 </td>\n   <td style=\"text-align:right;\"> 0,0000 </td>\n   <td style=\"text-align:right;\"> 1,0000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n\n\n\n### Construction de matrices de pondération spatiale dans R {#sec-0224}\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Construction des matrices dans R  avec le *package*`spdep`**.\n:::\n\n::: bloc_attention-body\nLe package `spdep` dispose de différentes fonctions pour construire des matrices de contiguïté, de connectivité et de distance :\n\n-   `poly2nb` pour des matrices de contiguïté ([section @sec-02241]);\n\n-   `nblag` et `nblag_cumul` pour des matrices de contiguïté avec des ordres d'adjacence ([section @sec-02242]);\n\n-   `dnearneigh` pour des matrices de connectivité ([section @sec-02243]);\n\n-   `as.matrix(dist(coords))` et `mat2listw` pour des matrices de distance ([section @sec-02244]);\n\n-   `knn2nb` pour des matrices selon le critère des plus proches voisins ([section @sec-02245]).\n:::\n:::\n\n#### Matrices de pondération spatiale selon la contiguïté {#sec-02241}\n\nPour créer des matrices de pondération spatiale selon la contiguïté décrites à la [section @sec-0221], nous utilisons deux fonctions du *package* `spdep` :\n\n-   `poly2nb(Nom de l'objet sf, queen=TRUE)` crée une matrice de contiguïté sous la forme d'une classe `nb` (*A neighbours list with class nb*). Avec le paramètre `queen=TRUE`, la contiguïté est évaluée selon le partage d'un nœud; avec `queen=FALSE`, la contiguïté est évaluée selon le partage d'un segment (frontière). La matrice spatiale comprend une ligne par secteur de recensement avec les index des polygones adjacents. Par exemple, `Queen[[1]]` renvoie la liste des polygones voisins à la première entité spatiale, soit `2 14 15 16 23 32`, c'est-à-dire six voisins.\n\n-   `nb2listw(objet nb, zero.policy=TRUE, style = \"W\")` crée une matrice de pondération spatiale à partir de n'importe quelle matrice spatiale (de contiguïté ou de distance). Le `paramètre style = \"W\"`, qui est par défaut, permet de standardiser la matrice en ligne. Par exemple, `W.Queen$weights[[1]]` renvoie les valeurs des pondérations pour la première entité spatiale, soit `0.1666667 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667` (0,1666667 = 1 / 6 voisin). Pour obtenir une matrice non standardisée, vous devez écrire `style = \"B\"`, alors `W.Queen$weights[[1]]` renverra les valeurs de `1 1 1 1 1 1`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)    # pour importer des couches géographiques\nlibrary(spdep) # pour construire les matrices de pondération\n## Importation de la couche des secteurs de recensement de la ville de Sherbrooke\nSR <- st_read(dsn = \"data/chap02/Recen2021Sherbrooke.gpkg\",\n              layer = \"DR_SherbSRDonnees2021\", quiet=TRUE)\n## Matrice selon le partage d'un nœud (Queen)\n# Création de la matrice spatiale\nQueen <- poly2nb(SR, queen=TRUE)\n# Affichage de la première ligne de la matrice\nQueen[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2 14 15 16 23 32\n```\n\n\n:::\n\n```{.r .cell-code}\n# Création de la matrice de pondération avec une standardisation en ligne\nW.Queen <- nb2listw(Queen, zero.policy=TRUE, style = \"W\")\n# Affichage de la première ligne des pondérations\nW.Queen$weights[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"La somme de la première ligne de la matrice de pondération est égale à\",\n    sum(W.Queen$weights[[1]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLa somme de la première ligne de la matrice de pondération est égale à 1\n```\n\n\n:::\n\n```{.r .cell-code}\n## Matrice selon le partage d'un segment (Rook)\nRook <- poly2nb(SR, queen=FALSE)\nW.Rook <- nb2listw(Rook, zero.policy=TRUE, style = \"W\")\n##  Comparaison des deux matrices de contiguïté\n# Résultat de la matrice de pondération (Queen)\nsummary(W.Queen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 50 \nNumber of nonzero links: 272 \nPercentage nonzero weights: 10.88 \nAverage number of links: 5.44 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8 10 \n 1  2  2  9 13  9  8  5  1 \n1 least connected region:\n41 with 1 link\n1 most connected region:\n29 with 10 links\n\nWeights style: W \nWeights constants summary:\n   n   nn S0      S1       S2\nW 50 2500 50 20.3056 205.5251\n```\n\n\n:::\n\n```{.r .cell-code}\n# Résultat de la matrice de pondération (Rook)\nsummary(W.Rook)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 50 \nNumber of nonzero links: 248 \nPercentage nonzero weights: 9.92 \nAverage number of links: 4.96 \nLink number distribution:\n\n 1  2  3  4  5  6  7  9 \n 1  2  4  9 17 11  5  1 \n1 least connected region:\n41 with 1 link\n1 most connected region:\n29 with 9 links\n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 50 2500 50 21.84674 205.0781\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLa syntaxe ci-dessous permet de visualiser et de comparer les graphes selon le partage d'un nœud (*Queen*) ou d'un segment commun (*Rook*).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2)) # permet d'avoir quatre graphiques (2x2)\ncoords <- st_coordinates(st_centroid(SR))\n## Graphe selon le partage d'un nœud\nplot(st_geometry(SR), border=\"gray\", lwd=2, col=\"wheat\")\nplot(Queen, coords, add=TRUE, col=\"red\", lwd=2)\ntitle(main=\"Queen\", font.main= 1)\n## Graphe selon le partage d'une frontière commune\nplot(st_geometry(SR), border=\"gray\", lwd=2, col=\"wheat\")\nplot(Rook, coords, add=TRUE, col=\"red\", lwd=2)\ntitle(main=\"Rook\", font.main= 1)\n```\n\n::: {.cell-output-display}\n![](02-Autocorrelation_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n#### Matrices de pondération spatiale selon la contiguïté et un ordre d'adjacence {#sec-02242}\n\nPour décrire la construction des matrices de contiguïté avec un ordre d'adjacence (décrites à la [section @sec-0221]), nous utilisons une couche géographique comprenant peu d'entités spatiales, soit celle des quatre arrondissements de la ville de Sherbrooke (figure 1). Le code ci-dessous permet d'obtenir les résultats suivants :\n\n-   `Rook <- poly2nb(Arrondissements, queen=FALSE)`: matrice d'ordre 1 selon le partage d'un segment.\n\n-   `str(Rook)`: pour chaque arrondissement, la liste des arrondissements adjacents d'ordre 1.\n\n-   `Rook.Ordre2 <- nblag(Rook, 2)`: création d'une matrice d'ordre 2 avec la fonction `nblag`.\n\n-   `str(Rook.Ordre2[[1]])`: liste des voisins d'ordre 1. Bien entendu, le résultat est identique à `str(Rook)`.\n\n-   `str(Rook.Ordre2[[2]])`: liste des voisins d'ordre 2.\n\n-   `Rook.Ordre2Cumule <- nblag_cumul(Rook.Ordre2)`: fusion des deux listes en une seule avec la fonction `nblag_cumul`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nArrondissements <- st_read(\"data/chap02/Arrondissements.shp\", quiet=TRUE)\n## Matrice de contiguïté d'ordre 1 selon le partage d'un segment (Rook)\nRook <- poly2nb(Arrondissements, queen=FALSE)\nstr(Rook)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : int [1:2] 2 4\n $ : int [1:3] 1 3 4\n $ : int [1:2] 2 4\n $ : int [1:3] 1 2 3\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:4] \"1\" \"2\" \"3\" \"4\"\n - attr(*, \"call\")= language poly2nb(pl = Arrondissements, queen = FALSE)\n - attr(*, \"type\")= chr \"rook\"\n - attr(*, \"snap\")= num 0.01\n - attr(*, \"sym\")= logi TRUE\n - attr(*, \"ncomp\")=List of 2\n  ..$ nc     : num 1\n  ..$ comp.id: num [1:4] 1 1 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\n## Matrice de contiguïté d'ordre 2 selon le partage d'un segment (Rook)\nRook.Ordre2 <- nblag(Rook, 2)\n## Rook.Ordre2 comprend deux listes : l'une pour l'ordre 1 et l'autre pour l'autre 2.\nstr(Rook.Ordre2[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : int [1:2] 2 4\n $ : int [1:3] 1 3 4\n $ : int [1:2] 2 4\n $ : int [1:3] 1 2 3\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:4] \"1\" \"2\" \"3\" \"4\"\n - attr(*, \"call\")= language poly2nb(pl = Arrondissements, queen = FALSE)\n - attr(*, \"type\")= chr \"rook\"\n - attr(*, \"snap\")= num 0.01\n - attr(*, \"sym\")= logi TRUE\n - attr(*, \"ncomp\")=List of 2\n  ..$ nc     : num 1\n  ..$ comp.id: num [1:4] 1 1 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(Rook.Ordre2[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : int 3\n $ : int 0\n $ : int 1\n $ : int 0\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:4] \"1\" \"2\" \"3\" \"4\"\n - attr(*, \"sym\")= logi TRUE\n - attr(*, \"ncomp\")=List of 2\n  ..$ nc     : num 3\n  ..$ comp.id: num [1:4] 1 2 1 3\n```\n\n\n:::\n\n```{.r .cell-code}\n## La fonction nblag_cumul permet de combiner les deux ordres dans une seule liste\nRook.Ordre2Cumule <- nblag_cumul(Rook.Ordre2)\nstr(Rook.Ordre2Cumule)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : int [1:3] 2 3 4\n $ : int [1:3] 1 3 4\n $ : int [1:3] 1 2 4\n $ : int [1:3] 1 2 3\n - attr(*, \"region.id\")= chr [1:4] \"1\" \"2\" \"3\" \"4\"\n - attr(*, \"call\")= language nblag_cumul(nblags = Rook.Ordre2)\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"sym\")= logi TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n## Création de la matrice de pondération spatiale standardisée\nWRook.Ordre2Cumule <- nb2listw(Rook.Ordre2Cumule, zero.policy=TRUE, style = \"W\")\n```\n:::\n\n\n\n\n\n\nLa @fig-ArrondOrdre1et2 permet de constater qu'au second ordre, chacun des arrondissements est relié aux trois autres.\n\n![Adjacence de premier et de second ordre](images/Chap02/FigureOrdre1et2.png){#fig-ArrondOrdre1et2 width=\"50%\" fig-align=\"center\"}\n\nReprenons la couche des secteurs de recensement de la ville de Sherbrooke pour construire des matrices d'adjacence d'ordre 1 à 3.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Création des matrices d'ordre 1, 2 et 3\nQueen1 <- poly2nb(SR, queen=TRUE)\nQueen2 <- nblag_cumul(nblag(Queen1, 2))\nQueen3 <- nblag_cumul(nblag(Queen1, 3))\n# Création des matrices\nW.Queen1 <- nb2listw(Queen, zero.policy=TRUE, style = \"W\")\nW.Queen2 <- nb2listw(Queen2, zero.policy=TRUE, style = \"W\")\nW.Queen3 <- nb2listw(Queen3, zero.policy=TRUE, style = \"W\")\n```\n:::\n\n\n\n\n\n\n#### Matrice de connectivité (matrice distance binaire) {#sec-02243}\n\nLa fonction `dnearneigh(sf points, d1=, d2=)` crée une matrice de connectivité (décrite à la [section @sec-0222]) à partir d'une couche de points. Les paramètres `d1` et `d2` permettent de spécifier le rayon de recherche (ex. : avec `d1 = 0` et `d2 = 2500`, le seuil maximal de distance est de 2500 mètres).\n\nSi votre couche `sf` comprend des `lignes` ou des `polygones`, utilisez la fonction `st_centroid` ou `st_point_on_surface()` pour les convertir en points ([section @sec-0122]).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Conversion des polygones en points avec st_centroid\nSR.centroides <- st_centroid(SR)\n## Matrice binaire avec un seuil de 2500 mètres\nConnect2500m <- dnearneigh(SR.centroides, d1 = 0, d2 = 2500)\n## Matrice de pondération spatiale standardisée en ligne\nW.Connect2500m <- nb2listw(Connect2500m, zero.policy=TRUE, style = \"W\")\n```\n:::\n\n\n\n\n\n\n#### Matrices de pondération spatiale selon l'inverse de la distance et l'inverse de la distance au carré {#sec-02244}\n\nDans la [section @sec-0223], nous avons présenté les matrices de l'inverse de la distance et de l'inverse de la distance au carré. Le code ci-dessous, qui permet de les créer, comprend les étapes suivantes :\n\n-   Récupération des coordonnées géographiques des entités spatiales.\n\n-   Création de la matrice de distance euclidienne $n \\times n$ ($n$ étant le nombre d'entités spatiales de la couche).\n\n-   Calcul des matrices d'inverse de la distance et d'inverse de la distance au carré.\n\n-   Standardisation de ces deux matrices et transformation dans des objets `listw` avec la fonction `mat2listw`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Coordonnées des centroïdes des entités spatiales\ncoords <- st_coordinates(SR.centroides)\n## Création de la matrice de distance\ndistances <- as.matrix(dist(coords, method = \"euclidean\"))\n# S'assurer que la diagonale de la matrice est à 0\ndiag(distances) <- 0\n## Matrices inverse de la distance et inverse de la distance au carré\nInvDistances <- ifelse(distances!=0, 1/distances, distances)\nInvDistances2 <- ifelse(distances!=0, 1/distances^2, distances)\n## Matrices de pondération spatiale standardisées en ligne\nW_InvDistances  <- mat2listw(InvDistances, style=\"W\")\nW_InvDistances2 <- mat2listw(InvDistances2, style=\"W\")\n## Visualisation des valeurs des pondération pour la première entité spatiale\nround(W_InvDistances$weights[[1]],4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.0688 0.0505 0.0377 0.0330 0.0220 0.0191 0.0152 0.0116 0.0155 0.0220\n[11] 0.0303 0.0382 0.0582 0.0677 0.0661 0.0366 0.0373 0.0316 0.0248 0.0123\n[21] 0.0178 0.0241 0.0055 0.0084 0.0083 0.0084 0.0106 0.0232 0.0125 0.0231\n[31] 0.0425 0.0192 0.0164 0.0049 0.0086 0.0071 0.0062 0.0061 0.0054 0.0049\n[41] 0.0078 0.0050 0.0032 0.0043 0.0036 0.0030 0.0035 0.0042 0.0037\n```\n\n\n:::\n\n```{.r .cell-code}\n# La somme de la ligne est bien égale à 1\nsum(W_InvDistances$weights[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Intégration d'autres types de distance**\n:::\n\n::: bloc_astuce-body\nÀ la [section @sec-02221], nous avons vu que plusieurs types de distances peuvent être utilisés : cartésiennes (euclidienne et de Manhattan) et réticulaires (chemin le plus rapide à pied, à vélo, en automobile et en transport en commun).\n\nPour construire une matrice de distance de Manhattan, vous devez changer la valeur du paramètre `method` de la fonction `dist` comme suit : `as.matrix(dist(coords, method = \"manhattan\"))`.\n\nPour intégrer une distance réticulaire, vous devez la calculer, soit dans R ([chapitre @sec-chap05]), soit dans un logiciel SIG (ArcGIS Pro avec l'extension *Network Analyst* par exemple) et l'importer dans R. Le reste du code sera alors identique.\n:::\n:::\n\nNous avons vu qu'il est possible d'utiliser une matrice de distance en fixant une distance maximale au-delà de laquelle les pondérations sont mises à 0 (@eq-MatriceDistance2 à la [section @sec-02221]). Le code ci-dessous permet de créer des matrices de pondération standardisées avec l'inverse de la distance et l'inverse de la distance au carré avec des seuils de 2500 et de 5000 mètres.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Coordonnées des centroïdes des entités spatiales\ncoords <- st_coordinates(SR.centroides)\n## Création de la matrice de distance\ndistances <- as.matrix(dist(coords, method = \"euclidean\"))\n## Création de différentes matrices avec différents seuils\nInvDistances.2500m  <- ifelse(distances<=2500 & distances!=0, 1/distances, 0)\nInvDistances.5000m  <- ifelse(distances<=5000 & distances!=0, 1/distances, 0)\nInvDistances2.2500m <- ifelse(distances<=2500 & distances!=0, 1/distances^2, 0)\nInvDistances2.5000m <- ifelse(distances<=5000 & distances!=0, 1/distances^2, 0)\n## Matrices de pondération spatiale standardisées en ligne\nW_InvDistances.2500 <- mat2listw(InvDistances.2500m, style=\"W\", zero.policy = TRUE)\nW_InvDistances.5000 <- mat2listw(InvDistances.5000m, style=\"W\", zero.policy = TRUE)\nW_InvDistances2.2500 <- mat2listw(InvDistances2.2500m, style=\"W\", zero.policy = TRUE)\nW_InvDistances2.5000 <- mat2listw(InvDistances2.5000m, style=\"W\", zero.policy = TRUE)\n```\n:::\n\n\n\n\n\n\nSpécifier un seuil de distance peut toutefois être problématique. Par exemple, sur les 50 secteurs de recensement de la ville de Sherbrooke, 19 n'ont pas de voisins à 2500 mètres, indiqués par le résultat suivant :\n\n`## 19 regions with no links:`\n\n`## 23 24 25 30 34 35 36 37 38 39 40 41 42 43 44 45 47 49 50`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(W_InvDistances.2500, zero.policy=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 50 \nNumber of nonzero links: 188 \nPercentage nonzero weights: 7.52 \nAverage number of links: 3.76 \n19 regions with no links:\n23, 24, 25, 30, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 47, 49,\n50\n21 disjoint connected subgraphs\nLink number distribution:\n\n 0  1  2  3  4  6  7  8  9 10 11 12 13 \n19  6  2  2  4  2  2  3  4  1  2  1  2 \n6 least connected regions:\n21 26 31 33 46 48 with 1 link\n2 most connected regions:\n12 13 with 13 links\n\nWeights style: W \nWeights constants summary:\n   n  nn S0       S1       S2\nW 31 961 31 19.09079 128.6954\n```\n\n\n:::\n:::\n\n\n\n\n\n\nMême avec un seuil de 5000 mètres, il reste encore 11 SR sans voisins.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(W_InvDistances.5000, zero.policy=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 50 \nNumber of nonzero links: 532 \nPercentage nonzero weights: 21.28 \nAverage number of links: 10.64 \n11 regions with no links:\n35, 36, 37, 39, 40, 41, 42, 43, 47, 49, 50\n13 disjoint connected subgraphs\nLink number distribution:\n\n 0  1  2  3  5  6  7  8  9 10 11 16 18 19 20 21 22 23 \n11  2  2  4  2  1  1  2  1  1  1  2  2  4  2  4  7  1 \n2 least connected regions:\n24 30 with 1 link\n1 most connected region:\n12 with 23 links\n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 39 1521 39 12.11283 162.9801\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Réduction de la taille des matrices de distance**\n:::\n\n::: bloc_attention-body\nPlusieurs logiciels (notamment ArcGIS Pro et GeoDa) réduisent par défaut la taille des matrices de distance de la façon suivante : 1) construction d'une matrice de distance uniquement pour l'entité la plus proche (la matrice résultante est donc de dimension $n \\times 1$); 2) obtention de la distance maximale dans cette matrice, soit la distance la plus grande entre une entité spatiale et celle la plus proche; 3) construction de la matrice de distance finale avec comme seuil la distance maximale obtenue à l'étape précédente.\n\nCette réduction procure deux avantages importants :\n\n-   **Une diminution considérable des temps de calcul**, surtout pour les couches géographiques comprenant un nombre très élevé d'entités spatiales. Par exemple, avec une couche de 50 entités spatiales, la matrice des distances comprendra 2500 valeurs (50 $\\times$ 50 = 2500) tandis qu'avec 1000 entités spatiales, elle en comprendra un million (1000 $\\times$ 1000 = 1 000 000).\n\n-   Comme décrit plus haut, il est préférable d'**éviter d'avoir une matrice de distance avec des entités spatiales sans voisins**, puisque cela a un impact négatif sur les mesures d'autocorrélation spatiale.\n:::\n:::\n\nLa syntaxe ci-dessous permet ainsi de construire des matrices de pondération (inverse de la distance et inverse de la distance au carré) à partir de la distance maximale et un SR et son voisin le plus proche.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Coordonnées des centroïdes des entités spatiales\ncoords <- st_coordinates(SR.centroides)\n## Trouver le plus proche voisin\nk1 <- knn2nb(knearneigh(coords))\n## Affichage des distances pour les 50 SR au le plus proche\nround(unlist(nbdists(k1,coords)),0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1352   563   563   659   833  1275  1275  1299  2136  1553  1171   833\n[13]   953   953  1024  1024   936   936  1149  1242  2378  1473  3863  4963\n[25]  2841  1755  1755  2294  1507  4002  1843  1710  2486  2977 10953  6965\n[37]  5331  4077  6717  6892  6892  6335  5639  3530  4202  1636  6662  1636\n[49] 10745 10034\n```\n\n\n:::\n\n```{.r .cell-code}\n## Trouver la distance maximale       \nplusprochevoisin.max <- max(unlist(nbdists(k1,coords)))\ncat(\"Distance maximale au plus proche voisin :\", round(plusprochevoisin.max,0), \"mètres\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDistance maximale au plus proche voisin : 10953 mètres\n```\n\n\n:::\n\n```{.r .cell-code}\n## Matrice de distance avec la valeur maximale\n# les voisins les plus proches avec le seuil de distance maximal\nVoisins.DistMax <- dnearneigh(coords, 0, plusprochevoisin.max)\n# Distances avec le seuil maximum\ndistances <- nbdists(Voisins.DistMax, coords)\n# Inverse de la distance\nInvDistances <- lapply(distances, function(x) (1/x))\n# Inverse de la distance au carré\nInvDistances2 <- lapply(distances, function(x) (1/x^2))\n## Matrices de pondération spatiale standardisées en ligne\nW_InvDistances  <- nb2listw(Voisins.DistMax, glist = InvDistances, style = \"W\")\nW_InvDistances2 <- nb2listw(Voisins.DistMax, glist = InvDistances2, style = \"W\")\n```\n:::\n\n\n\n\n\n\n#### Matrices de pondération spatiale selon le critère des plus proches voisins {#sec-02245}\n\nLa fonction `knearneigh` du *package* `spdep` crée des matrices de distance selon le critère des plus proches voisins (décrit à la [section @sec-02224]), dont le nombre est fixé avec le paramètre `k`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Coordonnées géographiques des centroïdes des polygones\ncoords <- st_coordinates(st_centroid(SR))\n## Matrices des plus proches voisins de 2 à 5\nk2 <- knn2nb(knearneigh(coords, k = 2))\nk3 <- knn2nb(knearneigh(coords, k = 3))\nk4 <- knn2nb(knearneigh(coords, k = 4))\nk5 <- knn2nb(knearneigh(coords, k = 5))\n## Matrices de pondération spatiale standardisées en ligne\nW.k2 <-  nb2listw(k2, zero.policy=FALSE, style = \"W\")\nW.k3 <-  nb2listw(k3, zero.policy=FALSE, style = \"W\")\nW.k4 <-  nb2listw(k4, zero.policy=FALSE, style = \"W\")\nW.k5 <-  nb2listw(k5, zero.policy=FALSE, style = \"W\")\n```\n:::\n\n\n\n\n\n\nLa syntaxe ci-dessous permet de comparer les matrices des plus proches voisins de *k* = 2 à 5 (@fig-PlusProcheVoisins).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,2))\nplot(st_geometry(SR), border=\"gray\", lwd=2, col=\"wheat\")\nplot(k2, coords, add=TRUE, col=\"red\", lwd=2)\ntitle(main=\"k = 2\")\n\nplot(st_geometry(SR), border=\"gray\", lwd=2, col=\"wheat\")\nplot(k3, coords, add=TRUE, col=\"red\", lwd=2)\ntitle(main=\"k = 3\")\n\nplot(st_geometry(SR), border=\"gray\", lwd=2, col=\"wheat\")\nplot(k4, coords, add=TRUE, col=\"red\", lwd=2)\ntitle(main=\"k = 4\")\n\nplot(st_geometry(SR), border=\"gray\", lwd=2, col=\"wheat\")\nplot(k5, coords, add=TRUE, col=\"red\", lwd=2)\ntitle(main=\"k = 5\")\n```\n:::\n\n\n\n\n\n\n![Matrices selon le critère des plus proches voisins](images/Chap02/FigurePlusProcheVoisins.png){#fig-PlusProcheVoisins width=\"100%\" fig-align=\"center\"}\n\n## Autocorrélation spatiale globale {#sec-023}\n\nDans le cadre de cette section, nous présentons uniquement les mesures d'autocorrélation spatiale globale les plus utilisées, à savoir le *I* de Moran pour évaluer l'autocorrélation spatiale d'une variable continue ([section @sec-0231]), les statistiques de comptage de jointure (*Join Count Statistics*) pour une variable binaire ou catégorielle ([section @sec-0232]) et l'indice de Lee pour évaluer l'autocorrélation spatiale de deux variables continues ([section @sec-0233]).\n\n### Statistique du *I* de Moran {#sec-0231}\n\n#### Formulation du *I* de Moran {#sec-02311}\n\nPour évaluer le degré d'autocorrélation spatiale d'une variable continue, les deux principales statistiques utilisées sont le *I* de Moran [-@moran1950test] et le *c* de Geary [-@geary1954contiguity]. Puisqu'elles renvoient une seule valeur pour la variable continue de la couche géographique étudiée, elles sont qualifiées de mesures globales de l'autocorrélation spatiale, par opposition aux mesures locales qui renvoient une valeur par entité spatiale ([section @sec-024]).\n\nNous présentons ici uniquement le *I* de Moran pour deux raisons principales. Premièrement, étant basée sur la covariance, son interprétation est bien plus facile que celle du *c* de Geary (basé sur la variance des écarts), c'est-à-dire qu'elle est très similaire au bien connu [coefficient de corrélation de Pearson](https://serieboldr.github.io/MethodesQuantitatives/04-bivarieeQuantiQuanti.html#sec-043) [@RBoldAir]. Deuxièmement, elle constitue la mesure la plus utilisée. Le *I* de Moran s'écrit :\n\n$$\nI = \\frac{n}{\\Sigma_{i=1}^n \\Sigma_{j=1}^n w_{ij}} \\frac{\\Sigma_{i=1}^n \\Sigma_{j=1}^n w_{ij}(x_i-\\bar{x})(x_j-\\bar{x})}{\\Sigma_{i=1}^n (x_i-\\bar{x})^2} \\text{ avec :}\n$$ {#eq-MoranIa}\n\n-   *n*, le nombre d'entités spatiales dans la couche géographique;\n\n-   $w_{ij}$, la valeur de la pondération spatiale entre les entités spatiales $i$ et $j$;\n\n-   $x_i$ et $x_j$, les valeurs de la variable continue pour les entités spatiales $i$ et $j$;\n\n-   $\\bar{x}$, la valeur moyenne de la variable $X$ à l'étude.\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Standardisation de la matrice de pondération et *I* de Moran**\n:::\n\n::: bloc_notes-body\nNous avons vu que si la matrice de pondération spatiale est standardisée en ligne ([section @sec-0223]), alors chaque ligne de la matrice vaut 1 et la somme de l'ensemble des valeurs de la matrice est égale au nombre d'entités spatiales ($n$). Or, dans l'@eq-MoranIa), $\\Sigma_{i=1}^n \\Sigma_{j=1}^n w_{ij}$ représente la somme des pondérations de la matrice, soit $n$ si elles sont standardisées en ligne. Puisque $\\frac{n}{n}=1$, alors l'équation du *I* de Moran est simplifiée comme suit :\n\n$$\nI = \\frac{\\Sigma_{i=1}^n \\Sigma_{j=1}^n w_{ij}(x_i-\\bar{x})(x_j-\\bar{x})}{\\Sigma_{i=1}^n (x_i-\\bar{x})^2}\n$$ {#eq-MoranIb}\n\nComme évoqué dans la [section @sec-0223], cela démontre l'intérêt de la standardisation : la comparaison des valeurs du *I* de Moran obtenues avec différentes matrices de contiguïté afin de sélectionner (éventuellement) celle avec laquelle la dépendance spatiale est la plus forte.\n:::\n:::\n\n#### Interprétation du *I* de Moran {#sec-02312}\n\nAvec une matrice standardisée, la statistique du *I* de Moran varie de -1 à 1 et s'interprète de la façon suivante :\n\n-   quand $I > 0$, l'autocorrélation est positive, c'est-à-dire que les entités géographiques ont tendance à se ressembler d'autant plus qu'elles sont voisines ou proches;\n\n-   quand $I = 0$, l'autocorrélation est nulle, c'est-à-dire que la contiguïté ou la proximité spatiale des zones ne jouent aucun rôle;\n\n-   quand $I < 0$, l'autocorrélation est négative, c'est-à-dire que les entités géographiques ont tendance à être dissemblables d'autant plus qu'elles sont voisines ou proches.\n\nLes limites de -1 et 1 sont les maximums théoriques du *I* de Moran. Dans la pratique, elles sont limitées par la matrice spatiale utilisée dans le calcul. En effet, selon la matrice spatiale, le maximum du *I* de Moran peut être inférieur à 1, et son minimum supérieur à -1. Le calcul de ces bornes propres à chaque matrice spatiale peut se faire en utilisant les maximums et minimums des valeurs propres de $\\frac{W+W^T}{2}$, quand la matrice spatiale est standardisée.\n\nÀ titre d'exemple, nous calculons ci-dessous les maximums et minimums possibles pour une matrice de contiguïté selon le partage d'un nœud (*Queen*) de nos secteurs de recensement.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Matrice de contiguïté selon le partage d'un nœud (Queen)\nQueen <- poly2nb(SR, queen = TRUE)\nWQueen <- nb2listw(Queen, style = 'W')\nQueenMat <- listw2mat(WQueen)\nvalues <- range(eigen((QueenMat + t(QueenMat))/2)$values)\nprint(round(values,2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.74  1.02\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIl apparaît ainsi que pour la matrice matrice de contiguïté selon le partage d'un nœud (*Queen*), quelle soit la variable analysée, la valeur de *I* de Moran ne pourra pas dépasser les limites -0,74 et 1,02.\n\n#### Significativité du *I* de Moran {#sec-02313}\n\nComme pour le coefficient de corrélation calculé entre deux variables, il est possible de tester la significativité de la valeur du *I* de Moran obtenue. Sans que nous détaillions les calculs de significativité, notez qu'il existe trois manières de tester la significativité :\n\n-   selon l'hypothèse de la normalité;\n\n-   selon l'hypothèse de la randomisation;\n\n-   selon des permutations Monte-Carlo (habituellement avec 999 échantillons).\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Comment calculer les trois tests de significativité du *I* de Moran?**\n:::\n\n::: bloc_aller_loin-body\nPour une description détaillée du calcul des trois tests, consultez l'ouvrage de Jean Dubé et Diego Legros [-@dube2014econometrie].\n:::\n:::\n\n#### Mise en œuvre dans R {#sec-02314}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Calcul du *I* de Moran dans R**\n:::\n\n::: bloc_objectif-body\nPour illustrer le calcul de *I* de Moran dans R, nous utilisons une couche des aires de diffusion (AD) de la ville de Sherbrooke. Les étapes suivantes sont réalisées :\n\n1.  Construire une panoplie de matrices de pondération spatiale selon la contiguïté, la connectivité, la proximité et le critère des plus proches voisins.\n2.  Comparer les valeurs de significativité (*p*) pour une variable continue (`HabKm2`).\n3.  Pour cette même variable, trouver avec quelle matrice la valeur du *I* de Moran est la plus forte.\n4.  Comparer les valeurs du *I* de Moran calculées sur plusieurs variables.\n:::\n:::\n\n##### Étape 1. Construction des matrices de pondération spatiale {#sec-023141}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(spdep)\n## Importation de la couche des aires de diffusion de la ville de Sherbrooke\nAD.DR <- st_read(dsn = \"data/chap02/Recen2021Sherbrooke.gpkg\",\n              layer = \"DR_SherbADDonnees2021\", quiet=TRUE)\n\n## Matrices de contiguïté\n##############################################\n## Partage d'un nœud (Queen)\nQueen <- poly2nb(AD.DR, queen=TRUE)\nW.Queen <- nb2listw(Queen, zero.policy=TRUE, style = \"W\")\n## Partage d'un segment (Rook)\nRook <- poly2nb(AD.DR, queen=FALSE)\nW.Rook <- nb2listw(Rook, zero.policy=TRUE, style = \"W\")\n## Partage d'un segment (Rook) et ordres d'adjacence de 2 à 5\nRook2 <- nblag_cumul(nblag(Rook, 2))\nRook3 <- nblag_cumul(nblag(Rook, 3))\nRook4 <- nblag_cumul(nblag(Rook, 4))\nRook5 <- nblag_cumul(nblag(Rook, 5))\nW.Rook2 <- nb2listw(Rook2, zero.policy=TRUE, style = \"W\")\nW.Rook3 <- nb2listw(Rook3, zero.policy=TRUE, style = \"W\")\nW.Rook4 <- nb2listw(Rook4, zero.policy=TRUE, style = \"W\")\nW.Rook5 <- nb2listw(Rook5, zero.policy=TRUE, style = \"W\")\n\n## Matrice de connectivité\n##############################################\n## Matrice binaire avec un seuil de 2500 mètres\nConnect2500m <-   dnearneigh(st_centroid(AD.DR), d1 = 0, d2 = 2500)\nW.Connect2500m <- nb2listw(Connect2500m, zero.policy=TRUE, style = \"W\")\n\n## Matrices de proximité\n##############################################\n## Coordonnées géographiques et matrice de distance\ncoords <- st_coordinates(st_centroid(AD.DR))\ndistances <- as.matrix(dist(coords, method = \"euclidean\"))\ndiag(distances) <- 0\n## Matrices inverse de la distance et inverse de la distance au carré\nInvDistances <- ifelse(distances!=0, 1/distances, distances)\nInvDistances2 <- ifelse(distances!=0, 1/distances^2, distances)\n## Matrices de pondération spatiale standardisées en ligne\nW.InvDistances  <- mat2listw(InvDistances, style=\"W\")\nW.InvDistances2 <- mat2listw(InvDistances2, style=\"W\")\n## Création de différentes matrices avec différents seuils\nInvDistances.2500m  <- ifelse(distances<=2500 & distances!=0, 1/distances, 0)\nInvDistances.5000m  <- ifelse(distances<=5000 & distances!=0, 1/distances, 0)\nInvDistances2.2500m <- ifelse(distances<=2500 & distances!=0, 1/distances^2, 0)\nInvDistances2.5000m <- ifelse(distances<=5000 & distances!=0, 1/distances^2, 0)\nW.InvDistances_2500 <- mat2listw(InvDistances.2500m, style=\"W\", zero.policy = TRUE)\nW.InvDistances_5000 <- mat2listw(InvDistances.5000m, style=\"W\", zero.policy = TRUE)\nW.InvDistances2_2500 <- mat2listw(InvDistances2.2500m, style=\"W\", zero.policy = TRUE)\nW.InvDistances2_5000 <- mat2listw(InvDistances2.5000m, style=\"W\", zero.policy = TRUE)\n## Matrice de distance réduite standardisée\nk1 <- knn2nb(knearneigh(coords))\nplusprochevoisin.max <- max(unlist(nbdists(k1,coords)))\nVoisins.DistMax <- dnearneigh(coords, 0, plusprochevoisin.max)                            \ndistances <- nbdists(Voisins.DistMax, coords)\nInvDistances <- lapply(distances, function(x) (1/x))\nInvDistances2 <- lapply(distances, function(x) (1/x^2))\nW_InvDistancesReduite  <- nb2listw(Voisins.DistMax, glist = InvDistances, style = \"W\")\nW_InvDistances2Reduite <- nb2listw(Voisins.DistMax, glist = InvDistances2, style = \"W\")\n\n## Matrice selon le critère des plus proches voisins\n#####################################################\n## Matrices des plus proches voisins de 2 à 5\nk2 <- knn2nb(knearneigh(coords, k = 2))\nk3 <- knn2nb(knearneigh(coords, k = 3))\nk4 <- knn2nb(knearneigh(coords, k = 4))\nk5 <- knn2nb(knearneigh(coords, k = 5))\n## Matrices de pondération spatiale standardisées en ligne\nW.k2 <-  nb2listw(k2, zero.policy=FALSE, style = \"W\")\nW.k3 <-  nb2listw(k3, zero.policy=FALSE, style = \"W\")\nW.k4 <-  nb2listw(k4, zero.policy=FALSE, style = \"W\")\nW.k5 <-  nb2listw(k5, zero.policy=FALSE, style = \"W\")\n```\n:::\n\n\n\n\n\n\n##### Étape 2. Calcul du *I* de Moran et des trois tests de significativité {#sec-023142}\n\nCalculons la statistique du *I* de Moran sur la variable continue cartographiée à la @fig-CartoADDRSherbrooke.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Densité de population, aires de diffusion de la ville de Sherbrooke](02-Autocorrelation_files/figure-html/fig-CartoADDRSherbrooke-1.png){#fig-CartoADDRSherbrooke fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\nLes fonctions `moran.test` et `moran.mc` du *package* `spdep` permettent de calculer le *I* de Moran selon les trois façons de tester la significativité :\n\n-   selon l'hypothèse de la normalité avec le paramètre `randomisation = FALSE`\n\n    -   `moran.test(ObjetSf$Variable, listw=MatriceW, zero.policy=TRUE, randomisation = FALSE)`\n\n-   selon l'hypothèse de la randomisation avec le paramètre `randomisation = TRUE`\n\n    -   `moran.test(ObjetSf$Variable, listw=MatriceW, zero.policy=TRUE, randomisation = TRUE)`\n\n-   selon des permutations Monte-Carlo (ci-dessus avec 999 permutations)\n\n    -   `moran.mc(ObjetSf$Variable, listw=MatriceW, zero.policy=TRUE, nsim=999)`\n\nBien entendu, dans les sorties des trois méthodes, la valeur du *I* de Moran est la même, contrairement à la valeur de *p* qui peut varier.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(AD.DR$HabKm2,          # nom de l'objet sf et de la variable continue\n           listw=W.Queen,         # nom de la matrice de pondération spatiale\n           zero.policy=TRUE,    \n           randomisation = FALSE) # significativité selon l’hypothèse de la normalité\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under normality\n\ndata:  AD.DR$HabKm2  \nweights: W.Queen    \n\nMoran I statistic standard deviate = 11.724, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.433714579      -0.004032258       0.001394035 \n```\n\n\n:::\n\n```{.r .cell-code}\nmoran.test(AD.DR$HabKm2,          # nom de l'objet sf et de la variable continue\n           listw=W.Queen,         # nom de la matrice de pondération spatiale\n           zero.policy=TRUE,    \n           randomisation = TRUE)  # significativité selon l’hypothèse de la randomisation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  AD.DR$HabKm2  \nweights: W.Queen    \n\nMoran I statistic standard deviate = 11.761, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.433714579      -0.004032258       0.001385364 \n```\n\n\n:::\n\n```{.r .cell-code}\nmoran.mc(AD.DR$HabKm2,            # nom de l'objet sf et de la variable continue\n         listw=W.Queen,           # nom de la matrice de pondération spatiale \n         zero.policy=TRUE, \n         nsim=999)                # 999 permutations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  AD.DR$HabKm2 \nweights: W.Queen  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.43371, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNous calculons la mesure du *I* de Moran sur la variable continue cartographiée à la @fig-IMoranLoiNormale.\n\nLa statistique du *I* de Moran (*I* = 0,43, *p* \\< 0,001) indique que la variable *densité de population* a une forte autocorrélation spatiale positive (@fig-IMoranLoiNormale), avec des valeurs fortes dans les aires de diffusion contiguës dans la partie centrale de la ville et des valeurs faibles dans les aires de diffusion contiguës dans les secteurs périphériques (@fig-CartoADDRSherbrooke).\n\n![Résultats du *I* de Moran selon l'hypothèse de la loi normale](images/Chap02/IdeMoran.png){#fig-IMoranLoiNormale width=\"70%\" fig-align=\"center\"}\n\n##### Étape 3. Identification de la plus forte autocorrélation spatiale selon les différentes matrices {#sec-023143}\n\nLa syntaxe ci-dessous permet de calculer la statistique du *I* de Moran avec plusieurs matrices de pondération spatiale.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Création d'un vecteur pour les noms des matrices\nVecteurMatrices <- c(\"W.Queen\", \"W.Rook\", \"W.Rook2\", \"W.Rook3\", \"W.Rook4\", \"W.Rook5\",\n                     \"W.Connect2500m\",\n                     \"W.InvDistances\", \"W.InvDistances2\",\n                     \"W_InvDistancesReduite\", \"W_InvDistances2Reduite\",\n                     \"W.InvDistances_2500\", \"W.InvDistances_5000\",\n                     \"W.InvDistances2_2500\",\"W.InvDistances2_5000\",\n                     \"W.k2\", \"W.k3\", \"W.k4\", \"W.k5\")\n## Création d'une liste pour toutes les matrices\nListeMatrices <- list(W.Queen, W.Rook, W.Rook2, W.Rook3, W.Rook4, W.Rook5,\n                      W.Connect2500m,\n                      W.InvDistances, W.InvDistances2,\n                      W_InvDistancesReduite, W_InvDistances2Reduite,\n                      W.InvDistances_2500, W.InvDistances2_2500,\n                      W.InvDistances2_2500, W.InvDistances2_5000,\n                      W.k2, W.k3, W.k4, W.k5)\n## Vecteur pour le I de Moran et la valeur de p\nMoranI <- c()\nPvalue <- c()\ni<-0\n## Boucle pour calculer le I de Moran avec la liste des matrices\nfor (e in ListeMatrices){\n   i<-i+1\n   Test <-moran.mc(AD.DR$HabKm2,\n                   listw=e, \n                   zero.policy=TRUE, \n                   nsim=999)\n   MoranI[i]<-Test$statistic\n   Pvalue[i] <- Test$p.value\n}\n# Création d'un DataFrame avec les valeurs du I de Moran et de p\nMoranData1 <- data.frame(Matrices=VecteurMatrices,\n                         MoranIs=MoranI,\n                         Pvalues=Pvalue)\nprint(MoranData1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                 Matrices    MoranIs Pvalues\n1                 W.Queen 0.43371458   0.001\n2                  W.Rook 0.44970946   0.001\n3                 W.Rook2 0.32509097   0.001\n4                 W.Rook3 0.21527754   0.001\n5                 W.Rook4 0.12614476   0.001\n6                 W.Rook5 0.07129756   0.001\n7          W.Connect2500m 0.25583250   0.001\n8          W.InvDistances 0.10632882   0.001\n9         W.InvDistances2 0.27216034   0.001\n10  W_InvDistancesReduite 0.28566705   0.001\n11 W_InvDistances2Reduite 0.38836327   0.001\n12    W.InvDistances_2500 0.32115230   0.001\n13    W.InvDistances_5000 0.40350492   0.001\n14   W.InvDistances2_2500 0.40350492   0.001\n15   W.InvDistances2_5000 0.34988630   0.001\n16                   W.k2 0.51070049   0.001\n17                   W.k3 0.44458619   0.001\n18                   W.k4 0.44800959   0.001\n19                   W.k5 0.43874109   0.001\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLa lecture détaillée du @tbl-TableauIMoranMatrices permet d'avancer plusieurs constats intéressants :\n\n-   D'emblée, signalons que toutes les valeurs sont positives et significatives, témoignant d'une autocorrélation spatiale positive.\n\n-   Concernant les **matrices de contiguïté**, la dépendance spatiale est plus forte selon le partage d'un segment que d'un nœud (0,4497 contre 0,4337). Par conséquent, si nous devons choisir une matrice de contiguïté, il serait préférable d'utiliser celle définie selon le partage d'une chaîne (*Rook*).\n\n-   Sans surprise, plus nous ajoutons des **ordres d'adjacence**, plus la valeur de la statistique du *I* de Moran est faible, passant de 0,3251 à 0,0713 du deuxième au cinquième ordre.\n\n-   La valeur du *I* de Moran avec une **matrice de connectivité** avec 2500 mètres est de 0,2558. Elle est plus faible que celles de l'inverse de la distance et l'inverse de la distance au carré, avec le même seuil de 2500 mètres (0,3212 et 0,4035).\n\n-   Concernant les **matrices de proximité**, la méthode de l'inverse de la distance au carré, qui accorde un poids plus important aux entités spatiales très proches (comparativement à l'inverse de la distance), renvoie des valeurs toujours plus élevées, et ce, que la matrice soit complète ou réduite. Aussi, les matrices de distance réduites présentent toujours des valeurs plus fortes que celles complètes.\n\n-   Concernant les matrices **selon le critère des plus proches voisins**, l'autocorrélation spatiale diminue légèrement de *k* = 2 à *k* = 5. D'ailleurs, la valeur la plus forte est pour deux voisins (*I* = 0,5107). Toutefois, retenir uniquement deux voisins est discutable puisque les AD sont très majoritairement contiguës à plus de deux autres AD (sur les 249 AD, seuls 9 sont contiguës à deux autres AD selon le partage d'un segment). Pour le vérifier, tapez `summary(W.Rook)` et analysez le tableau sous la ligne `Link number distribution`.\n\n\n\n\n\n\n::: {#tbl-TableauIMoranMatrices .cell tbl-cap='Résultats du I de Moran selon les différentes matrices'}\n::: {.cell-output-display}\n`````{=html}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Nom </th>\n   <th style=\"text-align:left;\"> Description </th>\n   <th style=\"text-align:center;\"> I de Moran </th>\n   <th style=\"text-align:center;\"> p (999 permutations) </th>\n  </tr>\n </thead>\n<tbody>\n  <tr grouplength=\"2\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Matrices de contiguïté</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.Queen </td>\n   <td style=\"text-align:left;\"> Partage d’un nœud </td>\n   <td style=\"text-align:center;\"> 0,4337 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.Rook </td>\n   <td style=\"text-align:left;\"> Partage d’un segment </td>\n   <td style=\"text-align:center;\"> 0,4497 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Matrices de contiguïté selon le partage d’un segment et ordre d'adjacence</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.Rook2 </td>\n   <td style=\"text-align:left;\"> Ordre 2 </td>\n   <td style=\"text-align:center;\"> 0,3251 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.Rook3 </td>\n   <td style=\"text-align:left;\"> Ordre 3 </td>\n   <td style=\"text-align:center;\"> 0,2153 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.Rook4 </td>\n   <td style=\"text-align:left;\"> Ordre 4 </td>\n   <td style=\"text-align:center;\"> 0,1261 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.Rook5 </td>\n   <td style=\"text-align:left;\"> Ordre 5 </td>\n   <td style=\"text-align:center;\"> 0,0713 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr grouplength=\"1\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Matrices de connectivité</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.Connect2500m </td>\n   <td style=\"text-align:left;\"> 2500 mètres </td>\n   <td style=\"text-align:center;\"> 0,2558 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr grouplength=\"2\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Matrices de distance (complètes)</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.InvDistances </td>\n   <td style=\"text-align:left;\"> Inverse de la distance </td>\n   <td style=\"text-align:center;\"> 0,1063 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.InvDistances2 </td>\n   <td style=\"text-align:left;\"> Inverse de la distance au carré </td>\n   <td style=\"text-align:center;\"> 0,2722 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr grouplength=\"2\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Matrices de distance (réduites)</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W_InvDistancesReduite </td>\n   <td style=\"text-align:left;\"> Inverse de la distance </td>\n   <td style=\"text-align:center;\"> 0,2857 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W_InvDistances2Reduite </td>\n   <td style=\"text-align:left;\"> Inverse de la distance au carré </td>\n   <td style=\"text-align:center;\"> 0,3884 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Matrices de distance avec un seuil maximal</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.InvDistances_2500 </td>\n   <td style=\"text-align:left;\"> Inverse de la distance (2500 mètres) </td>\n   <td style=\"text-align:center;\"> 0,3212 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.InvDistances_5000 </td>\n   <td style=\"text-align:left;\"> Inverse de la distance (5000 mètres) </td>\n   <td style=\"text-align:center;\"> 0,4035 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.InvDistances2_2500 </td>\n   <td style=\"text-align:left;\"> Inverse de la distance au carré (2500 mètres) </td>\n   <td style=\"text-align:center;\"> 0,4035 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.InvDistances2_5000 </td>\n   <td style=\"text-align:left;\"> Inverse de la distance au carré (5000 mètres) </td>\n   <td style=\"text-align:center;\"> 0,3499 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr grouplength=\"4\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Matrices selon le critère des plus proches voisins</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.k2 </td>\n   <td style=\"text-align:left;\"> 2 voisins </td>\n   <td style=\"text-align:center;\"> 0,5107 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.k3 </td>\n   <td style=\"text-align:left;\"> 3 voisins </td>\n   <td style=\"text-align:center;\"> 0,4446 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.k4 </td>\n   <td style=\"text-align:left;\"> 4 voisins </td>\n   <td style=\"text-align:center;\"> 0,4480 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> W.k5 </td>\n   <td style=\"text-align:left;\"> 5 voisins </td>\n   <td style=\"text-align:center;\"> 0,4387 </td>\n   <td style=\"text-align:center;\"> 0,001 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n\n\n\n**Quelle est la matrice avec laquelle la dépendance spatiale de la variable est la plus forte?**\n\nPour la trouver, nous construisons un graphique avec les valeurs du *I* de Moran triées par ordre décroissant. La valeur la plus forte est obtenue avec la matrice selon les deux plus proches voisins, suivie de la matrice *Rook*. Quoi qu'il en soit, il serait plus judicieux de privilégier la matrice de contiguïté selon le partage d'un segment comme expliqué plus haut.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(data=MoranData1, aes(x=reorder(Matrices,MoranIs), y=MoranIs)) +\n  geom_segment( aes(x=reorder(Matrices,MoranIs), \n                    xend=reorder(Matrices,MoranIs), \n                    y=0, yend=MoranIs)) +\n  geom_point( size=4,fill=\"red\",shape=21)+\n  xlab(\"Matrice de pondération spatiale\") +\n  ylab(\"I de Moran\")+\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![Valeurs du *I* de Moran selon les différentes matrices de pondération spatiale](02-Autocorrelation_files/figure-html/fig-loliplotMoran1-1.png){#fig-loliplotMoran1 fig-align='center' width=75%}\n:::\n:::\n\n\n\n\n\n\n##### Étape 4. Comparaison des valeurs du *I* de Moran pour plusieurs variables avec la même matrice {#sec-023144}\n\nLa syntaxe ci-dessous permet de calculer la statistique du *I* de Moran pour plusieurs variables (@fig-CarteQuatreVariables) avec la même matrice de pondération spatiale (ici, matrice de contiguïté selon le partage d'un segment).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Quatre variables sélectionnées pour les AD de la ville de Sherbrooke](02-Autocorrelation_files/figure-html/fig-CarteQuatreVariables-1.png){#fig-CarteQuatreVariables fig-align='center' width=85%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Vecteur pour les variables à analyser\nlisteVars <- c(\"PctLog1960_Av\", \"RevMedMenage\" , \"PctProprieta\", \"PctPop0_14\")\n\n## Boucle pour calculer le I de Moran pour les différentes variables\nMoranData2 <- t(sapply(listeVars, function(e){\n   Test <- moran.mc(AD.DR[[e]],\n                   listw=W.Rook,\n                   zero.policy=TRUE,\n                   nsim=999)\n   result <- c(round(Test$statistic,4),\n               Test$p.value)\n}))\n\nMoranData2 <- data.frame(MoranData2)\nnames(MoranData2) <- c('MoranIs', 'Pvalues')\nMoranData2$Variable <- listeVars\nrownames(MoranData2) <- NULL\n\nprint(MoranData2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  MoranIs Pvalues      Variable\n1  0.7071   0.001 PctLog1960_Av\n2  0.6168   0.001  RevMedMenage\n3  0.6028   0.001  PctProprieta\n4  0.4474   0.001    PctPop0_14\n```\n\n\n:::\n:::\n\n\n\n\n\n\nDe nouveau, en quelques lignes de code, il est aisé de réaliser un graphique pour comparer les valeurs du *I* de Moran pour les différentes variables (@fig-loliplotMoran2).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\tggplot(data=MoranData2, aes(x=reorder(Variable,MoranIs), y=MoranIs)) + \n\tgeom_segment( aes(x=reorder(Variable,MoranIs), xend=reorder(Variable,MoranIs), y=0, yend=MoranIs)) + \n\tgeom_point( size=4,fill=\"red\",shape=21)+ \n\txlab(\"Variable continue\") + ylab(\"I de Moran\")+ \n\tcoord_flip()\n```\n\n::: {.cell-output-display}\n![Valeurs du *I* de Moran pour les quatre variables](02-Autocorrelation_files/figure-html/fig-loliplotMoran2-1.png){#fig-loliplotMoran2 fig-align='center' width=75%}\n:::\n:::\n\n\n\n\n\n\n### Statistiques de comptage de jointure (*Join Count Statistics*) {#sec-0232}\n\nPour évaluer l'autocorrélation spatiale d'une variable qualitative dichotomique (binaire) ou polychotomique (catégorielle), il convient d'utiliser les ***Join Count Statistics***, qui peuvent être traduits par **statistiques de comptage de jointure**. Ces tests permettent de répondre à la question suivante : est-ce que le voisinage ou la proximité des entités spatiales augmente significativement les chances qu'elles partagent la même valeur (modalité) par rapport à ce que le hasard produirait [@cliff1981spatial]?\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Autocorrélation spatiale sur une variable qualitative**\n:::\n\n::: bloc_objectif-body\nCes statistiques permettent ainsi de vérifier si la distribution des modalités d'une variable binaire ou nominale est dispersée aléatoirement dans l'espace d'étude ou si elle tend à se regrouper spatialement. Voici quelques exemples applicatifs :\n\n-   **Variable binaire** (oui/non; absence/présence d'un phénomène) avec habituellement des valeurs de 0 ou 1. Dans une ville, les parcelles commerciales sont-elles distribuées aléatoirement ou tendent-elle à se regrouper?\n\n-   **Variable qualitative nominale**. À la suite d'une élection dans un pays donné, il s'agit de vérifier si les districts électoraux adjacents ont significativement été remportés par des personnes candidates du même parti. Autre exemple, la répartition d'espèces d'arbres sur un territoire donné est-elle aléatoire ou favorise-t-elle la proximité entre certaines espèces?\n:::\n:::\n\n#### Formulation des statistiques de comptage de jointure {#sec-02321}\n\n##### Application à une variable binaire {#sec-023211}\n\nPour décrire le fonctionnement de ces tests, nous utilisons deux situations fictives avec toutes deux 36 entités spatiales, dont 9 avec la valeur de 1 (noir, soit *B* par convention) et 27 avec la valeur de 0 (blanc, soit *W* par convention) (@fig-JoinCountTest). La relation d'adjacence entre les entités spatiales est ici mesurée à partir d'une matrice de contiguïté selon le partage d'un segment qui est représentée avec un graphe à la @fig-JoinCountTest (b).\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n![Illustration de l'autocorrélation spatiale pour une variable binaire](images/Chap02/JoinCountTest.png){#fig-JoinCountTest width=\"65%\" fig-align=\"center\"}\n\n##### Comptage des jointures {#sec-0232111}\n\nLe comptage des entités voisines partageant la même valeur (BB et WW, soit une autocorrélation spatiale positive) et inversement (WB, soit une autocorrélation spatiale négative) est réalisé comme suit :\n\n-   **Le nombre de voisins partageant la valeur de 1 (autocorrélation positive)** est obtenu avec l'@eq-JoinCountStatisticBB. Lorsque deux entités ne sont pas adjacentes, alors $w_{ij}=0$ et donc $w_{ij}x_ix_j = 0$. Par contre, lorsqu'elles sont voisines, trois cas de figure sont possibles :\n    -   **Toutes deux ont la valeur de 1**, alors $x_ix_j=1\\times1 = 1$.\n    -   Toutes deux ont la valeur de 0, alors $x_ix_j=0\\times0 = 0$.\n    -   Elles ont des valeurs différentes, alors $x_ix_j=1\\times0 = 0$.\n\n$$\n O_{BB} = \\frac{1}{2} \\Sigma_{i=1}^n \\Sigma_{j=1}^n w_{ij} x_i x_j \\text{ avec :}\n$$ {#eq-JoinCountStatisticBB}\n\n*n* étant le nombre d'entités spatiales dans la couche géographique; $w_{ij}$ étant la valeur de la matrice de contiguïté non standardisée entre $i$ et $j$ (1 quand elles sont voisines, sinon 0), $x_i$ et $x_j$ étant les valeurs de la variable binaire (0 ou 1) pour les entités spatiales $i$ et $j$.\n\n-   **Le nombre de voisins partageant la valeur de 0 (autocorrélation positive)** est obtenu avec l'@eq-JoinCountStatisticWW avec les cas suivants lorsque les deux entités sont voisines :\n    -   Toutes deux avec la valeur de 1, alors $(1-x_i) (1-x_j)=(1-1)\\times(1-1) = 0 \\times 0 = 0$.\n    -   **Toutes deux avec la valeur de 0**, alors $(1-x_i) (1-x_j)=(1-0)\\times(1-0) = 1 \\times 1 = 1$.\n    -   Avec des valeurs différentes, alors $(1-x_i) (1-x_j)=(1-1)\\times(1-0) = 0 \\times 1 = 0$.\n\n$$\n O_{WW} = \\frac{1}{2} \\Sigma_{i=1}^n \\Sigma_{j=1}^n w_{ij} (1-x_i) (1-x_j)\n$$ {#eq-JoinCountStatisticWW}\n\n-   **Le nombre de voisins ne partageant pas la même valeur (autocorrélation négative)** est obtenu avec l'@eq-JoinCountStatisticWB avec les cas suivants lorsque les deux entités sont voisines :\n    -   Toutes deux avec la valeur de 1, alors $(x_i-x_j)^2=(1-1)^2 = 0$.\n    -   Toutes deux avec la valeur de 0, alors $(x_i-x_j)^2=(0-0)^2 = 0$.\n    -   **Avec des valeurs différentes**, alors $(x_i-x_j)^2=(1-0)^2 = 1$.\n\n$$\n O_{BW} = \\frac{1}{2} \\Sigma_{i=1}^n \\Sigma_{j=1}^n w_{ij} \\left(x_i-x_j \\right)^2\n$$ {#eq-JoinCountStatisticWB}\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Note**\n:::\n\n::: bloc_notes-body\nPour les trois équations ci-dessus, les sommes sont divisées par 2 puisque les mêmes résultats sont obtenus entre les paires ($i,j$) et ($j,i$). La somme des voisins partageant les mêmes valeurs ($O_{BB}$ et $O_{WW}$) et ayant des valeurs différentes ($O_{BW}$) est égale à la somme de la matrice de contiguïté ($S_0$) divisée par deux (@eq-JoinCountStatistic4).\n\n$$\n  O_{BB} +  O_{WW} +  O_{BW} = \\frac{1}{2}S_0= \\frac{1}{2} \\Sigma_{i=1}^n \\Sigma_{j=1}^n w_{ij}\n$$ {#eq-JoinCountStatistic4}\n:::\n:::\n\nLes résultats des comptages pour les situations A et B (@fig-JoinCountTest) sont présentés au @tbl-TableauJC. Ils démontrent clairement que les regroupements des valeurs de 0 et 1 sont bien plus importants pour la situation A (BB = 12 et WW = 42) que celle de B (BB = 1 et WW = 33). Reste à vérifier si ces résultats sont significatifs, c'est-à-dire s'ils diffèrent de ce que le hasard produirait.\n\n\n\n\n\n\n::: {#tbl-TableauJC .cell tbl-cap='Comptages des jointures'}\n::: {.cell-output-display}\n\n\n|Situation                            | BB| WW| WB| Somme|\n|:------------------------------------|--:|--:|--:|-----:|\n|A (forte autocorrélation spatiale)   | 12| 42|  6|    60|\n|B (absence autocorrélation spatiale) |  1| 33| 26|    60|\n\n\n:::\n:::\n\n\n\n\n\n\n##### Tests statistiques {#sec-0232112}\n\nIl existe deux approches d'inférence pour déterminer si des observations voisines tendent à produire certaines paires de catégories (BB, WW ou WB) plus souvent que le hasard : les tests reposant sur la loi binomiale et les tests par permutations. Notez que la seconde approche est habituellement privilégiée.\n\n**Tests selon la loi binomiale**\n\nCes tests permettent d'obtenir les valeurs attendues des paires BB, WW et WB pour une absence d'autocorrélation spatiale, puis des valeurs de Z (@eq-JoinCountStatisticsZ) et de *p*.\n\n$$\nZ_{WW} = \\frac{O[WW] - E[WW]}{\\sqrt{\\text{Var}[WW]}} \\\\\nZ_{BB} = \\frac{O[BB] - E[BB]}{\\sqrt{\\text{Var}[BB]}} \\\\\nZ_{WB} = \\frac{O[WB] - E[WB]}{\\sqrt{\\text{Var}[WB]}}\\text{ avec :}\n$$ {#eq-JoinCountStatisticsZ}\n\n$O[WW]$, $O[BB]$ et $O[WB]$ étant les nombres de paires observées; $E[WW]$, $E[BB]$ et $E[WB]$ étant les nombres de paires attendues et $\\text{Var}[WW]$, $\\text{Var}[BB]$ et $\\text{Var}[WB]$ leurs variances selon la loi binomiale pour une distribution aléatoire. Pour une description détaillée des formules des valeurs attendues et des variances selon les deux types d'échantillons (indépendant et dépendant) et selon le type de matrice de pondération spatiale (standardisée ou non), consultez l'ouvrage de Wong et Lee [-@wong2005statistical].\n\nAussi, le calcul des valeurs de Z repose sur deux cas de figure :\n\n1.  **Échantillon dépendant** (*non free Sampling*). Le nombre de valeurs possibles de chaque catégorie est défini en amont et ne peut pas changer. Prenons l'exemple suivant : nous souhaitons vérifier si deux restaurants voisins ont tendance à avoir une licence d'alcool (BB) ou non (WW). Si le nombre de licences d'alcool est réglementé, alors la probabilité d'en avoir une dépend du nombre de licences en circulation (échantillon dépendant).\n\n2.  **Échantillon indépendant** (*free Sampling*). Pour chaque entité spatiale, la probabilité d'avoir une catégorie est indépendante du nombre d'observations. En d'autres termes, il n'y a pas un nombre défini d'observations pour chaque catégorie (W ou B) qui sont réparties entre les entités spatiales (échantillon indépendant).\n\nBien distinguer ces deux configurations est essentiel, car elles affectent directement les valeurs des variances et par ricochet celles de Z et de *p* (voir les tableaux [-@tbl-TableauJC2] et [-@tbl-TableauJC]). Avec un test basé sur un échantillon indépendant pour la situation A, nous concluons que les valeurs de 1 et de 0 (BB et WW) ne sont pas distribuées aléatoirement puisque *p* \\< 0,05, ce qui traduit une autocorrélation spatiale. Par contre, pour la situation B, toutes les valeurs de *p* sont supérieures à 0,05, ce qui ne nous permet pas de rejeter l'hypothèse nulle d'une distribution aléatoire selon la loi binomiale.\n\n\n\n\n\n\n::: {#tbl-TableauJC2 .cell tbl-cap='Statistiques de comptage de jointures pour BB (tests basés sur la loi binomiale)'}\n::: {.cell-output-display}\n\n\n|                            | O[BB]| E[BB]| Var[BB]|      Z|     p|\n|:---------------------------|-----:|-----:|-------:|------:|-----:|\n|A (échantillon dépendant)   |    42| 33,43|    3,73|  4,439| 0,000|\n|A (échantillon indépendant) |    42| 33,75|   45,98|  1,217| 0,112|\n|B (échantillon dépendant)   |    33| 33,43|    3,73| -0,222| 0,588|\n|B (échantillon indépendant) |    33| 33,75|   45,98| -0,111| 0,544|\n\n\n:::\n:::\n\n::: {#tbl-TableauJC3 .cell tbl-cap='Statistiques de comptage de jointures pour WW (tests basés sur la loi binomiale)'}\n::: {.cell-output-display}\n\n\n|Situation et test           | O[WW]| E[WW]| Var[WW]|      Z|     p|\n|:---------------------------|-----:|-----:|-------:|------:|-----:|\n|A (échantillon dépendant)   |    12|  3,43|    2,09|  5,922| 0,000|\n|B (échantillon indépendant) |    12|  3,75|    6,98|  3,122| 0,001|\n|B (échantillon dépendant)   |     1|  3,43|    2,09| -1,678| 0,953|\n|B (échantillon indépendant) |     1|  3,75|    6,98| -1,041| 0,851|\n\n\n:::\n:::\n\n\n\n\n\n\n**Tests par permutations**\n\nCette seconde approche d'inférence est très simple et consiste à :\n\n1.  Mélanger les observations du jeu de données de nombreuses fois (habituellement 999).\n2.  Pour chaque permutation, compter les jointures BB, WW et WB.\n3.  Estimer la pseudo valeur de *p* à partir de l'@eq-JoinCountPermutation. Cette valeur peut être interprétée comme la probabilité que le hasard génère plus souvent une paire (BB, WW ou WB) que ce qui est observé avec le jeu de données initial.\n\n$$\n  \\text{Pseudo valeur de } p = (M+1)/ (R+1) \\text{ avec :}\n$$ {#eq-JoinCountPermutation}\n\n$M$ étant le nombre de fois que le comptage de jointures (BB ou WW par exemple) est égal ou supérieur à la valeur de référence ($O_{BB}$ ou $O_{WW}$ par exemple) et $R$ étant le nombre de permutations (habituellement 999).\n\nEn guise d'exemple, nous réalisons 999 permutations des valeurs de la situation A qui comprend 12 paires de BB, 42 de WW et 6 de WB. Les comptages de BB et WW pour ces 999 permutations sont représentés à la @fig-JoinCountStatisticPermFigA. Nous constatons qu'elles sont toujours inférieures aux valeurs de référence (BB = 12 et WW = 42; lignes bleues). Par conséquent, la pseudo valeur de *p* est égale à $(0+1)/(999+1)=\\text{0,001}$. Cela signifie que nous ne pouvons pas rejeter l'hypothèse nulle stipulant que les distributions des paires BB et WW sont dues au hasard.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Résultats des 999 permutations pour la situation A](02-Autocorrelation_files/figure-html/fig-JoinCountStatisticPermFigA-1.png){#fig-JoinCountStatisticPermFigA fig-align='center' width=75%}\n:::\n:::\n\n\n\n\n\n\nEffectuons la même démarche pour la situation B avec une seule paire de BB et 33 paires de WW (@fig-JoinCountStatisticPermFigB) :\n\n-   pour BB, il y a 984 permutations qui ont une valeur supérieure ou égale à 1. La pseudo valeur de *p* est égale à $(984+1)/(999+1)=\\text{0,985}$.\n\n-   pour WW, il y a 653 permutations qui ont une valeur supérieure ou égale à 1. La pseudo valeur de *p* est égale à $(653+1)/(999+1)=\\text{0,653}$.\n\nPar conséquent, nous validons l'hypothèse nulle stipulant que les distributions des paires BB et WW sont dues au hasard pour la situation B.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Résultats des 999 permutations pour la situation B](02-Autocorrelation_files/figure-html/fig-JoinCountStatisticPermFigB-1.png){#fig-JoinCountStatisticPermFigB fig-align='center' width=75%}\n:::\n:::\n\n\n\n\n\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Comment réaliser une permutation aléatoire des valeurs d'un vecteur dans R?**\n:::\n\n::: bloc_astuce-body\nDans R, la fonction `sample(x)` permet de permuter les valeurs d'un vecteur.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Valeurs initiales pour les 36 observations (cas A)\nprint(Carres$CasA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 1 1 0 0 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\n## Valeurs permutées\nprint(sample(Carres$CasA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n:::\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Importance de la matrice de voisinage pour le *Join count Test***\n:::\n\n::: bloc_attention-body\nQuelle que soit la méthode utilisée pour effectuer le *Join count Test*, le test est sensible à la définition de la matrice de voisinage, définie selon le partage d'un segment ou d'un nœud (*Queen* ou *Rook*). Elle affecte directement le nombre de paires observées et attendues et donc le niveau de significativité de l'autocorrélation spatiale.\n:::\n:::\n\n#### Mise en œuvre dans R {#sec-02322}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Calcul des statistiques de comptage de jointure dans R**\n:::\n\n::: bloc_objectif-body\nPour illustrer le calcul des statistiques de comptage de jointure (*Join Count Statistics*) dans R, nous utilisons une couche des aires de diffusion (AD) de la ville de Sherbrooke afin de répondre à la question suivante : les AD avec une majorité de locataires et celles avec une majorité de propriétaires sont-elles significativement voisines les unes des autres (autocorrélation spatiale positive) à Sherbrooke?\n:::\n:::\n\nDans le code ci-dessous, nous importons la couche géographique, créons une variable binaire indiquant si l'aire de diffusion a ou non une majorité de locataires et finalement, cartographions cette variable. Sans surprise, les AD avec une majorité de locataires sont concentrées dans la partie centrale de la ville (@fig-MajLoc).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Chargement des données des aires de diffusion de la ville de Sherbrooke\nADSherb <- st_read(\"data/chap02/Recen2021Sherbrooke.gpkg\", \n                   layer=\"DR_SherbADDonnees2021\",\n                   quiet=TRUE)\n## Création de la variable binaire\nADSherb$maj_locataires <- ifelse(ADSherb$Locataire > ADSherb$Proprietaire, 1, 0)\nADSherb$maj_locataires <- factor(ADSherb$maj_locataires,\n                                 levels =c(0,1),\n                                 labels=c(\"Propriétaires\", \"Locataires\"))\n## Cartographie de la variable binaire\ntmap_mode(\"plot\")\ntm_shape(ADSherb)+\n  tm_borders(col=\"black\", lwd=0.5)+\n  tm_fill(col=\"maj_locataires\", \n          palette=c(\"#ededed\", \"#706f6f\"),\n          title = \"Groupe majoritaire\")+\n  tm_layout(frame=FALSE)+\n  tm_scale_bar(breaks=c(0,5))+\n  tm_credits(\"Source : Statistique Canada, 2021.\", align = \"left\")\n```\n\n::: {.cell-output-display}\n![Aires de diffusion avec une majorité de locataires ou de propriétaires, Sherbrooke, 2021](02-Autocorrelation_files/figure-html/fig-MajLoc-1.png){#fig-MajLoc fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\nPour calculer les statistiques de comptage de jointure, nous utilisons une matrice de contiguïté selon le partage d'un nœud (*Queen*). Notez que pour ces statistiques, il est préférable de ne pas standardiser la matrice spatiale (`style = \"B\"`), car nous souhaitons compter le nombre de paires formées par les deux catégories d'AD.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nQueen <- poly2nb(ADSherb, queen = TRUE)\nWQueen <- nb2listw(Queen, style = \"B\")\n```\n:::\n\n\n\n\n\n\nPour réaliser les tests selon la méthode d'inférence basée sur la loi binomiale, nous utilisons la fonction `joincount.test` du *package* `spdep`. Le paramètre `sampling = \"free\"` permet de spécifier le calcul des variances selon un échantillon indépendant, puisque les nombres d'AD dans lesquelles les locataires ou les propriétaires sont majoritaires n'ont pas de limites fixes.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest1 <- joincount.test(ADSherb$maj_locataires, listw = WQueen, sampling = \"free\")\nprint(test1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tJoin count test under free sampling\n\ndata:  ADSherb$maj_locataires \nweights: WQueen \n\nStd. deviate for Propriétaires = 3.2832, p-value = 0.0005132\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n             244.0000              163.4227              602.3289 \n\n\n\tJoin count test under free sampling\n\ndata:  ADSherb$maj_locataires \nweights: WQueen \n\nStd. deviate for Locataires = 3.7367, p-value = 9.324e-05\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n             319.0000              214.8323              777.1427 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nLes résultats du test présentés à la @fig-joincountTest s'interprètent comme suit :\n\n-   **a. Valeurs observées** : 244 AD sont voisines et majoritairement occupées par des propriétaires contre 319 pour les locataires.\n\n-   **b. Valeurs attendues** : 163,4227 pour une majorité de propriétaires et 214,8323 pour une majorité de locataires.\n\n-   **c. variances** pour les deux groupes selon la loi binomiale avec un échantillon indépendant (602,3289 et 777,1427).\n\n-   **d. Valeurs Z**, soit $(244-\\text{163,4227})/\\sqrt{\\text{602,3289}}=\\text{3,2832}$ et $(319-\\text{214,8323})/\\sqrt{\\text{777,1427}}=\\text{3,7367}$.\n\n-   **e. Valeurs de *p*** sont inférieures à 0,005, signalant que les deux modalités de la variable binaire sont significativement autocorrélées positivement selon la matrice de contiguïté.\n\n![Résultats des statistiques de comptage de jointure avec la fonction `joincount.test`](images/Chap02/JointCountTest_Locataires.png){#fig-joincountTest width=\"70%\" fig-align=\"center\"}\n\nÀ des fins de comparaison, nous effectuons le calcul des statistiques de comptage de jointure avec l'approche d'inférence selon le test des permutations (999) avec la fonction `joincount.mc`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest2 <- joincount.mc(ADSherb$maj_locataires, listw = WQueen, nsim = 999)\nprint(test2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of join-count statistic\n\ndata:  ADSherb$maj_locataires \nweights: WQueen \nnumber of simulations + 1: 1000 \n\nJoin-count statistic for Propriétaires = 244, rank of observed\nstatistic = 1000, p-value = 0.001\nalternative hypothesis: greater\nsample estimates:\n    mean of simulation variance of simulation \n              162.7778               103.7983 \n\n\n\tMonte-Carlo simulation of join-count statistic\n\ndata:  ADSherb$maj_locataires \nweights: WQueen \nnumber of simulations + 1: 1000 \n\nJoin-count statistic for Locataires = 319, rank of observed statistic =\n1000, p-value = 0.001\nalternative hypothesis: greater\nsample estimates:\n    mean of simulation variance of simulation \n              213.9459               122.7065 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nL'approche d'inférence basée sur les permutations signale aussi que les deux distributions sont significativement autocorrélées spatialement (*p* = 0,001).\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Fonction `joincount.multi`**\n:::\n\n::: bloc_aller_loin-body\nPour une variable qualitative comprenant plus de deux modalités (catégories), utilisez la fonction `joincount.multi` du *package* `spdep`. Cependant, celle-ci ne renvoie pas de valeurs de *p*, mais uniquement des valeurs de Z et des variances pour chaque modalité. Il est possible d'obtenir des valeurs de *p* en utilisant la fonction `pnorm` et surtout en ajustant ces valeurs de *p* pour contrôler l'effet de la multiplication des tests de significativité avec la fonction `p.adjust`.\n:::\n:::\n\n### Indice de Lee : autocorrélation spatiale dans un contexte bivarié {#sec-0233}\n\nÀ la [section @sec-0231], nous avons vu que le *I* de Moran permet d'évaluer le degré d'autocorrélation spatiale d'une variable continue, c'est-à-dire de vérifier si les entités spatiales proches ou voisines ont tendance à avoir des valeurs (dis)similaires pour une seule variable continue. Il est logique de vouloir étendre cette analyse à un contexte bivarié : est-ce que deux variables continues partagent ou non une relation marquée par de l'autocorrélation spatiale? En d'autres termes, l'association spatiale bivariée cherche à capturer la présence d'un patron spatial commun pour les deux variables [@lee2001developing].\n\n#### Formulation de l'indice de Lee {#sec-02331}\n\nIl est important de distinguer la corrélation (non spatiale) entre deux variables et l'autocorrélation spatiale entre deux variables. La première mesure à quel point deux variables tendent à avoir une relation linéaire positive ou négative, alors que la seconde mesure la présence d'un patron spatial commun. Prenons l'exemple d'un jeu de données fictives avec 25 observations et deux variables continues *X* et *Y* (@tbl-TabFictives2Vars).\n\n\n\n\n\n\n::: {#tbl-TabFictives2Vars .cell tbl-cap='Jeu de données fictives avec 25 observations et deux variables'}\n::: {.cell-output-display}\n\n\n|   X   |   Y    |\n|:-----:|:------:|\n| -1,77 | -6,10  |\n| -1,43 | -5,52  |\n| 0,78  |  0,56  |\n| 1,58  |  4,11  |\n| -1,73 | -7,12  |\n| -2,04 | -2,74  |\n| 2,05  |  6,06  |\n| -2,48 | -4,30  |\n| -4,69 | -16,07 |\n| -1,71 | -6,41  |\n| -2,00 | -0,66  |\n| -1,95 | -13,67 |\n| 1,14  |  2,64  |\n| 1,01  |  2,66  |\n| -1,58 | -8,89  |\n| -0,39 |  0,33  |\n| -0,69 | -8,20  |\n| -0,29 |  0,59  |\n| -0,37 | -1,89  |\n| 0,91  |  4,71  |\n| -0,38 | -0,61  |\n| -0,29 | -1,12  |\n| -0,07 |  1,59  |\n| -4,15 | -11,19 |\n| 1,97  |  6,62  |\n\n\n:::\n:::\n\n\n\n\n\n\nCes deux variables sont caractérisées par une forte corrélation linéaire positive avec un coefficient de corrélation de Pearson proche de 1 (@fig-FigCorrelation).\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Retour sur la notion de corrélation entre deux variables continues**.\n:::\n\n::: bloc_notes-body\nPour un rappel sur la notion de corrélation entre deux variables continues, notamment sur l'interprétation du coefficient de corrélation de Pearson, nous vous invitons à lire la [section suivante](https://serieboldr.github.io/MethodesQuantitatives/04-bivarieeQuantiQuanti.html#sec-043) [@RBoldAir].\n:::\n:::\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Relation entre deux variables continues et coefficients de corrélation de Pearson](02-Autocorrelation_files/figure-html/fig-FigCorrelation-1.png){#fig-FigCorrelation fig-align='center' width=75%}\n:::\n:::\n\n\n\n\n\n\nCependant, cette information relative à la corrélation entre les deux variables ne nous permet pas d'appréhender leurs caractéristiques spatiales. En effet, ce tableau de données peut correspondre aux différents patrons spatiaux. En examinant les cartes **a** à **d** de la @fig-ExMapBivar, nous constatons l'absence de tout patron spatial apparent. Par contre, à la @fig-ExMapBivar (e), nous observons une configuration spatiale particulière : à la fois, une forte autocorrélation spatiale positive univariée de chacune des deux variables (X et Y) et une forte autocorrélation spatiale positive bivariée puisque les deux patrons spatiaux de X et Y sont similaires.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Exemples de patrons spatiaux sans et avec autocorrélation spatiale dans un contexte bivarié](02-Autocorrelation_files/figure-html/fig-ExMapBivar-1.png){#fig-ExMapBivar fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n\n\nMaintenant que nous avons fait la distinction entre la **corrélation bivariée** et **l'autocorrélation spatiale bivariée**, nous pouvons présenter un indicateur d'autocorrélation spatiale globale bivariée, soit l'indice de Lee [-@lee2001developing]. Cet indicateur est construit à partir du produit de l'autocorrélation univariée de chacune des deux variables (numérateur) et de la corrélation de Pearson entre les versions spatialement décalées de ces variables (dénominateur). La formule de l'indicateur est la suivante :\n\n$$\n\\begin{aligned}\nL_{X, Y}=\\frac{n}{\\sum_i\\left(\\sum_j v_{i j}\\right)^2} \\cdot \\frac{\\sum_i\\left[\\left(\\sum_j v_{i j}\\left(x_j-\\bar{x}\\right)\\right) \\cdot\\left(\\sum_j v_{i j}\\left(y_j-\\bar{y}\\right)\\right)\\right]}{\\sqrt{\\sum_i\\left(x_i-\\bar{x}\\right)^2} \\sqrt{\\sum_i\\left(y_i-\\bar{y}\\right)^2}}\n\\end{aligned}\n$$ {#eq-Lee1}\n\nSi la matrice de pondération spatiale est standardisée en ligne, l'indice de Lee est simplifié comme suit :\n\n$$\n\\begin{aligned}\nL_{X, Y}= \\frac{\\sum_i\\left[\\left(\\sum_j v_{i j}\\left(x_j-\\bar{x}\\right)\\right) \\cdot\\left(\\sum_j v_{i j}\\left(y_j-\\bar{y}\\right)\\right)\\right]}{\\sqrt{\\sum_i\\left(x_i-\\bar{x}\\right)^2} \\sqrt{\\sum_i\\left(y_i-\\bar{y}\\right)^2}}\n\\end{aligned}\n$$ {#eq-Lee2}\n\nCet indicateur varie entre -1 (autocorrélation spatiale bivariée négative) et +1 (autocorrélation bivariée positive).\n\nNous présentons trois cas à la @fig-ExMapBivar3 pour illustrer son interprétation. Prenons trois variables X, Y et X', avec X' étant l'inverse spatial de X. Pour simplifier l'exemple, ces trois variables ne peuvent avoir que trois valeurs (1, 2 ou 3).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Patrons spatiaux de X, Y et X'](02-Autocorrelation_files/figure-html/fig-ExMapBivar3-1.png){#fig-ExMapBivar3 fig-align='center' width=75%}\n:::\n:::\n\n\n\n\n\n\nSi nous calculons l'autocorrélation spatiale entre toutes les paires de variables avec une matrice de contiguïté standardisée, nous obtenons la matrice au @tbl-ExampleBivarLeeTab1. Les résultats démontrent que les variables $X$ et $Y$ partagent un patron d'autocorrélation spatiale positive modérée ($0{,}327$), alors que les variables $X$ et $X^{\\prime}$ partagent un patron d'autocorrélation spatiale négative ($-0{,}512$). En d'autres termes, les endroits où $X$ tend à avoir des regroupements d'observations avec des valeurs fortes, $X^{\\prime}$ tend à avoir des regroupements d'observations avec des valeurs faibles.\n\n\n\n\n\n\n\n::: {#tbl-ExampleBivarLeeTab1 .cell tbl-cap='Indice de Lee global'}\n::: {.cell-output-display}\n\n\n|   |   X    |   Y    |   X'   |\n|:--|:------:|:------:|:------:|\n|X  |        | 0,327  | -0,512 |\n|Y  | 0,327  |        | -0,293 |\n|X' | -0,512 | -0,293 |        |\n\n\n:::\n:::\n\n\n\n\n\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Significativité du test de Lee**\n:::\n\n::: bloc_astuce-body\nAu même titre que pour les indicateurs vus précédemment, il est possible de tester si l'indice de Lee obtenu est significativement différent de 0 avec des permutations Monte-Carlo.\n:::\n:::\n\n#### Mise en œuvre dans R {#sec-02332}\n\nPour décrire le calcul de l'indice de Lee dans R, nous utilisons le jeu de données spatiales `LyonIris` du *package* `geocmeans` qui comprend quatre variables environnementales : le bruit routier (Lden dB(A)) (`Lden`), le dioxyde d'azote (ug/m^3^) (`NO2`), les particules fines PM~2,5~ (`PM25`) et la canopée (%) (`VegHautPrt`) pour les îlots regroupés pour l'information statistique (IRIS) de l'agglomération lyonnaise (@fig-datageocmeans1).\n\n![Cartographie des variables du jeu de données LyonIris](images/Chap02/FigureDataLyon.png){#fig-datageocmeans1 width=\"100%\" fig-align=\"center\"}\n\nIl est facile de calculer l'indice de Lee en utilisant les fonctions `lee.test(x, y, listw)`,`lee.mc(x, y, listw)` ou `lee(x, y, listw, n)` du package `spdep`. Par exemple, le code ci-dessous permet de le calculer pour les variables `Lden` et `NO2`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(geocmeans)\ndata(\"LyonIris\")\n## Matrice de pondération spatiale de contiguïté standardisée\nnb <- poly2nb(LyonIris, queen = TRUE)\nWmat <- nb2listw(nb, style = 'W')\n## Calcul de l'indice de Lee entre les deux variables\nlee.test(LyonIris$Lden, LyonIris$NO2, listw = Wmat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tLee's L statistic randomisation\n\ndata:  LyonIris$Lden ,  LyonIris$NO2 \nweights: Wmat  \n\nLee's L statistic standard deviate = 17.135, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nLee's L statistic       Expectation          Variance \n     0.4072785543      0.1243825152      0.0002725625 \n```\n\n\n:::\n\n```{.r .cell-code}\nlee.mc(LyonIris$Lden, LyonIris$NO2, listw = Wmat, nsim = 999)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Lee's L\n\ndata:  LyonIris$Lden ,  LyonIris$NO2 \nweights: Wmat  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.40728, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSi vous analysez plusieurs variables simultanément, il est pertinent de construire à la fois une matrice de corrélation et une matrice d'autocorrélation spatiale bivariée. Pour cette dernière, la diagonale peut être remplacée par le *I* de Moran de chaque variable.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Liste des variables à analyser\nvars <- c(\"Lden\",\"NO2\",\"PM25\",\"VegHautPrt\")\n## Calcul de la matrice de corrélation de Pearson\ncorr_mat <- cor(st_drop_geometry(LyonIris)[vars])\n## Calcul d'une matrice d'autocorrélation spatiale bivariée (indice de Lee)\nbivar_autocor_mat <- sapply(vars, function(x1){\n  row_values <- sapply(vars, function(x2){\n    test <- lee(LyonIris[[x1]], LyonIris[[x2]], listw = Wmat, n = nrow(LyonIris))\n    return(test$L)\n  })\n})\n# Remplacement de la diagonale par les valeurs du I de Moran\nmoranIs <- sapply(vars, function(x){\n  moran(LyonIris[[x]], Wmat, n = nrow(LyonIris), S0 = nrow(LyonIris))[[1]]\n})\ndiag(bivar_autocor_mat) <- moranIs\n```\n:::\n\n::: {#tbl-LeeCorrTable .cell tbl-cap='Matrice de corrélation de Pearson'}\n::: {.cell-output-display}\n\n\n|           |  Lden  |  NO2   |  PM25  | VegHautPrt |\n|:----------|:------:|:------:|:------:|:----------:|\n|Lden       | 1,000  | 0,623  | 0,489  |   -0,227   |\n|NO2        | 0,623  | 1,000  | 0,901  |   -0,283   |\n|PM25       | 0,489  | 0,901  | 1,000  |   -0,392   |\n|VegHautPrt | -0,227 | -0,283 | -0,392 |   1,000    |\n\n\n:::\n:::\n\n\n\n\n\n\nSans surprise, les différents polluants sont corrélés positivement entre eux et moyennement corrélés négativement avec le couvert végétal. La corrélation la plus forte s'observe entre le dioxyde d'azote et les particules fines (*r* = 0,901; @tbl-LeeCorrTable).\n\nLa lecture de la diagonale du @tbl-LeeBiarAutoCorrTable permet de constater que les deux polluants atmosphériques sont les plus fortement spatialement autocorrélés (*I* de Moran de 0,82 et 0,94). Leur valeur de l'indice de Lee est aussi très forte (0,79), indiquant qu'ils tendent à varier de façon conjointe dans l'espace. En revanche, l'autocorrélation spatiale entre le bruit environnemental (Lden) et le dioxyde d'azote (indice de Lee de 0,41) est à peine plus forte que celle entre le Lden et les particules fines (indice de Lee de 0,38) alors que l'écart de la corrélation entre ces paires de variables est bien plus important (respectivement de 0,62 et 0,49). La corrélation non spatiale marquée entre le bruit et le dioxyde d'azote ne se traduit que par une autocorrélation spatiale bivariée modérée (0,41). La géographie de ces deux pollutions ne peut donc se résumer à un patron commun.\n\n\n\n\n\n\n::: {#tbl-LeeBiarAutoCorrTable .cell tbl-cap='Matrice d\\'autocorrélation spatiale globale bivariée (indice de Lee)'}\n::: {.cell-output-display}\n\n\n|           |  Lden  |  NO2   |  PM25  | VegHautPrt |\n|:----------|:------:|:------:|:------:|:----------:|\n|Lden       | 0,561  | 0,407  | 0,379  |   -0,231   |\n|NO2        | 0,407  | 0,819  | 0,789  |   -0,283   |\n|PM25       | 0,379  | 0,789  | 0,935  |   -0,412   |\n|VegHautPrt | -0,231 | -0,283 | -0,412 |   0,585    |\n\n\n:::\n:::\n\n\n\n\n\n\n## Autocorrélation spatiale locale {#sec-024}\n\nNous avons vu que les statistiques d'autocorrélation spatiale globale comme le *I* de Moran ([section @sec-0231]), les statistiques de comptage de jointures ([section @sec-0232]) et l'indice de Lee ([section @sec-0233]) renvoient une valeur pour l'ensemble de l'espace d'étude. Une fois démontrée la présence d'autocorrélation spatiale globale (positive ou négative), il est pertinent de réaliser une analyse de l'autocorrélation spatiale locale afin de vérifier si chaque entité spatiale est significativement (dis)semblable de celles voisines ou proches. Comme l'indique l'adjectif *locale*, les mesures d'autocorrélation spatiale locale renvoient des valeurs pour chacune des entités spatiales.\n\n### Statistiques locales de Getis et Ord : repérer les points chauds et froids pour une variable continue {#sec-0241}\n\n#### Formulation des statistiques locale de Getis et Ord {#sec-02411}\n\nLes statistiques locales de Getis et Ord permettent d'évaluer la similarité d'une entité spatiale avec celles voisines ou proches en fonction **d'une variable continue** [@getis1992analysis; @ord1995local]. Autrement dit, elles nous informent si les valeurs fortes et les valeurs faibles d'une variable continue se regroupent significativement dans l'espace, et ce, avec n'importe quel type de matrice de contiguïté, de proximité, de plus proches voisins, etc. Cartographier ces statistiques permet alors de vérifier simultanément l'existence d'agrégats spatiaux de valeurs fortes (**points chauds**) et d'agrégats spatiaux de valeurs faibles (**points froids**).\n\nIl existe deux versions légèrement différentes de ces mesures locales [@getis1992analysis; @ord1995local] :\n\n1.  $G_i$ tient compte uniquement des entités voisines ou proches à l'entité spatiale $i$. Ainsi, $\\Sigma_{j=1}^n w_{ij}x_j$ représente la moyenne pondérée (par les poids de la matrice de pondération spatiale standardisée en ligne) de la variable continue $X$ dans les entités voisines ou proches.\n\n2.  $G_i^*$ tient compte à la fois des valeurs des entités voisines ou proches, mais aussi de celle de $i$.\n\nToutefois, nous cartographions rarement les valeurs de $G_i$ et de $G_i^*$, mais plutôt celles de $Z(G_i)$ et de $Z(G_i^*)$ (@eq-LocalGetis et @eq-LocalGetisStar) qui représentent la cote Z qui, lorsque positive, indique un agrégat de valeurs plus élevées que la moyenne, et qui, lorsque négative, indique un agrégat de valeurs plus faibles que la moyenne [@bivand2018comparing].\n\nÀ première vue, ces deux formules peuvent sembler quelque peu complexes! Retenez simplement que le numérateur est la différence entre $G_i$ ou $G_i^*$ et la valeur attendue de $G_i$ ou de $G_i^*$ pour une distribution aléatoire (soit globalement la moyenne de la variable), tandis que le dénominateur représente l'écart-type de $G_i$ ou de $G_i^*$.\n\n$$\nZ(G_i) = \\frac{\\bigr[ \\Sigma_{j=1}^n w_{ij}x_j \\bigr] - \\bigr[ (\\Sigma_{j=1}^nw_{ij}) \\bar x_i \\bigr]}\n{s_i \\sqrt{ \\Bigr[ \\Bigl((n-1)\\Sigma_{j=1}^nw_{ij}^2-(\\Sigma_{j=1}^nw_{ij})^2\\Bigl) \\Bigr] / (n-1) } } = \\frac{G_i - \\mathbb{E}(G_i)}{\\sqrt{Var(G_i)}} \\text{, }i \\neq j\n$$ {#eq-LocalGetis}\n\n$$\\text{avec } \\bar x_i=\\frac{\\Sigma_{j=1}^nx_j}{n-1}  \\text{, et } s_i = \\sqrt{ \\frac{\\Sigma_{j=1}^nx_j^2}{n-1}-\\bar x^2} \\text{, } i \\neq j$$ $$\nZ(G_i^*) = \\frac{\\bigr[ \\Sigma_{j=1}^n w_{ij}x_j \\bigr] - \\bigr[ (\\Sigma_{j=1}^nw_{ij}) \\bar x^* \\bigr]}\n{s^* \\sqrt{ \\Bigr[ \\Bigl((n-1)\\Sigma_{j=1}^nw_{ij}^2-(\\Sigma_{j=1}^nw_{ij})^2\\Bigl) \\Bigr] / (n-1) } } = \\frac{G_i^* - \\mathbb{E}(G_i^*)}{\\sqrt{Var(G_i^*)}}\\text{, tous }\n$$ {#eq-LocalGetisStar}\n\n$$\\text{avec } \\bar x^*=\\frac{\\Sigma_{j=1}^nx_j}{n}  \\text{, et } s^* = \\sqrt{ \\frac{\\Sigma_{j=1}^nx_j^2}{n}-\\bar x^{*2}} \\text{, tous } j$$ avec :\n\n-   *n*, le nombre d'entités spatiales dans la couche géographique;\n\n-   $w_{ij}$, la valeur de la pondération spatiale entre les entités spatiales $i$ et $j$;\n\n-   $x_j$, la valeur de variable continue $X$ pour l'entité spatiale $j$;\n\n-   $\\bar{x^*}$, la valeur moyenne de la variable pour toutes les observations;\n\n-   $\\bar{x_i}$, la valeur moyenne de la variable pour toutes les observations sauf $i$.\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Deux manières de calculer** $Z(G_i)$ et $Z(G_i^*)$ avec le *package* `spdep`\n:::\n\n::: bloc_astuce-body\n-   la fonction `localG` vous renvoie les valeurs de cote Z (*Z-score* en anglais) des statistiques de Getis et Ord avec les formules décrites plus haut.\n-   la fonction `localG_perm` permet de les obtenir avec la méthode Monte-Carlo (avec habituellement 999 permutations).\n\n**Cartographie des cotes Z**\n\nÀ partir des cotes Z, utilisez les bornes des classes suivantes et la palette de couleurs `-RdBu` :\n\n-   Minimum à -3,29 : point froid significatif avec *p* \\< 0,001 (bleu foncé).\n-   -3,29 à -2,58 : point froid significatif avec *p* \\< 0,01 (bleu).\n-   -2,58 à -1,96 : point froid significatif avec *p* \\< 0,05 (bleu pâle).\n-   -1,96 à 1,96 : non significatif (gris).\n-   1,96 à 2,58 : point chaud significatif avec *p* \\< 0,05 (rouge pâle).\n-   2,58 à 3,29 : point chaud significatif avec *p* \\< 0,01 (rouge).\n-   3,29 à Maximum : point chaud significatif avec \\*p \\<0 ,001 (rouge foncé).\n\nAvec la palette `-RdBu`, les points froids et les points chauds sont respectivement bleus et rouges comme les pastilles de votre robinet! Bref, un beau travail de plomberie!\n\nPour un rappel sur la cote Z et les valeurs de *p* associées, consultez [ce lien](https://pro.arcgis.com/fr/pro-app/latest/tool-reference/spatial-statistics/what-is-a-z-score-what-is-a-p-value.htm).\n:::\n:::\n\n#### Mise en œuvre dans R {#sec-02412}\n\nLa syntaxe ci-dessous calcule les deux statistiques locales avec `localG` et `localG_perm` pour le revenu moyen des ménages pour les aires de diffusion de 2021 de la ville de Sherbrooke.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRook1 <- poly2nb(AD.DR, queen=FALSE)\n## Matrice de pondération\nW.RookG    <- nb2listw(Rook1, zero.policy=TRUE)\nW.RookStar <-nb2listw(include.self(Rook1), zero.policy=TRUE) # matrice incluant elle-même\n## Calcul du Z(Gi) et du Z(Gi*)\nlocalGetis     <- localG(AD.DR$RevMedMenage, W.RookG)\nlocalGetisStar <- localG(AD.DR$RevMedMenage, W.RookStar)\n## Calcul avec la méthode Monte-Carlo (999 permutations)\nlocalGetis.MC999     <- localG_perm(AD.DR$RevMedMenage, W.RookG, nsim = 999)\nlocalGetis.StarMC999 <- localG_perm(AD.DR$RevMedMenage, W.RookStar, nsim = 999)\n## Sommaires statistiques\nsummary(localGetis)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-3.80885 -1.70432 -0.09828 -0.04120  1.41123  3.91835 \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(localGetisStar)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-4.04870 -1.88689 -0.13297 -0.03841  1.54641  4.10379 \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(localGetis.MC999)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-3.80885 -1.70432 -0.09828 -0.04120  1.41123  3.91835 \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(localGetis.StarMC999)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-4.04870 -1.88689 -0.13297 -0.03841  1.54641  4.10379 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nCartographions ces valeurs et repérons les regroupements de valeurs significativement fortes et faibles avec les statistiques de Getis et Ord (@fig-GetisLocaleClassique et @fig-GetisLocaleMC). Les quatre cartes sont très semblables et permettent de repérer un regroupement de valeurs faibles dans le centre-ville et un autre de valeurs fortes dans l'est de la ville.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Enregistrement des résultats dans deux nouveaux champs de la couche des AD\nAD.DR$RevMed_localGetis <- localGetis\nAD.DR$RevMed_localGetisStar <- localGetisStar\n# Définition des intervalles et des noms des classes\nclasses.intervalles = c(-Inf, -3.29, -2.58, -1.96, 1.96, 2.58, 3.29, Inf)\nclasses.noms = c(\"Point froid (p = 0,001)\", \n                 \"Point froid (p = 0,01)\", \n                 \"Point froid (p = 0,05)\", \n                 \"Non significatif\",\n                 \"Point chaud (p = 0,05)\", \n                 \"Point chaud (p = 0,01)\", \n                 \"Point chaud (p = 0,001)\")\n# Création d'un champ avec les noms des classes\nAD.DR$RevMed_localGetisP <- cut(AD.DR$RevMed_localGetis, \n                                breaks = classes.intervalles, \n                                labels = classes.noms)\nAD.DR$RevMed_localGetisStarP <- cut(AD.DR$RevMed_localGetisStar, \n                                  breaks = classes.intervalles, \n                                  labels = classes.noms)\n## Cartographie pour le Z(Gi)\nCarte1 = tm_shape(AD.DR)+\n            tm_polygons(col =\"RevMed_localGetisP\", \n                        title=\"Z(Gi)\", palette=\"-RdBu\", lwd = 1)+\n            tm_layout(frame =FALSE)\n## Cartographie pour le Z(Gi)*\nCarte2 = tm_shape(AD.DR)+\n            tm_polygons(col =\"RevMed_localGetisStarP\", \n                        title=\"Z(Gi*)\",  palette=\"-RdBu\", lwd = 1)+\n            tm_layout(frame =FALSE)+\n          tm_credits(\"Auteurs : Geoffroy et Jessie Chaux.\", \n           position = c(\"right\", \"bottom\"), size = 0.7, align = \"right\")\n## Composition avec les deux cartes\ntmap_arrange(Carte1, Carte2, ncol = 2, nrow = 1)\n```\n\n::: {.cell-output-display}\n![Points chauds et froids du revenu médian des ménages selon les statistiques de Getis et Ord (méthode classique)](02-Autocorrelation_files/figure-html/fig-GetisLocaleClassique-1.png){#fig-GetisLocaleClassique fig-align='center' width=85%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Enregistrement les résultats dans deux champs de la couche des AD\nAD.DR$RevMed_localGetis.MC999 <- localGetis.MC999\nAD.DR$RevMed_localGetis.StarMC999 <- localGetis.StarMC999\n# Définition des intervalles et des noms des classes\nclasses.intervalles = c(-Inf, -3.29, -2.58, -1.96, 1.96, 2.58, 3.29, Inf)\nclasses.noms = c(\"Point froid (p = 0,001)\", \n                 \"Point froid (p = 0,01)\", \n                 \"Point froid (p = 0,05)\", \n                 \"Non significatif\",\n                 \"Point chaud (p = 0,05)\", \n                 \"Point chaud (p = 0,01)\", \n                 \"Point chaud (p = 0,001)\")\n# Création d'un champ avec les noms des classes\nAD.DR$RevMed_localGetis.MC999P <- cut(AD.DR$RevMed_localGetis.MC999, \n                                breaks = classes.intervalles, \n                                labels = classes.noms)\nAD.DR$RevMed_localGetis.StarMC999P <- cut(AD.DR$RevMed_localGetis.StarMC999, \n                                  breaks = classes.intervalles, \n                                  labels = classes.noms)\n## Cartographie pour le Z(Gi) Mont-Carlo\nCarte3 = tm_shape(AD.DR)+\n            tm_polygons(col =\"RevMed_localGetis.MC999P\", \n                        title=\"Z(Gi)\", palette=\"-RdBu\", lwd = 1)+\n            tm_layout(frame =FALSE)\n## Cartographie pour le Z(Gi)* Mont-Carlo\nCarte4 = tm_shape(AD.DR)+\n            tm_polygons(col =\"RevMed_localGetis.StarMC999P\",\n                        title=\"Z(Gi*)\", palette=\"-RdBu\", lwd = 1)+\n            tm_layout(frame =FALSE)+\n          tm_credits(\"Auteurs : Geoffroy et Jessie Chaux.\", \n           position = c(\"right\", \"bottom\"), size = 0.7, align = \"right\")\n## Composition avec les deux cartes\ntmap_arrange(Carte3, Carte4, ncol = 2, nrow = 1)\n```\n\n::: {.cell-output-display}\n![Points chauds et froids du revenu médian des ménages selon les statistiques de Getis et Ord (999 permutations Monte-Carlo)](02-Autocorrelation_files/figure-html/fig-GetisLocaleMC-1.png){#fig-GetisLocaleMC fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\n### Version locale du *I* de Moran {#sec-0242}\n\n#### Formulation de la version locale du *I* de Moran {#sec-02421}\n\nUne version locale du *I* de Moran ($I_i$) a été proposée par Luc Anselin [-@anselin1995local]. Elle permet de vérifier si une entité spatiale est voisine ou proche -- dépendamment de la matrice spatiale utilisée -- d'entités spatiales avec des valeurs semblables (contexte d'autocorrélation spatiale locale positive) ou dissemblables (contexte d'autocorrélation spatiale locale négative). Le *I* de Moran local s'écrit :\n\n$$\nI_i = \\frac{(x_i-\\bar{X})\\Sigma_{j=1}^n w_{ij}(x_j-\\bar{X})}\n{\\frac{1}{n} \\Sigma_{i=1}^n(x_i-\\bar{X})^2} =  \\frac{z_i \\Sigma_{j=1}^n z_j}{\\frac{1}{n}\\Sigma_{i=1}^n z_i^2} \\text{, } i \\ne j\n$$ {#eq-LocalIMoran}\n\navec :\n\n-   $z_i$ étant la valeur de la variable continue centrée $X$ pour l'entité spatiale $i$, c'est-à-dire simplement l'écart de $i$ à la moyenne de $X$ ($x_i - \\bar X$).\n-   $z_j$ étant la valeur de la variable centrée de $X$ pour l'entité spatiale $j$.\n-   $w_{ij}$ étant la valeur de la matrice de pondération spatiale standardisée en ligne entre $i$ et $j$.\n-   $n$ étant le nombre d'entités spatiales dans la couche géographique.\n\nComme pour la version globale, il est possible de tester la significativité du *I* de Moran local de manière classique (selon la loi normale) ou avec l'approche Monte-Carlo (avec habituellement 999 permutations).\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Test de significativité du *I* de Moran local**.\n:::\n\n::: bloc_aller_loin-body\nPour comprendre les différentes variantes pour tester la significativité [@anselin1995local; @sokal1998local], consultez Bivand et Wong [-@bivand2018comparing] ou l'ouvrage de Dubé et Legros [-@dube2014econometrie].\n:::\n:::\n\n#### Mise en œuvre dans R {#sec-02422}\n\nLe calcul du *I* de Moran local s'opère avec les fonctions `localmoran` et `localMoranI.mc` du *package* `spdep` (voir la syntaxe ci-dessous). Comme pour la version globale, les résultats du *I* de Moran local sont les mêmes pour les deux fonctions, seules les valeurs de *p* peuvent varier.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Calcul du I de Moran local\nlocalMoranI <- localmoran(AD.DR$RevMedMenage,  # variable\n                          W.RookG)             # matrice de pondération spatiale\n## Calcul du I de Moran local avec la méthode Monte-Carlo\nlocalMoranI.mc <- localmoran_perm(AD.DR$RevMedMenage, # variable\n                             W.RookG,                 # matrice de pondération spatiale\n                             nsim = 999)              # nombre de permutations       \n## Sommaires statistiques\nsummary(localMoranI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Ii                E.Ii                Var.Ii               Z.Ii        \n Min.   :-0.90053   Min.   :-3.054e-02   Min.   :0.0000003   Min.   :-1.9962  \n 1st Qu.: 0.08313   1st Qu.:-5.368e-03   1st Qu.:0.0370546   1st Qu.: 0.4539  \n Median : 0.49029   Median :-2.755e-03   Median :0.1339044   Median : 1.4404  \n Mean   : 0.61678   Mean   :-4.032e-03   Mean   :0.2149974   Mean   : 1.2503  \n 3rd Qu.: 0.97602   3rd Qu.:-8.287e-04   3rd Qu.:0.2510284   3rd Qu.: 2.1938  \n Max.   : 3.37625   Max.   :-8.000e-09   Max.   :1.8207164   Max.   : 3.9184  \n Pr(z != E(Ii))     \n Min.   :0.0000892  \n 1st Qu.:0.0282519  \n Median :0.1268505  \n Mean   :0.2467939  \n 3rd Qu.:0.3948293  \n Max.   :0.9833048  \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(localMoranI.mc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Ii                E.Ii               Var.Ii               Z.Ii        \n Min.   :-0.90053   Min.   :-0.069143   Min.   :0.0000003   Min.   :-1.9500  \n 1st Qu.: 0.08313   1st Qu.:-0.010689   1st Qu.:0.0383852   1st Qu.: 0.4799  \n Median : 0.49029   Median :-0.002007   Median :0.1384804   Median : 1.4118  \n Mean   : 0.61678   Mean   :-0.004386   Mean   :0.2188704   Mean   : 1.2391  \n 3rd Qu.: 0.97602   3rd Qu.: 0.002960   3rd Qu.:0.2564877   3rd Qu.: 2.1361  \n Max.   : 3.37625   Max.   : 0.068986   Max.   :1.8780778   Max.   : 3.9434  \n Pr(z != E(Ii))      Pr(z != E(Ii)) Sim Pr(folded) Sim      Skewness       \n Min.   :0.0000803   Min.   :0.0020     Min.   :0.0010   Min.   :-0.37707  \n 1st Qu.:0.0326692   1st Qu.:0.0280     1st Qu.:0.0140   1st Qu.:-0.22898  \n Median :0.1291809   Median :0.1400     Median :0.0710   Median :-0.11260  \n Mean   :0.2504656   Mean   :0.2555     Mean   :0.1278   Mean   :-0.01269  \n 3rd Qu.:0.3970815   3rd Qu.:0.4060     3rd Qu.:0.2030   3rd Qu.: 0.20884  \n Max.   :0.9820912   Max.   :1.0000     Max.   :0.5000   Max.   : 0.46706  \n    Kurtosis       \n Min.   :-0.48543  \n 1st Qu.:-0.26894  \n Median :-0.17955  \n Mean   :-0.16969  \n 3rd Qu.:-0.06718  \n Max.   : 0.28020  \n```\n\n\n:::\n:::\n\n\n\n\n\n\nAvec la cartographie du *I* de Moran local, nous repérons localement l'autocorrélation spatiale positive (valeurs similaires, fortes ou faibles localement) et l'autocorrélation spatiale négative (valeurs dissemblables localement) (@fig-Chap02CartoIMoranLocal).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Ajout de champs pour le I de Moran local\nAD.DR$RevMed_IlocalMoran.MC999 <- localMoranI.mc[, 1]\nAD.DR$RevMed_IlocalMoran.MC999p <- localMoranI.mc[, 5]\n## Cartographie\ntmap_mode(\"plot\")\nCarte1 = tm_shape(AD.DR)+\n            tm_polygons(col =\"RevMed_IlocalMoran.MC999\", title=\"I Moran local\", \n                        style=\"cont\", palette=\"-RdBu\", lwd = 1)+\n         tm_layout(frame = FALSE)\n\nCarte2 = tm_shape(AD.DR)+\n              tm_polygons(col= \"RevMed_IlocalMoran.MC999p\", title=\"valeur de p\",\n                    palette = c(\"darkgreen\", \"green\", \"lightgreen\", \"gray\"),  lwd = 1, \n                    breaks = c(0, 0.001, 0.01, 0.05, Inf),\n\t\t\t  \t\tlegend.format = list(text.separator = \"à\"),\n                    title =\"En %\")+\n            tm_layout(frame = FALSE)\n## Combinaison des deux cartes\ntmap_arrange(Carte1, Carte2, ncol = 2, nrow = 1)\n```\n\n::: {.cell-output-display}\n![Cartographie du *I* de Moran local et de la valeur de *p* associée](02-Autocorrelation_files/figure-html/fig-Chap02CartoIMoranLocal-1.png){#fig-Chap02CartoIMoranLocal fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\n### Typologie basée sur le diagramme de Moran {#sec-0243}\n\n#### Formulation de la typologie basée sur le diagramme de Moran dans un contexte univarié {#sec-02431}\n\nLa typologie basée sur le diagramme de Moran a été proposée par Luc Anselin [-@anselin1996chapter]. L'idée est fort simple, mais extrêmement efficace! Avant tout, la variable continue est centrée réduite (cote $z$, *z-score* en anglais). Pour un rappel sur la cote $z$, consultez la [section suivante](https://serieboldr.github.io/MethodesQuantitatives/02-univarie.html#sec-02552) [@RBoldAir]. La moyenne est ainsi égale à 0 et l'écart-type à 1. Puis, il s'agit de construire un nuage de points entre :\n\n1.  Les valeurs de la variable centrée réduite (Z) **sur l'axe des X** pour les entités spatiales de la couche géographique.\n2.  Les valeurs de la variable centrée réduite spatialement décalée obtenues avec les pondérations spatiales de la matrice $W$ (voir l'encadré ci-dessous).\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Comment calculer une variable spatialement décalée avec une matrice de pondération spatiale?**\n:::\n\n::: bloc_notes-body\nÀ la @fig-Chap02FigureVariableSpatialementDecalee, nous détaillons le calcul de la valeur d'une variable spatialement décalée pour l'entité spatiale **A** à partir d'une matrice de contiguïté (selon le partage d'un segment) standardisée en ligne. Notez que **A** est adjacente à quatre entités spatiales (b, c, d et e).\n\n![Illustration du calcul d'une variable spatialement décalée](images/Chap02/FigureVariableSpatialementDecalee.png){#fig-Chap02FigureVariableSpatialementDecalee width=\"65%\" fig-align=\"center\"}\n\nDans R, la syntaxe est fort simple pour créer une cote $z$ et une variable spatiale décalée :\n\n`zx <- (x - mean(x))/sd(x)     # variable X centrée réduite (cote z)`\n\n`wzx <- lag.listw(listW,zx)    # variable X centrée réduite spatialement décalée`\n:::\n:::\n\nAnalysons les différents éléments du diagramme de Moran à la @fig-NuagePointsMoran :\n\n-   La droite de régression résume la relation linéaire entre la variable spatialement décalée ($W.ZX$) et l'originale ($ZX$). D'ailleurs, le coefficient de régression pour la variable $ZX$, soit la pente de la droite, équivaut au *I* de Moran!\n-   Les traits pointillés représentent les moyennes des deux variables, toutes deux égales à 0 puisqu'elles sont centrées-réduites (cote $z$).\n\nPour analyser ce nuage, nous le décomposons en quatre quadrants :\n\n1.  Le quadrant **HH (*High-High*)** en haut à droite regroupe des entités spatiales avec des valeurs **fortes** (H) qui sont voisines ou proches d'autres entités spatiales avec aussi des valeurs **fortes** (H). Nous sommes donc en présence **d'autocorrélation spatiale locale positive avec des valeurs fortes (HH)**.\n\n2.  Le quadrant **LL (*Low-Low*)** en bas à gauche regroupe des entités spatiales avec des valeurs **faibles** (L) qui sont voisines ou proches d'autres entités spatiales avec aussi des valeurs **faibles** (L). Nous sommes donc en présence **d'autocorrélation spatiale locale positive avec des valeurs faibles (LL)**.\n\n3.  Le quadrant **HL (*High-Low*)** en bas à droite regroupe des entités spatiales avec des valeurs **fortes** (H) qui sont voisines ou proches d'autres entités spatiales avec des valeurs **faibles** (L). Nous sommes donc en présence **d'autocorrélation spatiale locale négative (HL)**. Avec humour, un collègue économiste, Jean Dubé, qualifie ce quadrant de **village gaulois** (Obélix, Astérix et leurs compagnons sont très forts et ils sont entourés de voisins romains plus faibles...).\n\n4.  Le quadrant **LH (*Low-High*)** en haut à gauche regroupe des entités spatiales avec des valeurs **faibles** (L) qui sont voisines ou proches d'autres entités spatiales avec des valeurs **fortes** (H). Nous sommes donc en présence **d'autocorrélation spatiale locale négative (LH)**.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Diagramme de Moran](02-Autocorrelation_files/figure-html/fig-NuagePointsMoran-1.png){#fig-NuagePointsMoran fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\n#### Mise en œuvre dans R {#sec-02432}\n\nPour créer le diagramme de Moran, nous avons écrit la fonction `DiagMoranUnivarie`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"code_complementaire/DiagrammeMoran.R\")\n## Réalisation du diagramme de Moran avec la fonction DiagMoranUnivarie\nDiagMoranUnivarie(\n  x = AD.DR$RevMedMenage,\n  listW = W.Rook,\n  titre = \"Diagramme de Moran (matrice de contiguïté selon le partage d'un segment)\",\n  titreAxeX = \"ZX : Revenu médian des ménages centré réduit\",\n  titreAxeY = \"WZ : Variable ZX spatialement décalée\",\n  AfficheAide=TRUE)\n```\n\n::: {.cell-output-display}\n![](02-Autocorrelation_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nReste à déterminer si l'autocorrélation spatiale locale pour ces quatre quadrants est significative. Rien de plus simple, il suffit d'utiliser la valeur de *p* du *I* de Moran local ([section @sec-0242]). Nous choisissons un seuil de signification (habituellement *p* = 0,05) et obtenons ainsi la typologie comprenant cinq catégories :\n\n-   Autocorrélation spatiale locale positive et significative (*p* \\< 0,05).\n    1.  HH\n    2.  LL\n-   Autocorrélation spatiale locale négative et significative (*p* \\< 0,05).\n    3.  HL\n    4.  LH\n\n5.  Autocorrélation spatiale locale non significative (*p* \\> 0,05).\n\nLe code R ci-dessous permet d'obtenir la typologie de l'autocorrélation spatiale avec le *I* de Moran local pour le revenu médian des ménages avec une matrice de contiguïté selon le partage d'un segment (*Rook*). La @fig-TypoIMoran dénote surtout une autocorrélation spatiale positive importante (respectivement 33 et 48 aires de diffusion classées *HH* et *LL*), comparativement à l'autocorrélation spatiale négative qui ne comprend qu'une aire de diffusion (LH).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\n## Cote Z (variable centrée réduite)\nzx <- (AD.DR$RevMedMenage - mean(AD.DR$RevMedMenage))/sd(AD.DR$RevMedMenage)\n## variable X centrée réduite spatialement décalée avec une matrice Rook\nwzx <- lag.listw(W.Rook, zx)    \n## I de Moran local (notez que vous pouvez aussi utiliser la fonction localmoran_perm)\nlocalMoranI   <- localmoran(AD.DR$RevMedMenage, W.Rook)\n#localMoranI.mc   <- localmoran_perm(AD.DR$RevMedMenage, W.Rook, n=999)\nplocalMoranI  <- localMoranI[, 5]\n## Choix d'un seuil de signification\nsignif = 0.05\n## Construction de la typologie\nTypologie <- attributes(localMoranI)$quadr$mean\nTypologie <- case_when(\n  plocalMoranI < signif ~ Typologie,\n  TRUE ~ \"Non sign.\"\n)\n## Enregistrement de la typologie dans un champ\nAD.DR$TypoIMoran.RevMedian <- Typologie\nAD.DR$TypoIMoran.RevMedian <- factor(AD.DR$TypoIMoran.RevMedian,\n                                     levels = c(\"High-High\", \"High-Low\", \"Low-Low\", \"Low-High\", \"Non sign.\"),\n                                     labels = c(\"HH\", \"HL\", \"LL\", \"LH\", \"Non sign.\"))\ntable(AD.DR$TypoIMoran.RevMedian, useNA = \"always\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n       HH        HL        LL        LH Non sign.      <NA> \n       33         0        48         1       167         0 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Couleurs\nCouleurs <- c(\"HH\" = \"#FF0000\",\n              \"HL\" = \"#f4ada8\",\n              \"LL\" =\"#0000FF\",\n              \"LH\" =\"#a7adf9\",\n              \"Non sign.\" = \"#eeeeee\")\n## Cartographie\ntmap_mode(\"plot\")\ntm_shape(AD.DR) + \n  tm_polygons(col = \"TypoIMoran.RevMedian\", \n              palette = Couleurs, \n              title =\"Autocorrélation spatiale locale\")+\n  tm_credits(\"HH : Positive dans un contexte de valeurs fortes (HH)\n              LL : Négative dans un contexte de valeurs faibles (LL)\n              HL : Positive dans un contexte de valeurs fortes (HL)\n              LH : Négative dans un contexte de valeurs fortes (LH) \n              Non sign. : Non significative\",\n             size = .5,\n             position=c(\"right\", \"bottom\"),\n             align = \"right\")+\n  tm_layout(frame= FALSE,\n            legend.outside = TRUE,\n            legend.title.size = 1,\n            legend.position = c(\"right\", \"center\"))\n```\n\n::: {.cell-output-display}\n![Typologie de l'autocorrélation spatiale locale avec le *I* de Moran local](02-Autocorrelation_files/figure-html/fig-TypoIMoran-1.png){#fig-TypoIMoran fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Ne pas confondre les statistiques locales de Getis et Ord et la typologie avec le *I* de Moran local**.\n:::\n\n::: bloc_attention-body\nSuccinctement, ces deux familles de mesures renvoient deux typologies différentes :\n\n-   Le *I* de Moran local comprend cinq classes : HH, LL, HL, LH et non significatif.\n\n-   Les statistiques locales de Getis et Ord comprennent trois classes : points chauds (sensiblement l'équivalent de HH), points froids (sensiblement l'équivalent de LL) et non significatifs.\n:::\n:::\n\n### Version locale des statistiques de comptage de jointure (*Join Count Statistics*) {#sec-0244}\n\nUne version locale des statistiques de comptage de jointure a été proposée par Luc Anselin et Xun Li [-@anselin2019operational]. Au même titre que la version locale du *I* de Moran, elle consiste à désagréger localement le calcul de l'indicateur global. Pour chaque observation, nous comptons ainsi le nombre de paires 0-0 (WW) ou 1-1 (BB) pour une variable binaire.\n\nPour déterminer si les associations 0-0 et 1-1 sont plus fréquentes que celles attendues du hasard, il est recommandé d'utiliser un test d'inférence par permutations. Ce test n'est actuellement pas implémenté dans `spdep`, mais il est disponible dans le *package* `rgeoda` avec la fonction `local_joincount`. Nous reprenons ici l'exemple des deux variables identifiant une majorité de locataires (`loc_maj`) ou de propriétaires (`proprio_maj`) pour les aires de diffusion (AD) de la ville de Sherbrooke.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgeoda)\n## Définition de la matrice de contiguïté avec rgeoda\nwmat <- queen_weights(ADSherb)\n## Création de deux variables binaires avec des valeurs de 0 et 1\n## pour les locataires et propriétaires\nADSherb$loc_maj <- ifelse(ADSherb$Locataire > ADSherb$Proprietaire, 1, 0)\nADSherb$proprio_maj <- ifelse(ADSherb$Proprietaire > ADSherb$Locataire, 1, 0)\n## Calcul de la version locale du join count test\ntestLoc <- local_joincount(wmat, ADSherb[\"loc_maj\"], permutations = 999)\ntestPro <- local_joincount(wmat, ADSherb[\"proprio_maj\"], permutations = 999)\n```\n:::\n\n\n\n\n\n\nAvec le code ci-dessous, nous cartographions les AD en fonction des seuils de significativité de la version locale du test. Sans surprise, les AD avec une autocorrélation spatiale significative sont les suivantes :\n\n-   celles au centre de la ville de Sherbrooke avec une majorité de locataires (@fig-LocalJointCountStatCarto, a);\n-   celles de l'ouest de la ville avec une majorité de propriétaires (@fig-LocalJointCountStatCarto, b).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\n## Sauvegarde des résultats\nADSherb$testLoc_pvals <- testLoc$p_vals\nADSherb$testPro_pvals <- testPro$p_vals\n## Calcul d'une variable avec les seuils de significativité pour les locataires\nADSherb$clusterLoc <- case_when(\n  ADSherb$testLoc_pvals < 0.05 & ADSherb$testLoc_pvals >= 0.01 ~ 1,\n  ADSherb$testLoc_pvals < 0.01 ~ 2,\n  TRUE ~ 0\n)\nADSherb$clusterLoc <- factor(ADSherb$clusterLoc, \n                          levels = 0:2,\n                          labels = c(\"Non significatif (p > 0,05)\", \n                                     \"p = 0,05\",\"p = 0,01\"))\n## Calcul d'une variable avec les seuils de significativité pour les propriétaires\nADSherb$clusterPro <- case_when(\n  ADSherb$testPro_pvals < 0.05 & ADSherb$testPro_pvals >= 0.01 ~ 1,\n  ADSherb$testPro_pvals < 0.01 ~ 2,\n  TRUE ~ 0\n)\nADSherb$clusterPro <- factor(ADSherb$clusterPro, \n                          levels = 0:2,\n                          labels = c(\"Non significatif (p > 0,05)\", \n                                     \"p = 0,05\",\"p = 0,01\"))\n\n## Cartographie des résultats\nCarte1 <-  tm_shape(ADSherb) + \n  tm_borders(col=\"black\", lwd=0.5)+\n  tm_fill(col = \"clusterLoc\", \n          palette = c(\"#f0f0f0\", \"#fc9272\", \"#de2d26\"),\n          title = \"Seuil de significativité\")+\n  tm_layout(frame=FALSE,\n            legend.outside = TRUE,\n            legend.outside.position = c(\"bottom\", \"center\"),\n            title = \"a. Locataires majoritaires\",\n            title.size = 1)\nCarte2 <-  tm_shape(ADSherb) + \n  tm_borders(col=\"black\", lwd=0.5)+\n  tm_fill(col = \"clusterPro\", \n          palette = c(\"#f0f0f0\", \"#fc9272\", \"#de2d26\"),\n          title = \"Seuil de significativité\")+\n  tm_layout(frame=FALSE,\n            legend.outside = TRUE,\n            legend.outside.position = c(\"bottom\", \"center\"),\n            title = \"b. Propriétaires majoritaires\",\n            title.size = 1)\ntmap_arrange(Carte1, Carte2)\n```\n\n::: {.cell-output-display}\n![Cartographie de la version locale des statistiques de comptage de jointure](02-Autocorrelation_files/figure-html/fig-LocalJointCountStatCarto-1.png){#fig-LocalJointCountStatCarto fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\n### Version locale de l'indice de Lee {#sec-0245}\n\n#### Formulation de la version locale de l'indice de Lee {#sec-02451}\n\nDans le cas de l'autocorrélation spatiale bivariée, l'indice de Lee dispose aussi d'une version locale. Plus exactement, la version globale de l'indice correspond à l'agrégation des contributions locales de chaque observation. En cartographiant ces contributions locales, il est possible de se faire une idée de la relation spatiale entre les deux variables à l'étude. La version locale de l'indice est définie par l'@eq-LocalLee.\n\n$$\nL_i=\\frac{n \\cdot\\left[\\left(\\sum_i w_{i j}\\left(x_j-\\bar{x}\\right)\\right)\\left(\\sum_i w_{i j}\\left(y_j-\\bar{y}\\right)\\right)\\right]}{\\sqrt{\\sum_i\\left(x_i-\\bar{x}\\right)^2} \\sqrt{\\sum_i\\left(y_i-\\bar{y}\\right)^2}}=\\frac{n \\cdot\\left(\\tilde{x}_i-\\bar{x}\\right)\\left(\\tilde{y}_i-\\bar{y}\\right)}{\\sqrt{\\sum_i\\left(x_i-\\bar{x}\\right)^2} \\sqrt{\\sum_i\\left(y_i-\\bar{y}\\right)^2}}\n$$ {#eq-LocalLee}\n\nAvec :\n\n-   $n$, le nombre d'observations;\n-   $W_{ij}$, la valeur de la pondération spatiale entre les entités spatiales $i$ et $j$;\n-   $\\bar{x}$, la moyenne de la variable *x*;\n-   $\\bar{y}$, la moyenne de la variable *y*.\n\n#### Mise en œuvre dans R {#sec-02452}\n\nReprenons notre exemple précédent sur les pollutions atmosphériques à Lyon. Nous avions observé que le dioxyde d'azote partageait un patron d'autocorrélation spatiale positive forte avec les particules fines, et un patron moins prononcé avec le bruit. Nous allons observer ces deux relations à l'échelle locale.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(geocmeans)\ndata(\"LyonIris\")\n## Liste de variables à analyser\nvars <- c(\"Lden\",\"NO2\",\"PM25\",\"VegHautPrt\")\n## Matrice de pondération spatiale Queen standardisée\nnb <- poly2nb(LyonIris, queen = TRUE)\nWmat <- nb2listw(nb, style = 'W')\n## Calcul de la version locale de l'indice de Lee entre \n# NO2 et PM25\nLee_1 <- lee(LyonIris$NO2, LyonIris$PM25, listw = Wmat, n = nrow(LyonIris))\n# NO2 et DBA\nLee_2  <- lee(LyonIris$NO2, LyonIris$Lden, listw = Wmat, n = nrow(LyonIris))\n```\n:::\n\n\n\n\n\n\nDans le *package* `spdep`, aucune fonction ne permet de calculer un test d'inférence pour les valeurs locales de Lee. Nous pouvons cependant assez facilement obtenir des pseudo valeurs de *p* en réalisant 999 permutations aléatoires et en comptant combien de fois les valeurs obtenues au hasard sont plus grandes ou plus petites que celles obtenues dans les données initiales.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Nous créons une matrice à deux colonnes remplies de zéros qui \n## servira à compter le nombre de fois où les valeurs des permutations \n## sont au-dessus ou en dessous des valeurs réelles\np_vals_1 <- cbind(rep(0, nrow(LyonIris)),\n                  rep(0, nrow(LyonIris))\n                  )\np_vals_2 <- cbind(rep(0, nrow(LyonIris)),\n                  rep(0, nrow(LyonIris))\n                  )\nN <- nrow(LyonIris)\nfor(i in 1:999){\n  # Permutation aléatoire de l'ordre des observations\n  perm_data <- LyonIris[sample(1:nrow(LyonIris)),]\n  # Calcul de l'indice de Lee sur les données permutées\n  Lee_1_perm <- lee(perm_data$NO2, perm_data$PM25, listw = Wmat, n = N)\n  Lee_2_perm  <- lee(perm_data$NO2, perm_data$Lden, listw = Wmat, n = N)\n  # Test pour vérifier si les valeurs obtenues sont plus grandes\n  test1 <- Lee_1$localL < Lee_1_perm$localL\n  test2 <- Lee_2$localL < Lee_2_perm$localL\n  # Ajout du résultat aux matrices de valeurs de p\n  p_vals_1[,1] <- p_vals_1[,1] + test1\n  p_vals_2[,1] <- p_vals_2[,1] + test2\n  # Test pour vérifier si les valeurs obtenues sont plus petites\n  test1 <- Lee_1$localL > Lee_1_perm$localL\n  test2 <- Lee_2$localL > Lee_2_perm$localL\n  # Ajout du résultat aux matrices de valeurs de p\n  p_vals_1[,2] <- p_vals_1[,2] + test1\n  p_vals_2[,2] <- p_vals_2[,2] + test2\n}\n\n## Ajout des données originales\nLyonIris$Lee1 <- Lee_1$localL\nLyonIris$Lee2 <- Lee_2$localL\nLyonIris$Lee1_p_higher <- p_vals_1[,1] / 999\nLyonIris$Lee1_p_lower <- p_vals_1[,2] / 999\nLyonIris$Lee2_p_higher <- p_vals_2[,1] / 999\nLyonIris$Lee2_p_lower <- p_vals_2[,2] / 999\n\n## Cartographie des résultats avec deux cartes dans lesquelles\n## les valeurs non significatives au seuil 0,01 sont représentées en gris clair.\ntest_sign1 <- LyonIris$Lee1_p_higher < 0.01 | LyonIris$Lee1_p_lower < 0.01\nmap1 <- tm_shape(LyonIris)+tm_borders(col=\"black\")+\n  tm_shape(subset(LyonIris, test_sign1)) + \n  tm_polygons(col = 'Lee1', n = 5, style = 'kmeans', midpoint = 0, palette = '-RdBu',\n              legend.format = list(digits = 2, text.separator = \"à\"),\n\t\t\t  title = 'Indice de Lee') + \n  tm_shape(subset(LyonIris, !test_sign1)) + \n  tm_polygons(col = 'lightgrey')+ \n  tm_layout(legend.outside = FALSE, frame = FALSE,\n            title = \"a. NO2 versus PM25\", title.size = .75)+\n  tm_credits(text=\"Gris : non significatif (p > 0,001).\",\n             position = c(\"RIGHT\", \"BOTTOM\"))\n\ntest_sign2 <- LyonIris$Lee2_p_higher < 0.01 | LyonIris$Lee2_p_lower < 0.01\nmap2 <- tm_shape(LyonIris)+tm_borders(col=\"black\")+\n  tm_shape(subset(LyonIris, test_sign2)) + \n  tm_polygons(col = 'Lee2', n = 5, style = 'kmeans', palette = '-RdBu',\n              legend.format = list(digits = 2, text.separator = \"à\"),\n\t\t\t  title = 'Indice de Lee') + \n  tm_shape(subset(LyonIris, !test_sign2)) + \n  tm_polygons(col = 'lightgrey') + \n  tm_layout(legend.outside = FALSE, frame = FALSE,\n            title = \"b. NO2 versus Lden\", title.size = .75)+\n  tm_credits(text=\"Gris : non significatif (p > 0,001).\",\n             position = c(\"RIGHT\", \"BOTTOM\"))\n\ntmap_arrange(map1, map2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![Cartographie des valeurs de l'indice de Lee local](02-Autocorrelation_files/figure-html/fig-localLeeMaps-1.png){#fig-localLeeMaps fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\nÀ la @fig-localLeeMaps (a), nous constatons une forte autocorrélation spatiale bivariée positive dans deux secteurs de l'agglomération :\n\n-   Au centre avec des entités spatiales ayant des valeurs fortes pour les deux variables.\n\n-   Dans les zones périphériques au nord, à l'est et à l'ouest avec des entités spatiales ayant des valeurs faibles pour les deux variables.\n\nÀ la @fig-localLeeMaps (b), nous observons trois patrons d'autocorrélation spatiale bivariée :\n\n-   Autocorrélation spatiale positive pour des entités spatiales au centre de l'agglomération avec des valeurs fortes de bruit et de dioxyde d'azote.\n\n-   Autocorrélation spatiale positive pour des entités spatiales au nord de l'agglomération avec des valeurs faibles de bruit et de dioxyde d'azote.\n\n-   Autocorrélation spatiale négative à l'est de l'agglomération avec des valeurs fortes pour le bruit, mais faibles pour le dioxyde d'azote.\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Autocorrélation spatiale multivariée**\n:::\n\n::: bloc_aller_loin-body\nIl est possible d'analyser l'autocorrélation spatiale dans un contexte multivarié. Cependant, ces méthodes sont parfois difficiles à interpréter, car l'augmentation de la dimensionnalité des données analysées ajoute un haut niveau d'abstraction. Si ces méthodes vous intéressent, nous vous recommandons de jeter un œil à :\n\n-   L'indice de Geary multivarié local [@anselin2019local], qui peut être calculé facilement dans R (avec la fonction `local_multigeary` du *package* `rgeoda`) en faisant la moyenne des valeurs locales de l'indice de Geary univarié.\n\n-   Les méthodes factorielles intégrant l'espace, dont l'analyse en composantes principales spatiales (*spatial principal component analysis* en anglais, SPCA) [@jombart2008revealing] qui permet d'identifier des facteurs maximisant le produit de la variance expliquée d'un ensemble de variables continues et l'autocorrélation spatiale de ces facteurs (mesurée avec le *I* de Moran). Dans R, les *packages* pertinents pour ces méthodes sont `adegenet` et `ade4`.\n:::\n:::\n\n### Typologie basée sur le diagramme de Moran dans un contexte bivarié {#sec-0246}\n\n#### Formulation de la typologie basée sur le diagramme de Moran dans un contexte bivarié {#sec-02461}\n\nÀ la [section @sec-0243], nous avons décrit la construction du diagramme de Moran dans un contexte univarié avec la variable centrée réduite (**ZX**) sur l'axe des X et la variable centrée réduite spatialement décalée (**WZX**) sur l'axe des Y. Par la suite, ce diagramme est décomposé en quatre quadrants (HH, LL, HL, LH). Cette démarche peut être adaptée à un contexte bivarié avec deux variables continues, c'est-à-dire avec **ZX** et **WZY** pour construire le diagramme. Les quatre quadrants s'interprètent alors comme suit (@fig-localLeeMaps) :\n\n1.  **HH (*High-High*)** regroupe des entités spatiales avec des valeurs fortes (H) pour la variable X qui sont voisines ou proches d'autres entités spatiales avec des valeurs fortes pour la variable Y (H). Nous sommes donc en présence **d'autocorrélation spatiale locale bivariée positive avec des valeurs fortes (HH)**.\n\n2.  **LL (*Low-Low*)** regroupe des entités spatiales avec des valeurs faibles (L) pour la variable X qui sont voisines ou proches d'autres entités spatiales avec des valeurs faibles pour la variable Y (L). Nous sommes donc en présence **d'autocorrélation spatiale locale bivariée positive avec des valeurs faibles (LL)**.\n\n3.  **HL (*High-Low*)** regroupe des entités spatiales avec des valeurs fortes (H) pour la variable X qui sont voisines ou proches d'autres entités spatiales avec des valeurs faibles pour la variable Y (L), soit de **l'autocorrélation spatiale locale bivariée négative (HL)**.\n\n4.  **LH (*Low-High*)** regroupe des entités spatiales avec des valeurs faibles (L) pour la variable X qui sont voisines ou proches d'autres entités spatiales avec des valeurs fortes (H) pour la variable Y, soit de **l'autocorrélation spatiale bivariée locale négative (LH)**.\n\nPour déterminer si l'autocorrélation spatiale locale (positive ou négative) pour les quatre est significative, nous utilisons la valeur de *p* de la version locale du *I* de Moran bivariée (habituellement p = 0,05).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Diagramme de Moran dans un contexte bivarié](02-Autocorrelation_files/figure-html/fig-NuagePointsMoranBivariee-1.png){#fig-NuagePointsMoranBivariee fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Non-symétrie du *I* de Moran bivarié et du diagramme de Moran dans un contexte bivarié**\n:::\n\n::: bloc_attention-body\nÀ titre de rappel, le diagramme est construit avec **ZX** et **WZY**, tout comme l'indice de Moran bivarié. Par conséquent, les résultats entre **ZX** et **WZY** (@fig-localLeeMaps, a) et **ZY** et **WZX** (@fig-localLeeMaps, b) ne sont pas identiques!\n:::\n:::\n\n#### Mise en œuvre dans R {#sec-02462}\n\nPour créer le diagramme de Moran dans un contexte bivarié, nous avons écrit la fonction `DiagMoranUnivarie`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"code_complementaire/DiagrammeMoran.R\")\nlibrary(ggpubr)\n## Matrice de contiguïté\nQueen <- poly2nb(LyonIris, queen=FALSE)\nW.Queen <- nb2listw(Queen, zero.policy=TRUE, style = \"W\")\n## Réalisation du diagramme de Moran avec la fonction DiagMoranBivarie\nDiag1 <- DiagMoranBivarie(x = LyonIris$NO2,\n                 y = LyonIris$PM25,\n                 listW = W.Queen,\n                 titre = \"Diagramme de Moran\",\n                 titreAxeX = \"ZX : Dioxyde d'azote (NO2)\",\n                 titreAxeY = \"WZY : Particules fines (PM2,5)\",\n                 AfficheAide=FALSE)\nDiag2 <- DiagMoranBivarie(x = LyonIris$PM25,\n                 y = LyonIris$NO2,\n                 listW = W.Queen,\n                 titre = \"Diagramme de Moran\",\n                 titreAxeX = \"ZX : Particules fines (PM2,5)\",\n                 titreAxeY = \"WZY : Dioxyde d'azote (NO2)\",\n                 AfficheAide=FALSE)\nggarrange(Diag1, Diag2)\n```\n\n::: {.cell-output-display}\n![](02-Autocorrelation_files/figure-html/unnamed-chunk-60-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nPour mettre en œuvre la typologie, vous pouvez utiliser soit la fonction `local_bimoran` du *package* `rgeoda`, soit la fonction `localmoran_bv` du *package* `spdep`. Cette dernière est mobilisée dans le code ci-dessous pour obtenir la typologie de l'autocorrélation spatiale bivariée entre :\n\n-   Le dioxyde d'azote (**ZX**) et les particules fines (**ZWY**) (@fig-localLeeMaps, a).\n\n-   Les particules fines (**ZX**) et le dioxyde d'azote (**ZWY**) (@fig-localLeeMaps, b).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(spdep)\n## Matrice de contiguïté\nQueen <- poly2nb(LyonIris, queen=FALSE)\nW.Queen <- nb2listw(Queen, zero.policy=TRUE, style = \"W\")\n## Variables centrées réduites\nz.no2 <- (LyonIris$NO2 - mean(LyonIris$NO2))/sd(LyonIris$NO2)\nz.pm25 <- (LyonIris$PM25 - mean(LyonIris$PM25))/sd(LyonIris$PM25)\n## Variables spatialement décalées\nwz.no2 <- lag.listw(W.Queen, z.no2)\nwz.pm25 <- lag.listw(W.Queen, z.pm25)\n## I de Moran local bivarié\nlocalMoranBivariee_NO2_PM25 <- localmoran_bv(LyonIris$NO2, LyonIris$PM25, W.Queen, nsim = 999)\nlocalMoranBivariee_PM25_NO2 <- localmoran_bv(LyonIris$PM25, LyonIris$NO2, W.Queen, nsim = 999)\n## Valeur de p du I de Moran bivariée\nplocalMoranI_NO2_PM25  <- localMoranBivariee_NO2_PM25[, 7]\nplocalMoranI_PM25_NO2  <- localMoranBivariee_PM25_NO2[, 7]\n## Choix d'un seuil de signification\nsignif = 0.05\n## Construction de la typologie NO2 versus PM25\nTypoNO2_PM25 <- ifelse(z.no2 > 0 & wz.pm25 > 0, \"1. HH\", NA)\nTypoNO2_PM25 <- ifelse(z.no2 < 0 & wz.pm25 < 0, \"2. LL\", TypoNO2_PM25)\nTypoNO2_PM25 <- ifelse(z.no2 > 0 & wz.pm25 < 0, \"3. HL\", TypoNO2_PM25)\nTypoNO2_PM25 <- ifelse(z.no2 < 0 & wz.pm25 > 0, \"4. LH\", TypoNO2_PM25)\nTypoNO2_PM25 <- ifelse(plocalMoranI_NO2_PM25 > signif, \"Non sign\", TypoNO2_PM25)\n## Construction de la typologie PM25 versus NO2 \nTypoPM25_NO2 <- ifelse(z.pm25 > 0 & wz.no2 > 0, \"1. HH\", NA)\nTypoPM25_NO2 <- ifelse(z.pm25 < 0 & wz.no2 < 0, \"2. LL\", TypoPM25_NO2)\nTypoPM25_NO2 <- ifelse(z.pm25 > 0 & wz.no2 < 0, \"3. HL\", TypoPM25_NO2)\nTypoPM25_NO2 <- ifelse(z.pm25 < 0 & wz.no2 > 0, \"4. LH\", TypoPM25_NO2)\nTypoPM25_NO2 <- ifelse(plocalMoranI_PM25_NO2 > signif, \"Non sign\", TypoPM25_NO2)\n## Enregistrement des résultats dans la couche LyonIRS\nLyonIris$TypoNO2_PM25 <- TypoNO2_PM25\nLyonIris$TypoPM25_NO2 <- TypoPM25_NO2\n## Couleurs\nCouleurs <- c(\"1. HH\" = \"#FF0000\",\n              \"2. LL\" =\"#0000FF\",\n              \"3. HL\" = \"#f4ada8\",\n              \"4. LH\" =\"#a7adf9\",\n              \"Non sign\" = \"#eeeeee\")\n## Cartographie\ntmap_mode(\"plot\")\nCarte1 <- tm_shape(LyonIris) +\n            tm_polygons(col = \"TypoNO2_PM25\",\n              palette = Couleurs,\n              title =\"Typologie\")+\n            tm_layout(frame = FALSE, \n                      legend.outside = TRUE,\n                      legend.outside.position = c(\"bottom\", \"center\"),\n                      title = \"a. NO2 versus PM2,5\",\n                      title.size = .9)\nCarte2 <- tm_shape(LyonIris) +\n            tm_polygons(col = \"TypoPM25_NO2\",\n              palette = Couleurs,\n              title =\"Typologie\")+\n            tm_layout(frame = FALSE, \n                      legend.outside = TRUE,\n                      legend.outside.position = c(\"bottom\", \"center\"),\n                      title = \"b. PM2,5 versus NO2\",\n                      title.size = .9)\ntmap_arrange(Carte1, Carte2)\n```\n\n::: {.cell-output-display}\n![Typologies basées sur le diagramme de Moran dans un contexte bivarié](02-Autocorrelation_files/figure-html/fig-TypoDiagBivariee-1.png){#fig-TypoDiagBivariee fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Autocorrélation spatiale locale dans un contexte bivarié pour les variables binaires**\n:::\n\n::: bloc_aller_loin-body\nÀ la [section @sec-0244], nous avons abordé les statistiques locales de comptage de jointure. Tout comme la version locale de *I* de Moran, elles peuvent être adaptées à un contexte bivarié avec deux variables binaires. Pour ce faire, vous pouvez utiliser la fonction `local_bijoincount` du *package* `rgeoda`.\n:::\n:::\n\n### Autocorrélation locale pour une variable qualitative (catégorielle) : l'indicateur ELSA {#sec-0247}\n\n#### Formulation de l'indicateur ELSA {#sec-02471}\n\nRécemment, un indicateur basé sur la mesure de l'entropie locale a été proposé pour mesurer l'autocorrélation spatiale locale d'une variable qualitative comprenant plusieurs modalités (catégories) [@naimi2019elsa]. Cet indicateur ELSA (*Entropy-based local indicator of spatial association*), qui varie de 0 (autocorrélation spatiale parfaite) à 1 (forte hétérogénéité spatiale), est calculé comme suit :\n\n$$\n\\begin{aligned}\nE_i=E_{a i} \\times E_{c i} \\\\\n& E_{a i}=\\frac{\\sum_j \\omega_{i j} d_{i j}}{\\max \\{d\\} \\sum_j \\omega_{i j}}, j \\neq i \\\\\n& E_{c i}=-\\frac{\\sum_{k=1}^{m_\\omega} p_k \\log _2\\left(p_k\\right)}{\\log _2 m_i}, j \\neq i \\\\\n& m_i=\\left\\{\\begin{array}{l}\nm \\text { if } \\sum_j \\omega_{i j}>m \\\\\n\\sum_j \\omega_{i j}, \\text { otherwise }\n\\end{array}\\right. \\\\\n& d_{i j}=\\left|c_i-c_j\\right|\n\\end{aligned}\n$$ {#eq-ELSA1}\n\nIl s'agit donc du produit de deux termes, soit $E_{a i}$ et $E_{c i}$. Le premier mesure la dissimilarité entre l'observation *i* et ses voisins *j*. Le second est l'indice d'entropie de Shannon et quantifie la diversité des observations voisines de *i*.\n\nL'indicateur ELSA a la particularité de tenir compte du degré de dissimilarité entre les modalités (catégories) de la variable qualitative à l'étude. Aussi, il permet de spécifier qu'une catégorie *A* est plus ressemblante à une catégorie *B* qu'à une catégorie *C*. Or, nous supposons habituellement que *A* est différent de *B* et de *C*, ce qui produit une matrice des distances sémantiques binaire, telle que présentée au @tbl-TabMatriceSemantique1.\n\n\n\n\n\n\n::: {#tbl-TabMatriceSemantique1 .cell tbl-cap='Matrice des distances sémantiques classique (binaire)'}\n::: {.cell-output-display}\n\n\n|   | A | B | C |\n|:--|:-:|:-:|:-:|\n|A  | 0 | 1 | 1 |\n|B  | 1 | 0 | 1 |\n|C  | 1 | 1 | 0 |\n\n\n:::\n:::\n\n\n\n\n\n\nToutefois, si nous considérons que les catégories *A* et *B* sont plus proches entre elles que de la catégorie *C*, la matrice des distances sémantiques devrait être différente comme présentée au @tbl-TabMatriceSemantique2.\n\n\n\n\n\n\n::: {#tbl-TabMatriceSemantique2 .cell tbl-cap='Matrice des distances sémantiques modifiée'}\n::: {.cell-output-display}\n\n\n|   |  A  |  B  | C |\n|:--|:---:|:---:|:-:|\n|A  | 0,0 | 0,5 | 1 |\n|B  | 0,5 | 0,0 | 1 |\n|C  | 1,0 | 1,0 | 0 |\n\n\n:::\n:::\n\n\n\n\n\n\nPour déterminer si l'autocorrélation spatiale est significative, Babak Naimi et ses collègues [-@naimi2019elsa] proposent une approche par simulations Monte-Carlo, très semblable aux tests par permutations vus pour les autres mesures d'autocorrélation spatiale.\n\n#### Mise en œuvre dans R {#sec-02472}\n\nNous illustrons ici comment calculer l'indice *ELSA* sur des données matricielles (*raster*) avec une image dérivée d'un modèle numérique de terrain (élévation) et d'une image d'un indice de végétation par différence normalisée (NDVI) (@fig-figLaval). Cette image est en accès libre sur le [portail de données](https://observatoire.cmm.qc.ca/produits/donnees-georeferencees/#indice_canopee) de la Communauté métropolitaine de Montréal. Pour accélérer les calculs, nous avons extrait une petite partie de l'image qui couvre une zone de la ville de Laval. Cette image classifie le territoire en quatre catégories :\n\n1.  Minéral bas (\\< 3 mètres et NDVI \\< 0,3) (route, stationnement, etc.).\n2.  Minéral haut (\\>= 3 mètres et NDVI \\< 0,3) (construction).\n3.  Végétal bas (\\< 3 mètres et NDVI \\>= 0,3) (culture, gazon, etc.).\n4.  Végétal haut (\\>= 3 mètres et NDVI \\>= 0,3) (canopée).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(tmap)\nlibrary(geocmeans)\nlibrary(ggpubr)\n## Chargement du raster\nlaval_data <- rast(\"data/chap02/65005_IndiceCanopee_2021_sub.tif\")\ntm_shape(laval_data) +\n  tm_raster(palette = c(\"#fbd4b4\", \"#e36c0a\", \"#92d050\", \"#76923c\"),\n            style = 'cat',\n            title = \"Classe (catégorie)\",\n            labels = c(\"1. Minéral bas\", \"2. Minéral haut\",\n                       \"3. Végétal bas\", \"4. Végétal haut\"))+\n  tm_layout(legend.outside = TRUE, frame = FALSE)\n```\n\n::: {.cell-output-display}\n![Données matricielles sur une portion du territoire de Laval](02-Autocorrelation_files/figure-html/fig-figLaval-1.png){#fig-figLaval fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\nPour calculer l'indicateur ELSA, nous devons premièrement définir une matrice de voisinage. Pour ce faire, nous créons plusieurs fenêtres circulaires de taille différente (100, 200, 300 et 400 mètres; @fig-chap02FigureCirculaWindow). Notez que la résolution spatiale de l'image utilisée est de 5 m x 5 m, ce qui est possible de vérifier avec la fonction `terra::res`. La @fig-chap02FigureCirculaWindow illustre la taille des différentes matrices spatiales circulaires que nous allons construire. Chaque pixel de la zone en noir sera considéré comme un voisin du pixel central pour lequel l'indicateur *ELSA* sera calculé.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Illustration des matrices spatiales circulaires sur une image](02-Autocorrelation_files/figure-html/fig-chap02FigureCirculaWindow-1.png){#fig-chap02FigureCirculaWindow fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\nEn plus de la matrice spatiale, nous devons définir une matrice de dissimilarité entre les modalités (catégories) de la variable qualitative. Nous proposons de considérer que les catégories **Végétal haut** et **Végétal bas** ont une distance de 0,5 entre elles, tout comme les catégories de surface **Minéral bas** et **Minéral haut**. Par contre, la distance est fixée à 1 entre les surfaces végétales et celles minérales (@tbl-TabMatriceSemantiqueELSA).\n\n\n\n\n\n\n::: {#tbl-TabMatriceSemantiqueELSA .cell tbl-cap='Matrice de dissimilarité entre les catégories de l\\'image'}\n::: {.cell-output-display}\n\n\n|                  | MB  | MH  | VB  | VH  |\n|:-----------------|:---:|:---:|:---:|:---:|\n|Minéral bas (MB)  | 0,0 | 0,5 | 1,0 | 1,0 |\n|Minéral haut (MH) | 0,5 | 0,0 | 1,0 | 1,0 |\n|Végétal bas (VB)  | 1,0 | 1,0 | 0,0 | 0,5 |\n|Végétal haut (VH) | 1,0 | 1,0 | 0,5 | 0,0 |\n\n\n:::\n:::\n\n\n\n\n\n\nFinalement, nous calculons l'indicateur d'autocorrélation spatiale ELSA avec uniquement des rayons de 100 et de 400 mètres afin de limiter le temps de calcul. Pour ce faire, nous utilisons le *package* `geocmeans` et ses fonctions `circular_window` et `elsa_raster`.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Avec geocmeans, la première catégorie doit avoir la valeur 0\nlaval_data <- laval_data - 1\n## Définition des fenêtres circulaires à 100 et 400 mètre\nw100 <- circular_window(100,5)\nw400 <- circular_window(400,5)\n## Calcul de l'indicateur ELSA\nelsa_100 <- elsa_raster(laval_data, w100, matrice_dissim)\nelsa_400 <- elsa_raster(laval_data, w400, matrice_dissim)\n## Cartographie des résultats\ncarte1 <- tm_shape(elsa_100) + \n  tm_raster(palette = \"RdYlGn\", n = 6, \n            legend.is.portrait = FALSE, title = \"ELSA 100m\") + \n  tm_layout(legend.outside = TRUE, frame = FALSE,\n            legend.outside.position = \"bottom\",\n            legend.stack = \"horizontal\",\n            legend.text.size = .55)\ncarte2 <- tm_shape(elsa_400) + \n  tm_raster(palette = \"RdYlGn\", n = 6, \n            legend.is.portrait = FALSE, title = \"ELSA 400m\") + \n  tm_layout(legend.outside = TRUE, frame = FALSE,\n            legend.outside.position = \"bottom\",\n            legend.stack = \"horizontal\",\n            legend.text.size = .55)\ntmap_arrange(carte1, carte2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![Cartographie des valeurs ELSA obtenues](02-Autocorrelation_files/figure-html/fig-chap02FigureElsaLaval-1.png){#fig-chap02FigureElsaLaval fig-align='center' width=85%}\n:::\n:::\n\n\n\n\n\n\nLa @fig-chap02FigureElsaLaval révèle que l'utilisation d'une matrice circulaire de 400 mètres lisse trop les résultats. Par conséquent, nous privilégions ceux obtenus avec une matrice circulaire de 100 mètres. Puis, avec le code ci-dessous, nous souhaitons identifier les bâtiments avec un environnement immédiat (défini à 100 mètres) avec une forte hétérogénéité spatiale, c'est-à-dire végétalisé.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nous isolons les bâtiments avec forte dissimilarité à proximité\n# la valeur de l'image de sortie (buildings_green) sera 1\nbuildings_green <- (laval_data == 1) & (elsa_100 >= 0.4)\n# Nous isolons les bâtiments avec faible dissimilarité à proximité\n# la valeur de l'image de sortie (buildings_other) sera 2\nbuildings_other <- ((laval_data == 1) & (elsa_100 < 0.4)) * 2\n# Nous combinons les deux images\nraster_buildings <- buildings_green + buildings_other\ntmap_mode(\"view\")\ntm_basemap(c(\"Esri.WorldImagery\", \"OpenStreetMap\"))+\n  tm_shape(raster_buildings) + \n  tm_raster(palette = c(alpha(\"white\",0),  \"green\", \"grey\"),\n            title = \"Bâtiments\",\n            labels = c(\"Transparent (0) : autre que bâtiments\",\n                       \"Vert (1) : forte dissimilarité\", \n                       \"Gris (2) : faible dissimilarité\"),\n            style = 'cat', zindex = 1)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"leaflet html-widget html-fill-item\" id=\"htmlwidget-e69034e356aca9763715\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-e69034e356aca9763715\">{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"createMapPane\",\"args\":[\"tmap001\",1]},{\"method\":\"addProviderTiles\",\"args\":[\"Esri.WorldImagery\",null,\"Esri.WorldImagery\",{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"pane\":\"tilePane\"}]},{\"method\":\"addProviderTiles\",\"args\":[\"OpenStreetMap\",null,\"OpenStreetMap\",{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"pane\":\"tilePane\"}]},{\"method\":\"addRasterImage\",\"args\":[\"data:image/png;base64,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\",[[45.62798301094705,-73.6998417458048],[45.6096134260689,-73.66850511547936]],1,null,\"tmap001\",\"raster_buildings\"]},{\"method\":\"addLegend\",\"args\":[{\"colors\":[\"#FFFFFF\",\"#00FF00\",\"#BEBEBE\"],\"labels\":[\"Transparent (0) : autre que bâtiments\",\"Vert (1) : forte dissimilarité\",\"Gris (2) : faible dissimilarité\"],\"na_color\":null,\"na_label\":\"NA\",\"opacity\":0,\"position\":\"topright\",\"type\":\"unknown\",\"title\":\"Bâtiments\",\"extra\":null,\"layerId\":\"legend001\",\"className\":\"info legend raster_buildings\",\"group\":\"raster_buildings\"}]},{\"method\":\"addLayersControl\",\"args\":[[\"Esri.WorldImagery\",\"OpenStreetMap\"],\"raster_buildings\",{\"collapsed\":true,\"autoZIndex\":true,\"position\":\"topleft\"}]}],\"limits\":{\"lat\":[45.6096134260689,45.62798301094705],\"lng\":[-73.6998417458048,-73.66850511547936]},\"fitBounds\":[45.60965523571319,-73.6998417458048,45.62798301094704,-73.66851836917905,[]]},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n\n\n\n\nSur la carte ci-dessus, nous distinguons clairement deux groupes de bâtiments avec une forte hétérogénéité spatiale dans leur environnement immédiat (en vert) : ceux en bordure du quartier résidentiel et ceux situés le long des rangs Saint-Elzéar Est et Haut-Saint-François au nord-ouest. À l'inverse, les bâtiments au cœur du quartier résidentiel de banlieue affichent une faible hétérogénéité spatiale dans leur environnement immédiat (en gris).\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Indicateur ELSA : données vectorielles et test d'inférence**\n:::\n\n::: bloc_aller_loin-body\n**Données vectorielles**\n\nSi les données sont vectorielles et non matricielles, il convient alors d'utiliser la fonction `elsa_vector` du *package* `geocmeans`.\n\n**Indicateur ELSA et test d'inférence**\n\nDans les fonctions `elsa_raster` et `elsa_vector`, aucun test d'inférence n'est implémenté pour obtenir une valeur de *p* locale. Toutefois, il est assez facile dans R d'appliquer la méthode par simulation Monte-Carlo décrite dans l'article de Naimi *et al.* [-@naimi2019elsa]. Appliquée à des données matricielles, la démarche est la suivante :\n\n-   Créer 999 images dont les valeurs des pixels sont tirées aléatoirement avec remplacement.\n\n-   Recalculer l'indicateur ELSA pour chaque image.\n\n-   Pour chaque pixel, compter le nombre de fois où la valeur observée de l'indicateur ELSA est supérieure ou égale à celles des 999 valeurs simulées.\n\nLa pseudo valeur de *p* pour chaque pixel *i* s'écrit alors :\n\n$$\n  \\text{Pseudo valeur de } p_i = (M+1) / (R+1) \\text{ avec :}\n$$ {#eq-PseudoValeurpELSEA}\n\n$M$ étant le nombre de fois que la valeur observée est supérieure ou égale à la valeur simulée ($E_i \\ge E^*_{ir}$) [@naimi2019elsa, pp. 33-35].\n:::\n:::\n\nAppliquons la démarche ci-dessous dans R pour obtenir une pseudo valeur pour l'indicateur ELSA obtenu sur l'image avec un rayon de 100 mètres. Notez que pour améliorer la vitesse de calcul, nous convertissons notre objet `terra::rast` en une matrice.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Conversion des données matricielles en matrice\nbase_data <- terra::values(laval_data, format = \"matrice\")\n## calcul de la proportion de chaque catégorie\nN <- ncell(base_data)\nprobs <- table(base_data) / N\n## Conversion de l'indicateur ELSA (à 100 mètres) en matrice\nbase_elsa <- terra::values(elsa_100, format = \"matrice\")\n## Création d'une matrice qui contiendra les pseudo valeurs de p\np_matrix <- matrix(0, nrow = nrow(base_elsa), ncol = ncol(base_elsa))\n## Lancement des 999 simulations\nfor(i in 1:999){\n  # pour chaque simulation, nous tirons au hasard la valeur de chaque pixel\n  sim_values <- sample(c(0,1,2,3), size = N, replace = TRUE, prob = probs[1:4])\n  # Nous enregistrons les valeurs tirées au hasard dans une matrice\n  dim(sim_values) <- dim(base_elsa)\n  # Calcul de la valeur de ELSA simulée\n  sim_elsa <- elsa_raster(sim_values, w100, matrice_dissim)\n  # Comparaison des valeurs de l'indicateur ELSA (valeurs simulées versus observées)\n  comp_matrix <- base_elsa >= sim_elsa\n  # Ajout à notre matrice des valeurs de p\n  p_matrix <- p_matrix + comp_matrix\n}\n## Conversion des comptages en pseudo valeur de p\np_values <- p_matrix / (999+1)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nDans la matrice obtenue, les pseudos valeurs de *p* représentent la probabilité que l'indice de *ELSA* obtenu sur les données réelles soit inférieur à celui obtenu si les données étaient réparties aléatoirement sur le territoire. Une pseudo valeur de *p* inférieure à 0,001 signifie donc qu'il n'y aurait que 0,1 % de chance que le hasard produise un patron d'autocorrélation spatiale plus fort que celui observé avec les données initiales.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nraster_p_vals <- laval_data\nvalues(raster_p_vals) <- p_values <= 0.001\ntmap_mode(\"plot\")\n\nCarte1 <- tm_shape(raster_p_vals) +\n  tm_raster(palette = c(\"grey\", \"red\"),\n            style = 'cat',\n            title = \"Significativité\",\n            labels = c(\"Non significatif (p > 0,001)\",\n                       \"Significatif (p <= 0,001)\")) +\n  tm_layout(legend.outside = TRUE, \n            frame = FALSE,\n            legend.outside.position = c(\"bottom\", \"center\"))\n\nCarte2 <- tm_shape(elsa_100) + \n  tm_raster(palette = \"RdYlGn\", n = 6, \n\t\t\tlegend.format = list(text.separator = \"à\"),\n            title = \"ELSA 100 mètres\") + \n  tm_layout(legend.outside = TRUE, \n            frame = FALSE,\n            legend.outside.position =  c(\"bottom\", \"center\"))\n\nCarte3 <- tm_shape(laval_data) + \n  tm_raster(palette = c(\"#fbd4b4\", \"#e36c0a\", \"#92d050\", \"#76923c\"),\n            style = 'cat',\n            title = \"Classe (catégorie)\",\n            labels = c(\"1. Minéral bas\",\n                       \"2. Minéral haut\",\n                       \"3. Végétal bas\",\n                       \"4. Végétal haut\"))+\n  tm_layout(legend.outside = TRUE, \n            frame = FALSE,\n            legend.outside.position =  c(\"bottom\", \"center\"))\n\ntmap_arrange(Carte3, Carte2, Carte1, ncol=3)\n```\n\n::: {.cell-output-display}\n![Cartographie des valeurs de *p* de l'indicateur ELSA](02-Autocorrelation_files/figure-html/fig-chap02FigureElsaPval-1.png){#fig-chap02FigureElsaPval fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n\n\nLa @fig-chap02FigureElsaPval montre en rouge les pixels situés dans des secteurs avec une forte autocorrélation spatiale, soit ceux principalement végétalisés ou principalement minéralisés.\n\n## Quiz de révision du chapitre {#sec-025}\n\n\n\n\n\n\n<div id=\"Chap02\" class=\"card\">\n<link type=\"text/javascript\" src=\"libs/quizlib.1.0.1.min.js\"/>\n<script>var Quiz=function(a,b){this.Classes=Object.freeze({QUESTION:\"quizlib-question\",QUESTION_TITLE:\"quizlib-question-title\",QUESTION_ANSWERS:\"quizlib-question-answers\",QUESTION_WARNING:\"quizlib-question-warning\",CORRECT:\"quizlib-correct\",INCORRECT:\"quizlib-incorrect\",TEMP:\"quizlib-temp\"}),this.unansweredQuestionText=\"Question sans réponse !\",this.container=document.getElementById(a),this.questions=[],this.result=new QuizResult,this.answers=b;for(var c=0;c<this.container.children.length;c++)this.container.children[c].classList.contains(Quiz.Classes.QUESTION)&&this.questions.push(this.container.children[c]);if(this.answers.length!=this.questions.length)throw new Error(\"Number of answers does not match number of questions!\")};Quiz.Classes=Object.freeze({QUESTION:\"quizlib-question\",QUESTION_TITLE:\"quizlib-question-title\",QUESTION_ANSWERS:\"quizlib-question-answers\",QUESTION_WARNING:\"quizlib-question-warning\",CORRECT:\"quizlib-correct\",INCORRECT:\"quizlib-incorrect\",TEMP:\"quizlib-temp\"}),Quiz.prototype.checkAnswers=function(a){void 0===a&&(a=!0);for(var b=[],c=[],d=0;d<this.questions.length;d++){var e=this.questions[d],f=this.answers[d],g=[];this.clearHighlights(e);for(var h,i=e.getElementsByClassName(Quiz.Classes.QUESTION_ANSWERS)[0].getElementsByTagName(\"input\"),j=0;j<i.length;j++)h=i[j],\"checkbox\"===h.type||\"radio\"===h.type?h.checked&&g.push(h.value):\"\"!==h.value&&g.push(h.value);1!=g.length||Array.isArray(f)?0===g.length&&b.push(e):g=g[0],c.push(Utils.compare(g,f))}if(0===b.length||!a)return this.result.setResults(c),!0;for(d=0;d<b.length;d++){var k=document.createElement(\"span\");k.appendChild(document.createTextNode(this.unansweredQuestionText)),k.className=Quiz.Classes.QUESTION_WARNING,b[d].getElementsByClassName(Quiz.Classes.QUESTION_TITLE)[0].appendChild(k)}return!1},Quiz.prototype.clearHighlights=function(a){for(var b=a.getElementsByClassName(Quiz.Classes.QUESTION_WARNING);b.length>0;)b[0].parentNode.removeChild(b[0]);var c,d=[a.getElementsByClassName(Quiz.Classes.CORRECT),a.getElementsByClassName(this.Classes.INCORRECT)];for(i=0;i<d.length;i++)for(;d[i].length>0;)c=d[i][0],c.classList.remove(Quiz.Classes.CORRECT),c.classList.remove(Quiz.Classes.INCORRECT);for(var e=a.getElementsByClassName(Quiz.Classes.TEMP);e.length>0;)e[0].parentNode.removeChild(e[0])},Quiz.prototype.highlightResults=function(a){for(var b,c=0;c<this.questions.length;c++)b=this.questions[c],b.getElementsByClassName(Quiz.Classes.QUESTION_TITLE)[0].classList.add(this.result.results[c]?Quiz.Classes.CORRECT:Quiz.Classes.INCORRECT),void 0!==a&&a(this,b,c,this.result.results[c])};var QuizResult=function(){this.results=[],this.totalQuestions=0,this.score=0,this.scorePercent=0,this.scorePercentFormatted=0};QuizResult.prototype.setResults=function(a){this.results=a,this.totalQuestions=this.results.length,this.score=0;for(var b=0;b<this.results.length;b++)this.results[b]&&this.score++;this.scorePercent=this.score/this.totalQuestions,this.scorePercentFormatted=Math.floor(100*this.scorePercent)};var Utils=function(){};Utils.compare=function(a,b){if(a.length!=b.length)return!1;if(Array.isArray(a)&&Array.isArray(b)){for(var c=0;c<a.length;c++)if(a[c]!==b[c])return!1;return!0}return a===b};\n\nfunction showResults(quiz) {\n    // Check answers and continue if all questions have been answered\n    if (quiz.checkAnswers()) {\n        var quizScorePercent = quiz.result.scorePercentFormatted; // The unformatted percentage is a decimal in range 0 - 1\n        var quizResultElement = document.getElementById('quiz-result');\n        quizResultElement.style.display = 'block';\n        document.getElementById('quiz-percent').innerHTML = quizScorePercent.toString();\n\n        // Change background colour of results div according to score percent\n        if (quizScorePercent > 75) quizResultElement.style.backgroundColor = '#4caf50';\n        else if (quizScorePercent > 50) quizResultElement.style.backgroundColor = '#ffc107';\n        else if (quizScorePercent > 25) quizResultElement.style.backgroundColor = '#ff9800';\n        else if (quizScorePercent > 0) quizResultElement.style.backgroundColor = '#f44336';\n\n        // Highlight questions according to whether they were correctly answered. The callback allows us to highlight/show the correct answer\n        quiz.highlightResults(handleAnswers);\n    }\n}\n\n/** Callback for Quiz.highlightResults. Highlights the correct answers of incorrectly answered questions\n * Parameters are: the quiz object, the question element, question number, correctly answered flag\n */\nfunction handleAnswers(quiz, question, no, correct) {\n    if (!correct) {\n        var answers = question.getElementsByTagName('input');\n        for (var i = 0; i < answers.length; i++) {\n            if (answers[i].type === 'checkbox' || answers[i].type === 'radio'){\n                // If the current input element is part of the correct answer, highlight it\n                if (quiz.answers[no].indexOf(answers[i].value) > -1) {\n                    answers[i].parentNode.classList.add(Quiz.Classes.CORRECT);\n                }\n            } else {\n                // If the input is anything other than a checkbox or radio button, show the correct answer next to the element\n                var correctAnswer = document.createElement('span');\n                correctAnswer.classList.add(Quiz.Classes.CORRECT);\n                correctAnswer.classList.add(Quiz.Classes.TEMP); // quiz.checkAnswers will automatically remove elements with the temp class\n                correctAnswer.innerHTML = quiz.answers[no];\n                correctAnswer.style.marginLeft = '10px';\n                answers[i].parentNode.insertBefore(correctAnswer, answers[i].nextSibling);\n            }\n        }\n    }\n}\n\n  var quizz_Chap02;\n  window.onload = function() {\n    quizz_Chap02 = new Quiz('Chap02', [['1', '2', '3', '4'],'2','1',['1', '2', '3'],'1',['1', '2'],'3',['1', '3', '4']]);\n  };</script>\n<link rel=\"stylesheet\" type=\"text/css\" src=\"css/quizlib.min.css\"/>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Parmi les matrices de pondération spatiale ci-dessous, lesquelles sont des matrices de contiguïté?</div>\n<div>Relisez au besoin la [section @sec-022].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Partage d’un nœud</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q1\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Partage d’un segment</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q1\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Partage d’un nœud et ordre d’adjacence</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q1\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Partage d’un segment et ordre d’adjacence</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q1\" value=\"4\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Connectivité selon la distance</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q1\" value=\"5\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">En anglais, comment est appelée une matrice selon le partage d'un nœud?</div>\n<div>Relisez au besoin le début de la [section @sec-022].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Rook</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q2\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Queen</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q2\" value=\"2\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Comparativement à une matrice de l'inverse de la distance, une matrice de l'inverse de la distance au carré accorde un poids plus important aux entités proches.</div>\n<div>Relisez au besoin la [section @sec-02223].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Vrai</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q3\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Faux</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q3\" value=\"2\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Quels sont les avantages de la standardisation en ligne des matrices de pondération spatiale?</div>\n<div>Relisez au besoin la [section @sec-0223].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>La somme de chaque ligne est égale à 1.</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q4\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>La somme de l'ensemble de la matrice est égale au nombre d'entités spatiales.</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q4\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>La standardisation permet de comparer la dépendance spatiale selon différentes matrices.</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q4\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>La standardisation augmente la vitesse des calculs.</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q4\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Quelle est la différence entre les deux mesures locales de Getis et Ord?</div>\n<div>Relisez au besoin la [section @sec-0241].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Gi* tient compte à la fois des valeurs des entités voisines ou proches, mais aussi de celle de i.</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q5\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Contrairement à Gi, Gi* a un z-score.</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q5\" value=\"2\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Parmi les quatre catégories de la typologie basée sur le nuage de points du I de Moran, lesquelles renvoient à de l'autocorrélation spatiale locale positive?</div>\n<div>Relisez au besoin la [section @sec-0243].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>HH</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q6\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>LL</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q6\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>HL</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q6\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>LH</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q6\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Le village gaulois correspond à quelle catégorie?</div>\n<div>Relisez au besoin la [section @sec-0243].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>HH</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q7\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>LL</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q7\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>HL</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q7\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>LH</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q7\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Quelles sont les trois manières de tester la significativité des mesures d'autocorrélation globales?</div>\n<div>Relisez au besoin la [section @sec-02313].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Avec l'hypothèse de la normalité</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q8\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>En relançant plusieurs fois les calculs</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q8\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Avec l'hypothèse de la randomisation</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q8\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Avec la méthode Monte-Carlo (habituellement avec 999 échantillons)</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q8\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<button type=\"button\" onclick=\"showResults(quizz_Chap02);\" id=\"buttonID\">Vérifiez votre résultat</button>\n<div id=\"quiz-result\" class=\"card\">\n<span id=\"quiz-percent\"></span>\n</div>\n</div>\n\n\n\n\n\n\n## Exercices de révision {#sec-026}\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 2.** Construction de matrices de pondération spatiale\n:::\n\n::: bloc_exercice-body\nConstruisez les matrices de pondération spatiale suivante pour la région métropolitaine de Québec :\n\n-   Matrice de pondération spatiale selon le partage d'un segment commun (voir la [section @sec-02241]).\n-   Matrice de pondération spatiale selon l'inverse de la distance au carré, à partir de la distance maximale et un SR et son voisin le plus proche (voir la [section @sec-02244]).\n-   Matrice de pondération spatiale selon le critère des plus proches voisins (*k* = 2) (voir la [section @sec-02245]).\n\nComplétez le code ci-dessous.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(spdep)\nlibrary(tmap)\n## Importation de la couche des secteurs de recensement\nSRQc <- st_read(dsn = \"data/chap02/exercice/RMRQuebecSR2021.shp\", quiet=TRUE)\n\n## Matrice selon le partage d'un segment (Rook)\nRook <- À compléter\nW.Rook <- À compléter\n\n## Coordonnées des centroïdes des entités spatiales\ncoords <- st_coordinates(st_centroid(SRQc))\n\n## Matrice de l'inverse de la distance réduite\n# Trouver le plus proche voisin avec la fonction knn2nb\nk1 <- À compléter\nplusprochevoisin.max <- max(unlist(nbdists(k1,coords)))\n# Voisins les plus proches avec le seuil de distance maximal\nVoisins.DistMax <- À compléter\n# Distances avec le seuil maximum\ndistances <- À compléter\n# Inverse de la distance au carré\nInvDistances2 <- À compléter\n# Matrices de pondération spatiale standardisées en ligne\nW_InvDistances2 <- À compléter\n\n## Matrice des plus proches voisins avec k = 2\nk2 <- À compléter\nW.k2 <-  À compléter\n```\n:::\n\n\n\n\n\n\nCorrection à la [section @sec-12022].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 3.** Calcul du *I* de Moran global\n:::\n\nCalculez le *I* de Moran global pour la variable `D1pct` (pourcentage du premier décile de revenu des familles économiques) de la couche `SRQc` avec les différentes matrices de pondération spatiale (voir la [section @sec-02322]). Complétez le code ci-dessous.\n\n::: bloc_exercice-body\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(spdep)\nlibrary(tmap)\n## Cartographie de la variable\ntm_shape(SRQc)+\n  tm_polygons(col=\"D1pct\", title = \"Premier décile de revenu (%)\",\n              style=\"quantile\", n=5, palette=\"Greens\")+\n  tm_layout(frame = F)+tm_scale_bar(c(0,5,10))\n\n## I de Moran avec la méthode Monte-Carlo avec 999 permutations\n# utilisez la fonction moran.mc\n# avec la matrice W.Rook\nÀ compléter\n# avec la matrice W_InvDistances2Reduite\nÀ compléter\n# avec la matrice W.k2\nÀ compléter\n```\n:::\n\n\n\n\n\n\nQuelle matrice de pondération spatiale donne la dépendance spatiale la plus forte? Correction à la [section @sec-12023].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 3.** Mesures d'autocorrélation spatiale locales\n:::\n\n::: bloc_exercice-body\nCalculez et cartographiez les mesures d'autocorrélation spatiale locale pour la variable `D1pct` de la couche `SRQc` avec la matrice spatiale `W.Rook` :\n\n-   Mesure $G_i$ de Getis et Ord (voir la [section @sec-0241]).\n-   Typologie du nuage de points du *I* de Moran avec la fonction `localmoran` (voir la [section @sec-0243]).\n\nComplétez le code ci-dessous.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n####################\n## Calcul du Z(Gi)\n####################\nSRQc$D1pct_localGetis <- localG(À compléter, \n                                À compléter, \n                                zero.policy=TRUE)\n# Définition des intervalles et des noms des classes\nclasses.intervalles = À compléter\nclasses.noms = c(\"Point froid (p = 0,001)\", \n                \"Point froid (p = 0,01)\", \n                \"Point froid (p = 0,05)\", \n                \"Non significatif\",\n                \"Point chaud (p = 0,05)\", \n                \"Point chaud (p = 0,01)\", \n                \"Point chaud (p = 0,001)\")\n## Création d'un champ avec les noms des classes\nSRQc$D1pct_localGetisP <- cut(SRQc$D1pct_localGetis,\n                              breaks = classes.intervalles,\n                              labels = classes.noms)\n## Cartographie\nÀ compléter\n\n####################\n## Typologie LISA\n####################\n## Cote Z (variable centrée réduite)\nzx <- À compléter\n## variable X centrée réduite spatialement décalée avec une matrice Rook\nwzx <- lag.listw(À compléter)\n## I de Moran local (notez que vous pouvez aussi utiliser la fonction localmoran_perm)\nlocalMoranI  <- localmoran(À compléter)\nplocalMoranI <- localMoranI[, 5]\n## Choisir un seuil de signification\nsignif = 0.05\n## Construction de la typologie\nTypologie <- ifelse(zx > 0 & wzx > 0, \"1. HH\", NA)\nTypologie <- ifelse(zx < 0 & wzx < 0, \"2. LL\", Typologie)\nTypologie <- ifelse(zx > 0 & wzx < 0, \"3. HL\", Typologie)\nTypologie <- ifelse(zx < 0 & wzx > 0, \"4. LH\", Typologie)\nTypologie <- ifelse(plocalMoranI > signif, \"Non sign\", Typologie)  # Non significatif\n## Enregistrement de la typologie dans un champ\nSRQc$TypoIMoran.D1pct <- Typologie\n## Couleurs\nCouleurs <- c(\"red\", \"blue\", \"lightpink\", \"skyblue2\", \"lightgray\")\nnames(Couleurs) <- c(\"1. HH\",\"2. LL\",\"3. HL\",\"4. LH\",\"Non sign\")\n## Cartographie\ntmap_mode(\"plot\")\nÀ compléter\n```\n:::\n\n\n\n\n\n\nCorrection à la [section @sec-12024].\n:::\n:::\n\n",
    "supporting": [
      "02-Autocorrelation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n<link href=\"site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"site_libs/leaflet-1.3.1/leaflet.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/leaflet-1.3.1/leaflet.js\"></script>\n<link href=\"site_libs/leafletfix-1.0.0/leafletfix.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/proj4-2.6.2/proj4.min.js\"></script>\n<script src=\"site_libs/Proj4Leaflet-1.0.1/proj4leaflet.js\"></script>\n<link href=\"site_libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/leaflet-binding-2.2.2/leaflet.js\"></script>\n<script src=\"site_libs/leaflet-providers-2.0.0/leaflet-providers_2.0.0.js\"></script>\n<script src=\"site_libs/leaflet-providers-plugin-2.2.2/leaflet-providers-plugin.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}