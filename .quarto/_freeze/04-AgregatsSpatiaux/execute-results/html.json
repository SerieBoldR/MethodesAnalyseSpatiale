{
  "hash": "08ff9cc18d03233dc11cc2fb7f00645b",
  "result": {
    "engine": "knitr",
    "markdown": "# Méthodes de détection d'agrégats spatiaux et spatio-temporels {#sec-chap04}\n\nDans ce chapitre, nous abordons deux familles de méthodes de détection d'agrégats spatiaux et spatio-temporels qui s'appliquent à des géométries différentes : les méthodes de classification basées sur la densité des points (couche de points), principalement les algorithmes DBSCAN [@DBSCAN1996] et ST-DBSCAN [@birant2007st], et les méthodes de balayage de Kulldorff [-@kulldorff1997spatial] (couche polygonale).\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n\n::: bloc_package-body\n-   Pour importer et manipuler des fichiers géographiques :\n    -   `sf` pour importer et manipuler des données vectorielles.\n    -   `dplyr` pour manipuler les données.\n-   Pour construire des cartes et des graphiques :\n    -   `tmap` pour les cartes.\n    -   `ggplot2` pour construire des graphiques.\n-   `dbscan` pour l'algorithme DBSCAN.\n-   `SpatialEpi` pour les méthodes de balayage de Kurlldoff.\n:::\n:::\n\n## Agrégats d'entités spatiales ponctuelles {#sec-041}\n\n### DBSCAN : agrégats spatiaux {#sec-0411}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Pourquoi utiliser DBSCAN ?**\n:::\n\n::: bloc_objectif-body\nDans le chapitre précédent, portant sur les *méthodes de répartition ponctuelles*, nous avons abordé la méthode KDE permettant de cartographier la densité de points dans une maille régulière ([section @sec-0342]). La carte de chaleur obtenue avec la KDE représente les valeurs de densité (variable continue) pour les pixels couvrant le territoire à l'étude.\n\nAvec l'algorithme DBSCAN [@DBSCAN1996], l'objectif est différent : il s'agit d'**identifier des agrégats spatiaux d'évènements ponctuels dans un territoire donné** (par exemple, des cas de maladies, d'accidents, d'espèces fauniques ou végétales, de crimes, etc.). Autrement dit, il s'agit d'identifier plusieurs régions du territoire à l'étude dans lesquelles la densité de points est forte.\n\nConcrètement, si la méthode KDE renvoie une variable continue pour l'ensemble du territoire, l'algorithme DBSCAN renvoie une variable qualitative uniquement pour les points du jeu de données.\n:::\n:::\n\n#### Fonctionnement de DBSCAN {#sec-04111}\n\nDBSCAN (***D**ensity-**B**ased **S**patial **C**lustering of **A**pplications with **N**oise*) est un algorithme de classification non supervisée qui regroupe des observations en fonction de **leur densité** dans un espace à deux, trois ou *n* dimensions [@DBSCAN1996]. Comme pour toute autre méthode de classification non supervisée, ces dimensions sont des variables. Par conséquent, en appliquant DBSCAN sur les coordonnées géographiques d'entités ponctuelles 2D (*x*, *y*) ou 3D (*x*, *y*, *z*), nous classifions les points du jeu de données.\n\nPrenons un jeu de données fictives (@fig-DonnesFictivesDBSCAN, a). À l'œil nu, nous identifions clairement cinq régions distinctes avec une forte densité de points et des zones de faible densité; ces dernières étant représentées par les points noirs avec DBSCAN (@fig-DonnesFictivesDBSCAN, b).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Jeu de données fictives et classification DBSCAN avec cinq classes](04-AgregatsSpatiaux_files/figure-html/fig-DonnesFictivesDBSCAN-1.png){#fig-DonnesFictivesDBSCAN fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\n\nL'intérêt majeur de l'algorithme DBSCAN est qu'il est basé sur la **densité des points** et non sur la **distance entre les points** comme les algorithmes classiques de classification non supervisée que sont les k-moyennes, k-médianes, k-médoïdes ou la classification ascendante hiérarchique. Tel qu'illustré à la @fig-AutresMethodesClassifNonSuperv, l'utilisation de la distance pour identifier cinq groupes de points renvoie des résultats peu convaincants. D'une part, tous les points appartiennent à une classe, sans séparer les régions de fortes et de faibles densités. D'autre part, les algorithmes classiques basés sur la distance ne parviennent pas à bien identifier les deux agrégats circulaires (bleu et rouge à la @fig-DonnesFictivesDBSCAN, b) et parfois linéaires (vert et mauve à la @fig-DonnesFictivesDBSCAN, b).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Classification avec d'autres algorithmes basés sur la distance](04-AgregatsSpatiaux_files/figure-html/fig-AutresMethodesClassifNonSuperv-1.png){#fig-AutresMethodesClassifNonSuperv fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\nL'algorithme DBSCAN comprend deux paramètres qui doivent être définis par la personne utilisatrice :\n\n-   **Le rayon de recherche**, dénommé $\\epsilon$ (epsilon), habituellement basé sur la distance euclidienne. Les distances de Manhattan ou réticulaires peuvent aussi être utilisées.\n\n-   **Le nombre minimum de points**, dénommé $MinPts$, requis pour qu'un point, incluant lui-même, soit considéré comme un point central et appartienne à un agrégat, un regroupement (*cluster* en anglais).\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Avantage de DBSCAN : nul besoin de spécifier le nombre d'agrégats (*clusters*)!**\n:::\n\n::: bloc_notes-body\nComparativement à d'autres méthodes de classification non supervisées comme les k-moyennes, k-médianes et k-médoïdes, DBSCAN ne requiert pas de spécifier le nombre de classes à identifier dans le jeu de données. Autrement dit, appliqué à des géométries ponctuelles, l'algorithme DBSCAN détecte autant d'agrégats spatiaux que nécessaire en fonction des valeurs des deux paramètres ($\\epsilon$ et $MinPts$).\n:::\n:::\n\nÀ la @fig-TypesPointsDBSCAN, nous appliquons l'algorithme DBSCAN à un semis de points avec un rayon de recherche de 500 mètres ($\\epsilon=500$) et un nombre minimum de cinq points ($MinPts = 5$). Dans un premier temps, l'algorithme distingue trois types de points :\n\n1.  Des **points centraux** (*core points* en anglais) qui ont au moins cinq points (incluant eux-mêmes) dans un rayon de 500 mètres (points rouges).\n2.  Des **points frontières** (*border points*) qui ont moins de cinq points (incluant eux-mêmes) dans un rayon de 500 mètres, mais qui sont inclus dans la zone tampon de 500 mètres d'un point central (points bleus).\n3.  Des **points aberrants** (*noise points*) qui ont moins de cinq points (incluant eux-mêmes) dans un rayon de 500 mètres et qui ne sont pas inclus dans la zone tampon d'un point central (points noirs).\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n![Trois types de points identifiés par l'algorithme DBSCAN](images/Chap04/DbscanTypesPoints.png){#fig-TypesPointsDBSCAN width=\"65%\" fig-align=\"center\"}\n\nPar la suite, les étapes de l'algorithme sont les suivantes :\n\n-   **Étape 1.** Formation du premier agrégat\n\n    -   Nous tirons au hasard un point central et l'assignons au premier agrégat (groupe ou *cluster*).\n\n    -   Puis, les points compris dans la zone tampon du premier point central sont ajoutés à ce premier agrégat.\n\n    -   De façon itérative, nous étendons l'agrégat avec les points centraux ou frontières qui sont compris dans les zones tampons des points ajoutés précédemment.\n\n-   **Étape 2.** Formation d'autres agrégats\n\n    -   Lorsque le premier agrégat est complété, nous tirons au hasard un autre point central n'appartenant pas au premier agrégat.\n\n    -   Nous appliquons la même démarche qu'à l'étape 1 pour étendre et compléter cet autre agrégat.\n\n    -   Les deux sous-étapes ci-dessus sont répétées jusqu'à ce que tous les points centraux et frontières soient assignés à un agrégat.\n\nNous obtenons ainsi *k* agrégats (valeurs de 1 à *k*) tandis que les points aberrants sont affectés à la même classe (valeur de 0 habituellement). Appliqué au semis de points, DBSCAN a détecté deux agrégats et quatre points aberrants (@fig-ResultatsDBSCAN).\n\n![Résultats de l'algorithme DBSCAN](images/Chap04/DbscanResultats.png){#fig-ResultatsDBSCAN width=\"65%\" fig-align=\"center\"}\n\n#### Sensibilité et optimisation des paramètres de DBSCAN {#sec-04112}\n\nLes résultats de l'algorithme de DBSCAN varient en fonction de ses deux paramètres, soit le rayon de recherche ($\\epsilon$) et le nombre minimum de points ($MinPts$).\n\nConcernant le paramètre $\\epsilon$, plus sa valeur est réduite, plus le nombre de points identifiés comme aberrants est important. Inversement, plus elle est grande, plus le nombre d'agrégats diminue. En guise d'illustration, faisons varier la valeur du rayon en maintenant à cinq le nombre minimum de points :\n\n-   Avec un rayon de 250 mètres, cinq agrégats sont identifiés tandis que 29 points sont considérés comme du bruit (@fig-VariationResultatsDBSCAN, a).\n\n-   Avec un rayon de 500 mètres, la solution est plus optimale avec deux agrégats et cinq points aberrants (@fig-VariationResultatsDBSCAN, b).\n\n-   Avec un rayon de 1000 mètres, deux agrégats sont aussi identifiés. Par contre, il ne reste plus qu'un point aberrant. Par conséquent, quatre points qui, à l'œil nu, sont très éloignés d'un agrégat y sont pourtant affectés (@fig-VariationResultatsDBSCAN, c).\n\n-   Avec un rayon de 1500 mètres, tous les points sont affectés à un et un seul agrégat (@fig-VariationResultatsDBSCAN, d).\n\n![Variations de résultats de l'algorithme DBSCAN selon la taille du rayon](images/Chap04/DbscanResultatsVariation.png){#fig-VariationResultatsDBSCAN width=\"65%\" fig-align=\"center\"}\n\nConcernant le paramètre $MinPts$, plusieurs stratégies ont été proposées pour fixer sa valeur :\n\n-   $MinPts \\geq dim(D) + 1$, c'est-à-dire que sa valeur doit être minimalement égale au nombre de dimensions (variables) plus un du jeu de données.\n-   $MinPts = dim(D) \\times 2$, c'est-à-dire que le nombre de points devrait être égal à deux fois le nombre de dimensions du tableau [@sander1998density].\n-   $MinPts = 4$ quand le jeu de données ne comprend que deux dimensions [@DBSCAN1996], soit un critère qui s'applique à des géométries ponctuelles 2D.\n\nAprès avoir fixé le nombre minimal de points, nous pouvons optimiser la valeur du rayon de recherche de la façon suivante :\n\n-   Pour chacun des points, calculer la distance au *k*^ième^ point le plus proche.\n\n-   Trier les valeurs obtenues pour construire un graphique en courbe.\n\n-   Dans ce graphique, utiliser le *critère du coude* pour repérer la ou les valeurs signalant un décrochement dans la courbe. À la lecture de la @fig-KPlusProcheDbScan, les valeurs d'epsilon ($\\epsilon$) à retenir pourraient être 300, 350, 425 et 450 mètres.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Optimisation de la valeur d'epsilon](04-AgregatsSpatiaux_files/figure-html/fig-KPlusProcheDbScan-1.png){#fig-KPlusProcheDbScan fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\nSi vous repérez plusieurs seuils de distance dans le graphique des distances au *k*^ième^ plus proche voisin, réalisez et comparez les résultats des DBSCAN avec ces valeurs d'epsilon. À la @fig-DbscanResultatsOptimatisationEpsilon, nous constatons que les résultats avec des seuils de 425 et 450 mètres sont identiques et semblent optimaux. Par contre, la solution avec un rayon de 350 mètres identifie deux points aberrants qui pourraient être intégrés au deuxième agrégat tandis que celle avec un rayon de 300 mètres identifie un agrégat supplémentaire, mais classifie de nombreux points comme aberrants.\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Quel résultat choisir parmi les quatre solutions?**\n:::\n\n::: bloc_attention-body\nComme pour toute analyse de classification, votre choix peut être objectif et reposer uniquement sur des indicateurs statistiques (ici, le graphique des distances au *k* plus proche voisin). Il devrait aussi s'appuyer sur vos connaissances du terrain. Par exemple, l'identification d'un troisième agrégat avec une valeur d'epsilon fixée à 300 mètres pourrait refléter selon vous une réalité terrain particulièrement intéressante qui motiverait fortement le choix de cette solution.\n:::\n:::\n\n![Comparaison de solutions DBSCAN avec différentes valeurs d'epsilon](images/Chap04/DbscanResultatsOptimatisationEpsilon.png){#fig-DbscanResultatsOptimatisationEpsilon width=\"65%\" fig-align=\"center\"}\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Autres algorithmes de classification non supervisée basée sur la densité**\n:::\n\n::: bloc_aller_loin-body\nBien que DBSCAN soit l'algorithme le plus utilisé, d'autres algorithmes basés sur la densité peuvent être utilisés pour détecter des agrégats spatiaux de points, notamment :\n\n-   HDBSCAN (***H**ierarchical **D**ensity-**B**ased **S**patial **C**lustering of **A**pplications with **N**oise*) [@HDBSCAN2013]. Brièvement, cette version modifiée de DBSCAN permet d'obtenir une hiérarchie de partitions, comme dans une classification ascendante hiérarchique.\n\n-   OPTICS (***O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure*) [@HDBSCAN2013]. Avec OPTICS, la distance de voisinage ($\\epsilon$) n'a pas besoin d'être spécifiée. Succinctement, pour chaque point du jeu de données, il utilise la distance au $k$ ($MinPts$) plus proche voisin.\n\n**Application à des évènements localisés sur un réseau de rues**\n\nLorsque les évènements sont localisés sur un réseau de rues (des accidents par exemple), il convient d'utiliser une autre métrique que la distance euclidienne pour le rayon de recherche ($\\epsilon$), soit la distance du chemin le plus court à travers le réseau de rues, ce que nous verrons au chapitre suivant ([section @sec-064]). Geoff Boeing a aussi proposé un [un code Python](https://geoffboeing.com/2018/04/network-based-spatial-clustering/) basé sur la librairie [OSMnx](https://geoffboeing.com/2016/11/osmnx-python-street-networks/).\n\n:::\n:::\n\n### ST-DBSCAN : agrégats spatio-temporels {#sec-0412}\n\nDerya Birant et Alp Kut [-@birant2007st] ont proposé une modification de l'algorithme de DBSCAN afin qu'il puisse s'appliquer à des données spatio-temporelles ($x$, $y$, $d$) avec $d$ étant la date de l'évènement. Dénommé ST-DBSCAN, l'algorithme comprend toujours les deux paramètres de DBSCAN ($MinPts$ et $\\epsilon$), auxquels s'ajoute un autre paramètre $\\epsilon$ pour le temps (défini en heure, jour, semaine, mois ou année). Autrement dit, deux paramètres de distance sont utilisés : $\\epsilon_1$ pour la proximité spatiale (comme avec DBSCAN) et $\\epsilon_2$ pour la proximité temporelle [@birant2007st]. De la sorte, deux points sont considérés comme voisins si la distance spatiale et la distance temporelle sont toutes deux inférieures aux seuils fixés.\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Fenêtre temporelle des points formant un agrégat**\n:::\n\n::: bloc_attention-body\nAttention, les points formant un agrégat peuvent avoir une fenêtre temporelle bien plus grande que le seuil $\\epsilon_2$ fixé. Par exemple, fixons les valeurs de $\\epsilon_1$ à 500 mètres et de $\\epsilon_2$ à 7 jours. Si le point A ($d$ = 2023-01-15) est distant de 400 mètres du point B ($d$ = 2023-01-20), les deux points sont considérés comme voisins. Par contre, si le point B est distant du point C ($d$ = 2023-01-25) de moins de 500 mètres, il peut être aussi agrégé à l'agrégat puisque l'écart temporel entre B et C est de 5 jours.\n\nHabituellement, plus la valeur de $\\epsilon_2$ est faible, plus le nombre de points considérés comme aberrants est important.\n:::\n:::\n\n### Mise en œuvre dans R {#sec-0414}\n\n#### DBSCAN {#sec-04141}\n\nNous utilisons le *package* `dbscan` [@dbscanPackage1; @dbscanPackage2] dans lequel sont implémentés plusieurs algorithmes, dont DBSCAN, mais aussi OPTICS et HDBSCAN. La fonction `dbscan(x, eps, minPts, weights = NULL)` comprend plusieurs paramètres :\n\n-   `x`: une matrice, un *DataFrame*, un objet `dist` ou un objet `frNN`.\n-   `eps`: le rayon de recherche epsilon ($\\epsilon$).\n-   `minPts`: le nombre de points minimum requis pour que chaque point soit considéré comme un point central.\n-   `weights`: un vecteur numérique optionnel pour pondérer les points.\n\nPour illustrer le fonctionnement de la méthode DBSCAN, nous avons extrait les accidents d'un [jeu de données sur les incidents de sécurité publique survenus sur le territoire de la Ville de Sherbrooke de juillet 2019 à juin 2022](https://donneesouvertes-sherbrooke.opendata.arcgis.com/datasets/64d19d62f0804f5896e4b24c32aea49d_0/explore?location=45.403675%2C-71.960143%2C12.65) (@fig-CartoAccidents).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Accidents survenus entre juillet 2019 et juin 2022, Ville de Sherbrooke](04-AgregatsSpatiaux_files/figure-html/fig-CartoAccidents-1.png){#fig-CartoAccidents fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\nDans le code ci-dessous, nous réalisons trois étapes préalables au calcul de DBSCAN :\n\n-   Importation des accidents.\n-   Récupération des coordonnées ($x$, $y$) des accidents et stockage dans une matrice.\n-   Construction du graphique à partir de la distance au quatrième point le plus proche.\n\nNous n'observons pas de décrochement particulier dans la courbe de la @fig-GraphiqueAccidentsDist4. Par conséquent, nous pourrions tout aussi bien retenir une distance euclidienne de 250, 500, 1000 ou 1500 mètres pour epsilon.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(tmap)\nlibrary(dbscan)\nlibrary(ggplot2)\n## Importation des accidents\nAccidents.sf <- st_read(dsn = \"data/chap04/DataAccidentsSherb.shp\", quiet=TRUE)\n## Coordonnées géographiques\nxy <- st_coordinates(Accidents.sf)\n## Graphique pour la distance au quatrième voisin le plus proche\nDistKplusproche <- kNNdist(xy, k = 4)\nDistKplusproche <- as.data.frame(sort(DistKplusproche, decreasing = FALSE))\nnames(DistKplusproche) <- \"distance\"\nggplot(data = DistKplusproche)+\n  geom_path(aes(x = 1:nrow(DistKplusproche), y = distance), size=1)+\n  labs(x = \"Points triés par ordre croissant selon la distance\",\n       y = \"Distance au quatrième point le plus proche\")+\n  geom_hline(yintercept=250, color = \"#08306b\", linetype=\"dashed\", size=1)+\n  geom_hline(yintercept=500, color = \"#00441b\", linetype=\"dashed\", size=1)+\n  geom_hline(yintercept=1000, color = \"#67000d\", linetype=\"dashed\", size=1)+\n  geom_hline(yintercept=1500, color = \"#3f007d\", linetype=\"dashed\", size=1)\n```\n\n::: {.cell-output-display}\n![Optimisation de la valeur d’epsilon pour les accidents](04-AgregatsSpatiaux_files/figure-html/fig-GraphiqueAccidentsDist4-1.png){#fig-GraphiqueAccidentsDist4 fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\nAppliquons la méthode DBSCAN avec un minimum de quatre points et les quatre valeurs de distance euclidienne.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123456789)\n## DBSCAN avec les quatre distances\ndbscan250  <- dbscan(xy, eps = 250, minPts = 4)\ndbscan500  <- dbscan(xy, eps = 500, minPts = 4)\ndbscan1000 <- dbscan(xy, eps = 1000, minPts = 4)\ndbscan1500 <- dbscan(xy, eps = 1500, minPts = 4)\n## Affichage des résultats\ndbscan250\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDBSCAN clustering for 1106 objects.\nParameters: eps = 250, minPts = 4\nUsing euclidean distances and borderpoints = TRUE\nThe clustering contains 45 cluster(s) and 353 noise points.\n\n  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 \n353   4   6   7   5  15   5   4  22   7   5   5  19 295   4  18   5   4   7   8 \n 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39 \n  4   6  49   4  11   4   4  41   5   4   8  31  25  10   6  23   4   5  18  15 \n 40  41  42  43  44  45 \n  6   4   6   4   7   4 \n\nAvailable fields: cluster, eps, minPts, metric, borderPoints\n```\n\n\n:::\n\n```{.r .cell-code}\ndbscan500\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDBSCAN clustering for 1106 objects.\nParameters: eps = 500, minPts = 4\nUsing euclidean distances and borderpoints = TRUE\nThe clustering contains 33 cluster(s) and 143 noise points.\n\n  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 \n143   7   6  14   4   5   5   4   6 734  18   8   6   6   5   9  16   9   5   4 \n 20  21  22  23  24  25  26  27  28  29  30  31  32  33 \n 23   5   3   4   6   5   4   9   6   9   4   4   4   6 \n\nAvailable fields: cluster, eps, minPts, metric, borderPoints\n```\n\n\n:::\n\n```{.r .cell-code}\ndbscan1000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDBSCAN clustering for 1106 objects.\nParameters: eps = 1000, minPts = 4\nUsing euclidean distances and borderpoints = TRUE\nThe clustering contains 10 cluster(s) and 42 noise points.\n\n  0   1   2   3   4   5   6   7   8   9  10 \n 42   8   6  37 962   8   4   6   5  12  16 \n\nAvailable fields: cluster, eps, minPts, metric, borderPoints\n```\n\n\n:::\n\n```{.r .cell-code}\ndbscan1500\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDBSCAN clustering for 1106 objects.\nParameters: eps = 1500, minPts = 4\nUsing euclidean distances and borderpoints = TRUE\nThe clustering contains 3 cluster(s) and 7 noise points.\n\n   0    1    2    3 \n   7 1047   12   40 \n\nAvailable fields: cluster, eps, minPts, metric, borderPoints\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPour les 1106 accidents du jeu de données, les résultats des quatre DBSCAN ci-dessus sont les suivants :\n\n-   Avec $\\epsilon = 250$, 45 agrégats et 353 points aberrants (bruit).\n-   Avec $\\epsilon = 500$, 33 agrégats et 143 points aberrants.\n-   Avec $\\epsilon = 1000$, 10 agrégats et 42 points aberrants.\n-   Avec $\\epsilon = 1500$, 3 agrégats et 7 points aberrants.\n\nPour les *n* points du jeu de données, l'appartenance à un agrégat est enregistrée dans un vecteur numérique avec des valeurs de 0 à *k* agrégats (`ResultatDbscan$cluster`). Notez que la valeur de 0 est attribuée aux points aberrants. Avec ce vecteur, nous enregistrons les résultats dans un nouveau champ de la couche de points `sf`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Enregistrement des résultats de DBSCAN dans la couche de points sf\nAccidents.sf$Dbscan250  <- as.character(dbscan250$cluster)\nAccidents.sf$Dbscan500  <- as.character(dbscan500$cluster)\nAccidents.sf$Dbscan1000 <- as.character(dbscan1000$cluster)\nAccidents.sf$Dbscan1500 <- as.character(dbscan1500$cluster)\n\nAccidents.sf$Dbscan250 <- ifelse(nchar(Accidents.sf$Dbscan250) == 1,\n                                        paste0(\"0\", Accidents.sf$Dbscan250),\n                                        Accidents.sf$Dbscan250)\nAccidents.sf$Dbscan500 <- ifelse(nchar(Accidents.sf$Dbscan500) == 1,\n                                        paste0(\"0\", Accidents.sf$Dbscan500),\n                                        Accidents.sf$Dbscan500)\nAccidents.sf$Dbscan1000 <- ifelse(nchar(Accidents.sf$Dbscan1000) == 1,\n                                        paste0(\"0\", Accidents.sf$Dbscan1000),\n                                        Accidents.sf$Dbscan1000)\nAccidents.sf$Dbscan1500 <- ifelse(nchar(Accidents.sf$Dbscan1500) == 1,\n                                        paste0(\"0\", Accidents.sf$Dbscan1500),\n                                        Accidents.sf$Dbscan1500)\n```\n:::\n\n\n\n\n\n\nNous cartographions finalement les résultats pour les quatre solutions.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(Accidents.sf)+tm_dots(col=\"Dbscan250\", title = \"DBSCAN 250\", size = .5)\n```\n\n::: {.cell-output-display}\n![](04-AgregatsSpatiaux_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntm_shape(Accidents.sf)+tm_dots(col=\"Dbscan500\", title = \"DBSCAN 500\", size = .5)\n```\n\n::: {.cell-output-display}\n![](04-AgregatsSpatiaux_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n\n```{.r .cell-code}\ntm_shape(Accidents.sf)+tm_dots(col=\"Dbscan1000\", title = \"DBSCAN 1000\", size = .5)\n```\n\n::: {.cell-output-display}\n![](04-AgregatsSpatiaux_files/figure-html/unnamed-chunk-9-3.png){width=672}\n:::\n\n```{.r .cell-code}\ntm_shape(Accidents.sf)+tm_dots(col=\"Dbscan1500\", title = \"DBSCAN 1500\", size = .5)\n```\n\n::: {.cell-output-display}\n![](04-AgregatsSpatiaux_files/figure-html/unnamed-chunk-9-4.png){width=672}\n:::\n:::\n\n\n\n\n\n\n#### ST-DBSCAN {#sec-04142}\n\nPour l'algorithme ST-DBSCAN, nous utilisons une [fonction R](https://github.com/CKerouanton/ST-DBSCAN/blob/master/stdbscan.R) proposée par Colin Kerouanton.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"code_complementaire/stdbscan.R\")\n```\n:::\n\n\n\n\n\n\nCalculons ST-DBSCAN avec une distance spatiale de 1000 mètres et une distance temporelle de 21 jours. Nous obtenons 26 agrégats et 584 points identifiés comme aberrants.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Importation des accidents\nAccidents.sf <- st_read(dsn = \"data/chap04/DataAccidentsSherb.shp\", quiet=TRUE)\n## Coordonnées géographiques\nxy <- st_coordinates(Accidents.sf)\nAccidents.sf$x <- xy[,1]\nAccidents.sf$y <- xy[,2]\n## Vérifions que le champ DATEINCIDE est bien au format date\nstr(Accidents.sf$DATEINCIDE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Date[1:1106], format: \"2021-12-11\" \"2022-05-16\" \"2021-08-12\" \"2019-08-02\" \"2020-03-02\" ...\n```\n\n\n:::\n\n```{.r .cell-code}\n## Calcul de st-dbscan avec une distance de 1000 mètres et 21 jours\nResultats.stdbscan <- stdbscan(x = Accidents.sf$x,\n                              y = Accidents.sf$y,\n                              time = Accidents.sf$DATEINCIDE,\n                              eps1 = 1000,\n                              eps2 = 21,\n                              minpts = 4)\n## Enregistrement des résultats de ST-DBSCAN dans la couche de points sf\nAccidents.sf$stdbscan.1000_21 <- as.character(Resultats.stdbscan$cluster)\nAccidents.sf$stdbscan.1000_21 <- ifelse(nchar(Accidents.sf$stdbscan.1000_21) == 1,\n                                        paste0(\"0\", Accidents.sf$stdbscan.1000_21),\n                                        Accidents.sf$stdbscan.1000_21)\n## Nombre de points par agrégat\ntable(Accidents.sf$stdbscan.1000_21)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16  17  18  19 \n584   4   6   5   4   4   7   7   4 178 156  13  17   4  22  32   6   7   8   8 \n 20  21  22  23  24  25  26 \n  5   6   4   3   5   4   3 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nPour faciliter l'analyse des résultats de ST-DBSCAN, nous conseillons de :\n\n1.  Construire un tableau récapitulatif pour les agrégats avec le nombre de points, les dates de début et de fin et l'intervalle temporel.\n2.  Construire un graphique avec les agrégats (axe des *y*) et la dimension temporelle (axe des *x*).\n3.  Cartographier les résultats.\n\nLe code ci-dessous génère le tableau récapitulatif. Nous constatons ainsi que les agrégats 9 et 10 incluent respectivement 178 et 156 points avec des intervalles temporels importants (respectivement 251 et 319 jours).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n## Sélection des points appartenant à un agrégat\nAgregats <- subset(Accidents.sf, \n                   Accidents.sf$stdbscan.1000_21 != \"00\")\n## Conversion de la date au format POSIXct\nAgregats$dtPOSIXct <- as.POSIXct(Agregats$DATEINCIDE, format = \"%Y/%m/%d\")\n## Tableau récapitulatif\nlibrary(\"dplyr\")  \nTableau.stdbscan <-\n    st_drop_geometry(Agregats) %>%\n      group_by(stdbscan.1000_21) %>% \n      summarize(points = n(),\n                date.min = min(DATEINCIDE),\n                date.max = max(DATEINCIDE),\n                intervalle.jours = as.numeric(max(DATEINCIDE)-min(DATEINCIDE)))\n## Affichage du tableau\nprint(Tableau.stdbscan, n = nrow(Tableau.stdbscan))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 26 × 5\n   stdbscan.1000_21 points date.min   date.max   intervalle.jours\n   <chr>             <int> <date>     <date>                <dbl>\n 1 01                    4 2019-08-08 2019-09-04               27\n 2 02                    6 2021-12-15 2022-01-25               41\n 3 03                    5 2019-07-21 2019-08-30               40\n 4 04                    4 2020-11-10 2020-12-12               32\n 5 05                    4 2022-01-08 2022-02-13               36\n 6 06                    7 2021-06-09 2021-07-02               23\n 7 07                    7 2020-06-23 2020-08-07               45\n 8 08                    4 2021-09-30 2021-10-27               27\n 9 09                  178 2019-07-02 2020-03-09              251\n10 10                  156 2021-03-13 2022-01-26              319\n11 11                   13 2021-07-24 2021-09-11               49\n12 12                   17 2021-10-21 2022-01-12               83\n13 13                    4 2021-06-16 2021-07-07               21\n14 14                   22 2022-04-11 2022-06-27               77\n15 15                   32 2020-09-11 2020-12-18               98\n16 16                    6 2020-01-17 2020-02-08               22\n17 17                    7 2022-05-07 2022-05-30               23\n18 18                    8 2021-04-01 2021-05-27               56\n19 19                    8 2020-07-15 2020-09-11               58\n20 20                    5 2019-07-05 2019-07-31               26\n21 21                    6 2022-01-15 2022-03-02               46\n22 22                    4 2020-06-17 2020-06-30               13\n23 23                    3 2022-03-12 2022-03-18                6\n24 24                    5 2021-06-29 2021-07-21               22\n25 25                    4 2021-09-20 2021-10-25               35\n26 26                    3 2021-04-13 2021-04-26               13\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLa @fig-GraphStScanEps1000Eps21 présente les points et l'étendue temporelle de chaque agrégat.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Construction du graphique\nggplot(Agregats) + \n  geom_point(aes(x = dtPOSIXct, \n                 y = stdbscan.1000_21, \n                 color = stdbscan.1000_21),\n             show.legend = FALSE) +\n  scale_x_datetime(date_labels = \"%Y/%m\")+\n  labs(x= \"Temps\",\n       y= \"Identifiant de l'agrégat\",\n       title = \"ST-DBSCAN avec Esp1 = 1000, Esp2 = 21 et MinPts = 4\")\n```\n\n::: {.cell-output-display}\n![Intervalles temporels des agrégats ST-DBSCAN](04-AgregatsSpatiaux_files/figure-html/fig-GraphStScanEps1000Eps21-1.png){#fig-GraphStScanEps1000Eps21 fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\nLa cartographie des agrégats est présentée à la @fig-CarteStScanEps1000Eps21 avec en noir les points aberrants.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Création de deux couches : l'une pour les agrégats, l'autre pour les points aberrants\nstdbcan.Agregats <- subset(Accidents.sf, Accidents.sf$stdbscan.1000_21 != \"00\")\nstdbcan.Bruit    <- subset(Accidents.sf, Accidents.sf$stdbscan.1000_21 == \"00\")\n## Cartographie\ntmap_mode(\"plot\")\ntm_shape(Arrondiss)+tm_fill(col=\"#f7f7f7\")+tm_borders(col=\"black\")+\ntm_shape(stdbcan.Bruit)+\n  tm_dots(shape = 21, col=\"black\", size=.2)+\n  tm_shape(stdbcan.Agregats)+\n  tm_dots(shape = 21, col=\"stdbscan.1000_21\", size=.2, title = \"Agrégat\")+\ntm_layout(frame = FALSE, legend.position = c(\"center\", \"bottom\"),\n          legend.text.size = .85, legend.outside = TRUE)\n```\n\n::: {.cell-output-display}\n![Agrégats identifiés avec ST-DBSCAN](04-AgregatsSpatiaux_files/figure-html/fig-CarteStScanEps1000Eps21-1.png){#fig-CarteStScanEps1000Eps21 fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\n## Méthodes de balayage de Kulldorff {#sec-042}\n\n### Objectifs de la méthode, types d'analyses, de modèles et d'agrégats {#sec-0421}\n\n### Principes de base de la méthode {#sec-0422}\n\n#### Type de balayage (cercle ou ellipse) {#sec-04221}\n\n#### Variable de contrôle {#sec-04222}\n\n### Mise en œuvre dans R {#sec-043}\n\n#### Agrégats temporels, spatiaux et spatio-temporels {#sec-0431}\n\n#### Introduction de variables de contrôle {#sec-0432}\n\n#### Exploration d'autres types de modèles {#sec-0434}\n\n## Quiz de révision du chapitre {#sec-044}\n\n\n\n\n\n\n<div id=\"Chap04\" class=\"card\">\n<link type=\"text/javascript\" src=\"libs/quizlib.1.0.1.min.js\"/>\n<script>var Quiz=function(a,b){this.Classes=Object.freeze({QUESTION:\"quizlib-question\",QUESTION_TITLE:\"quizlib-question-title\",QUESTION_ANSWERS:\"quizlib-question-answers\",QUESTION_WARNING:\"quizlib-question-warning\",CORRECT:\"quizlib-correct\",INCORRECT:\"quizlib-incorrect\",TEMP:\"quizlib-temp\"}),this.unansweredQuestionText=\"Question sans réponse !\",this.container=document.getElementById(a),this.questions=[],this.result=new QuizResult,this.answers=b;for(var c=0;c<this.container.children.length;c++)this.container.children[c].classList.contains(Quiz.Classes.QUESTION)&&this.questions.push(this.container.children[c]);if(this.answers.length!=this.questions.length)throw new Error(\"Number of answers does not match number of questions!\")};Quiz.Classes=Object.freeze({QUESTION:\"quizlib-question\",QUESTION_TITLE:\"quizlib-question-title\",QUESTION_ANSWERS:\"quizlib-question-answers\",QUESTION_WARNING:\"quizlib-question-warning\",CORRECT:\"quizlib-correct\",INCORRECT:\"quizlib-incorrect\",TEMP:\"quizlib-temp\"}),Quiz.prototype.checkAnswers=function(a){void 0===a&&(a=!0);for(var b=[],c=[],d=0;d<this.questions.length;d++){var e=this.questions[d],f=this.answers[d],g=[];this.clearHighlights(e);for(var h,i=e.getElementsByClassName(Quiz.Classes.QUESTION_ANSWERS)[0].getElementsByTagName(\"input\"),j=0;j<i.length;j++)h=i[j],\"checkbox\"===h.type||\"radio\"===h.type?h.checked&&g.push(h.value):\"\"!==h.value&&g.push(h.value);1!=g.length||Array.isArray(f)?0===g.length&&b.push(e):g=g[0],c.push(Utils.compare(g,f))}if(0===b.length||!a)return this.result.setResults(c),!0;for(d=0;d<b.length;d++){var k=document.createElement(\"span\");k.appendChild(document.createTextNode(this.unansweredQuestionText)),k.className=Quiz.Classes.QUESTION_WARNING,b[d].getElementsByClassName(Quiz.Classes.QUESTION_TITLE)[0].appendChild(k)}return!1},Quiz.prototype.clearHighlights=function(a){for(var b=a.getElementsByClassName(Quiz.Classes.QUESTION_WARNING);b.length>0;)b[0].parentNode.removeChild(b[0]);var c,d=[a.getElementsByClassName(Quiz.Classes.CORRECT),a.getElementsByClassName(this.Classes.INCORRECT)];for(i=0;i<d.length;i++)for(;d[i].length>0;)c=d[i][0],c.classList.remove(Quiz.Classes.CORRECT),c.classList.remove(Quiz.Classes.INCORRECT);for(var e=a.getElementsByClassName(Quiz.Classes.TEMP);e.length>0;)e[0].parentNode.removeChild(e[0])},Quiz.prototype.highlightResults=function(a){for(var b,c=0;c<this.questions.length;c++)b=this.questions[c],b.getElementsByClassName(Quiz.Classes.QUESTION_TITLE)[0].classList.add(this.result.results[c]?Quiz.Classes.CORRECT:Quiz.Classes.INCORRECT),void 0!==a&&a(this,b,c,this.result.results[c])};var QuizResult=function(){this.results=[],this.totalQuestions=0,this.score=0,this.scorePercent=0,this.scorePercentFormatted=0};QuizResult.prototype.setResults=function(a){this.results=a,this.totalQuestions=this.results.length,this.score=0;for(var b=0;b<this.results.length;b++)this.results[b]&&this.score++;this.scorePercent=this.score/this.totalQuestions,this.scorePercentFormatted=Math.floor(100*this.scorePercent)};var Utils=function(){};Utils.compare=function(a,b){if(a.length!=b.length)return!1;if(Array.isArray(a)&&Array.isArray(b)){for(var c=0;c<a.length;c++)if(a[c]!==b[c])return!1;return!0}return a===b};\n\nfunction showResults(quiz) {\n    // Check answers and continue if all questions have been answered\n    if (quiz.checkAnswers()) {\n        var quizScorePercent = quiz.result.scorePercentFormatted; // The unformatted percentage is a decimal in range 0 - 1\n        var quizResultElement = document.getElementById('quiz-result');\n        quizResultElement.style.display = 'block';\n        document.getElementById('quiz-percent').innerHTML = quizScorePercent.toString();\n\n        // Change background colour of results div according to score percent\n        if (quizScorePercent > 75) quizResultElement.style.backgroundColor = '#4caf50';\n        else if (quizScorePercent > 50) quizResultElement.style.backgroundColor = '#ffc107';\n        else if (quizScorePercent > 25) quizResultElement.style.backgroundColor = '#ff9800';\n        else if (quizScorePercent > 0) quizResultElement.style.backgroundColor = '#f44336';\n\n        // Highlight questions according to whether they were correctly answered. The callback allows us to highlight/show the correct answer\n        quiz.highlightResults(handleAnswers);\n    }\n}\n\n/** Callback for Quiz.highlightResults. Highlights the correct answers of incorrectly answered questions\n * Parameters are: the quiz object, the question element, question number, correctly answered flag\n */\nfunction handleAnswers(quiz, question, no, correct) {\n    if (!correct) {\n        var answers = question.getElementsByTagName('input');\n        for (var i = 0; i < answers.length; i++) {\n            if (answers[i].type === 'checkbox' || answers[i].type === 'radio'){\n                // If the current input element is part of the correct answer, highlight it\n                if (quiz.answers[no].indexOf(answers[i].value) > -1) {\n                    answers[i].parentNode.classList.add(Quiz.Classes.CORRECT);\n                }\n            } else {\n                // If the input is anything other than a checkbox or radio button, show the correct answer next to the element\n                var correctAnswer = document.createElement('span');\n                correctAnswer.classList.add(Quiz.Classes.CORRECT);\n                correctAnswer.classList.add(Quiz.Classes.TEMP); // quiz.checkAnswers will automatically remove elements with the temp class\n                correctAnswer.innerHTML = quiz.answers[no];\n                correctAnswer.style.marginLeft = '10px';\n                answers[i].parentNode.insertBefore(correctAnswer, answers[i].nextSibling);\n            }\n        }\n    }\n}\n\n  var quizz_Chap04;\n  window.onload = function() {\n    quizz_Chap04 = new Quiz('Chap04', ['2','2',['1', '3', '4'],['1', '2'],'1',['1', '2', '3']]);\n  };</script>\n<link rel=\"stylesheet\" type=\"text/css\" src=\"css/quizlib.min.css\"/>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">L'algorithme DBSCAN est basé sur :</div>\n<div>Relisez au besoin la [section @sec-04111].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>La distance entre les points</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q1\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>La densité des points</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q1\" value=\"2\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Avec l'algorithme DBSCAN, vous devez spécifier le nombre de groupes (agrégats).</div>\n<div>Relisez au besoin la [section @sec-04111].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Vrai</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q2\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Faux</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q2\" value=\"2\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Quels sont les trois types de points identifiés par DBSCAN?</div>\n<div>Relisez au besoin l'encadré à la [section @sec-04111].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Points centraux</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q3\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Points médians</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q3\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Points frontières</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q3\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Points aberrants</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q3\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Quels sont les deux paramètres de l'algorithme DBSCAN?</div>\n<div>Relisez au besoin la [section @sec-04111].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Le nombre de points minimum pour identifier les points centraux (MinPts)</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q4\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Le rayon de recherche (epsilon)</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q4\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>La distance standard (DS)</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q4\" value=\"3\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Plus la valeur d'epsilon est grande, plus le nombre d'agrégats diminue.</div>\n<div>Relisez au besoin la [section @sec-04112].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Vrai</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q5\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Faux</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q5\" value=\"2\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Quels sont les trois paramètres de l'algorithme ST-DBSCAN?</div>\n<div>Relisez au besoin la [section @sec-0412].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Le nombre de points minimum pour identifier les points centraux (MinPts)</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q6\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Le rayon de recherche pour la proximité spatiale (eps1)</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q6\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Le rayon de recherche pour la proximité temporelle (eps2)</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q6\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>La région d'étude</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q6\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<button type=\"button\" onclick=\"showResults(quizz_Chap04);\" id=\"buttonID\">Vérifiez votre résultat</button>\n<div id=\"quiz-result\" class=\"card\">\n<span id=\"quiz-percent\"></span>\n</div>\n</div>\n\n\n\n\n\n\n## Exercices de révision {#sec-045}\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 1.** Application de l'algorithme DBSCAN\n:::\n\n::: bloc_exercice-body\nL'objectif est d'appliquer cet algorithme sur des accidents impliquant des personnes à vélo sur l'île de Montréal (voir la [section @sec-04141]). Ces données ouvertes sur les collisions routières et leur documentation sont disponibles au [lien suivant](https://donnees.montreal.ca/dataset/collisions-routieres).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(tmap)\nlibrary(dbscan)\nlibrary(ggplot2)\n## Importation des données\nCollissions <- st_read(dsn = \"data/chap04/collisions.gpkg\", \n                       layer = \"CollisionsRoutieres\", \n                       quiet = TRUE)\n## Collisions impliquant au moins une personne à vélo en 2020 et 2021\nColl.Velo <- subset(Collissions,\n                    Collissions$NB_VICTIMES_VELO > 0 &\n                      Collissions$AN %in% c(2020, 2021))\n## Coordonnées géographiques\nxy <- st_coordinates(Coll.Velo)\n## Graphique pour la distance au quatrième voisin le plus proche\nDistKplusproche <- kNNdist(xy, k = 4)\nDistKplusproche <- as.data.frame(sort(DistKplusproche, decreasing = FALSE))\nnames(DistKplusproche) <- \"distance\"\nggplot(à compléter)+\n  geom_path(à compléter)+\n  labs(à compléter)+\n  geom_hline(yintercept=250, color = \"#08306b\", linetype=\"dashed\", size=1)+\n  geom_hline(yintercept=500, color = \"#00441b\", linetype=\"dashed\", size=1)+\n  geom_hline(yintercept=1000, color = \"#67000d\", linetype=\"dashed\", size=1)\n## DBSCAN avec les quatre distances\nset.seed(123456789)\ndbscan250  <- à compléter\ndbscan500  <- à compléter\ndbscan1000 <- à compléter\n## Affichage des résultats\ndbscan250\ndbscan500\ndbscan1000\n## Enregistrement dans la couche de points sf Coll.Velo\nColl.Velo$dbscan250 <- à compléter\nColl.Velo$dbscan500 <- à compléter\nColl.Velo$dbscan1000 <- à compléter\n\nColl.Velo$dbscan250 <- ifelse(nchar(Coll.Velo$dbscan250) == 1,\n                              paste0(\"0\", Coll.Velo$dbscan250),\n                              Coll.Velo$dbscan250)\nColl.Velo$dbscan500 <- ifelse(nchar(Coll.Velo$dbscan500) == 1,\n                               paste0(\"0\", Coll.Velo$dbscan500),\n                               Coll.Velo$dbscan500)\nColl.Velo$dbscan1000 <- ifelse(nchar(Coll.Velo$dbscan1000) == 1,\n                               paste0(\"0\", Coll.Velo$dbscan1000),\n                               Coll.Velo$dbscan1000)\n# Extraction des agrégats\nAgregats.dbscan250  <- subset(Coll.Velo, dbscan250 != \"00\")\nAgregats.dbscan500  <- subset(Coll.Velo, dbscan500 != \"00\")\nAgregats.dbscan1000 <- subset(Coll.Velo, dbscan1000 != \"00\")\n## Cartographie\ntmap_mode(\"plot\")\nà compléter\n```\n:::\n\n\n\n\n\n\nCorrection à la [section @sec-12041].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 2.** Application de l'algorithme ST-DBSCAN\n:::\n\n::: bloc_exercice-body\nAvec le même jeu de données, réaliser un ST-DBSCAN avec les paramètres suivants : distance spatiale de 500 mètres, distance temporelle de 30 jours et quatre points minimum (voir la [section @sec-04142]).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(tmap)\nlibrary(dbscan)\nlibrary(ggplot2)\n## Importation des données\nCollissions <- st_read(dsn = \"data/chap04/collisions.gpkg\", \n                       layer = \"CollisionsRoutieres\",\n                       quiet = TRUE)\n## Collisions impliquant au moins une personne à vélo en 2020 et 2021\nColl.Velo <- subset(Collissions,\n                    Collissions$NB_VICTIMES_VELO > 0 &\n                      Collissions$AN %in% c(2020, 2021))\n## Coordonnées géographiques\nxy <- st_coordinates(Coll.Velo)\nColl.Velo$x <- xy[,1]\nColl.Velo$y <- xy[,2]\n## Conversion du champ DT_ACCDN au format Date\nColl.Velo$DT_ACCDN <- as.Date(Coll.Velo$DT_ACCDN)\n## ST-DBSCAN avec eps1 = 500, esp2 = 30 et minpts = 4\nResultats.stdbscan <- stdbscan(À compléter)\n## Enregistrement des résultats ST-DBSCAN dans la couche de points sf\nColl.Velo$stdbscan <- as.character(Resultats.stdbscan$cluster)\nColl.Velo$stdbscan <- ifelse(nchar(Coll.Velo$stdbscan) == 1,\n                             paste0(\"0\", Coll.Velo$stdbscan),\n                             Coll.Velo$stdbscan)\n## Nombre de points par agrégat avec la fonction table\ntable(Coll.Velo$stdbscan)\n## Sélection des points appartenant à un agrégat avec la fonction subset\nAgregats <- subset(Coll.Velo, stdbscan != \"00\")\n## Conversion de la date au format POSIXct\nAgregats$dtPOSIXct <- as.POSIXct(Agregats$DT_ACCDN, format = \"%Y/%m/%d\")\n## Tableau récapitulatif\nlibrary(\"dplyr\")  \nTableau.stdbscan <- À compléter\n## Affichage du tableau\nprint(Tableau.stdbscan, n = nrow(Tableau.stdbscan))\n## Construction du graphique\nÀ compléter\n## Création d'une couche pour les agrégats\nstdbcan.Agregats <- subset(Coll.Velo, stdbscan != \"00\")\n## Cartographie\nÀ compléter\n```\n:::\n\n\n\n\n\n\nCorrection à la [section @sec-12042].\n:::\n:::\n",
    "supporting": [
      "04-AgregatsSpatiaux_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}