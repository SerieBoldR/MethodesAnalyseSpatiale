{
  "hash": "9dff5b54c8387581850afbd5e206ecaf",
  "result": {
    "engine": "knitr",
    "markdown": "# Manipulation des données spatiales dans R {#sec-chap01}\n\nDans ce chapitre, nous décrivons comment importer, manipuler et cartographier des données spatiales dans R. Pour une description plus détaillée du langage de programmation R -- objets et expression, opérateurs, structures de données (vecteurs, matrices, *arrays*, *DataFrame*), importation et manipulation de données --, lisez le chapitre intitulé [*Prise en main avec R*](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html) [@RBoldAir].\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n\n::: bloc_package-body\n-   Pour importer et manipuler des fichiers géographiques :\n    -   `sf` pour importer et manipuler des données vectorielles.\n    -   `rmapshaper` pour simplifier des géométries en conservant la topologie.\n    -   `terra` pour importer et manipuler des données *raster*.\n    -   `gpx` pour importer des coordonnées GPS au format *GPS eXchange Format*.\n    -   `foot` pour créer des enveloppes orientées sur les géométries.\n    -   `concaveman` pour créer des enveloppes concaves.\n-   Pour cartographier des données :\n    -   `ggplot2` est un *package* pour construire des graphiques qui peut être aussi utilisé pour visualiser des données spatiales.\n    -   `tmap` pour construire des cartes thématiques.\n    -   `RColorBrewer` pour construire une palette de couleur.\n    -   `ggpurb` pour combiner des graphiques et des cartes.\n-   Pour importer des tables attributaires :\n    -   `foreign` pour importer des fichiers *dBase*.\n    -   `xlsx` pour importer des fichiers Excel.\n:::\n:::\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Pas de panique!**\n:::\n\n::: bloc_attention-body\nCe document comprend de nombreuses notions sur l'importation, la manipulation et la cartographie de données spatiales dans R, soit des opérations que vous avez l'habitude de réaliser dans ArcGIS Pro ou QGIS.\n\nPrenez le temps de lire ce premier chapitre à tête reposée et assurez-vous de bien comprendre chaque notion avant de passer à la suivante. L'objectif n'est pas de maîtriser parfaitement la syntaxe R pour toutes les opérations dès la première semaine!\n\nVous allez manipuler de nombreuses données spatiales avec R au fil de la lecture du livre. Par conséquent, n'hésitez pas à revenir sur ce chapitre lorsque nécessaire; considérez-le comme un aide-mémoire.\n:::\n:::\n\n## Importation de données géographiques {#sec-011}\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Quels *packages* choisir pour importer et manipuler des données spatiales?**\n:::\n\n::: bloc_notes-body\nPour les données vectorielles, il existe deux principaux *packages* (équivalent d'une librairie dans Python) : `sp` [@PackageSP1; @PackageSP2] et `sf` [@PackageSF]. Puisque le *package* `sp` est progressivement délaissé par R, il est donc fortement conseillé d'utiliser `sf`.\n\nPour les données *raster*, il est possible d'utiliser les *packages* `raster` [@PackageRaster] et `terra` [@PackageTerra], dont le dernier, plus récent, semblerait plus rapide.\n\nCette transition de `sp` à `sf` et de `raster` à `terra` est assez récente et encore en cours durant l'écriture de ce livre. Il existe encore de nombreux *packages* basés sur `sp` et `raster`. Il est donc possible que vous ayez à les utiliser, car leur transition n'est peut-être pas encore effectuée. Notez que la façon dont ces anciens *packages* intègrent les données vectorielles et matricielles dans R est très différente de celle des nouveaux *packages*. À titre d'exemple, la fonction `sp::readOGR` lit un fichier *shapefile*, tout comme la fonction `sf::st_read`, mais la première produit un objet de type `SpatialDataFrame`, alors que la seconde produit un `tbl_df`. Dans le premier cas, les géométries et les données sont stockées dans deux éléments séparés, alors que dans le second cas, le `tbl_df` est un `data.frame` avec une colonne contenant les géométries.\n\nPour les personnes intéressées aux motivations ayant conduit à cette transition, consultez cet excellent [article de blog](https://r-spatial.org/r/2022/04/12/evolution.html). Il existe deux raisons principales : le mainteneur des *packages* `rgdal` et `rgeos` servant de fondation à `raster` et `sp` a pris sa retraite. À cela s'ajoutent le côté « vieille école » de ces *packages* (ayant plus de 20 ans!) et l'apparition de *packages* plus modernes. Il s'agit d'un bon exemple de ce qui peut arriver dans une communauté *open source* et des évolutions constantes de l'environnement R.\n\nEn résumé, privilégiez l'utilisation de `sf` et de `terra.`\n\nIl convient d'installer les deux *packages*. Notez que l'installation d'un *package* requiert une connexion Internet, car R accède au répertoire de *packages* *CRAN* pour télécharger le *package* et l'installer sur votre ordinateur. Cette opération est réalisée avec la fonction `install.packages(\"nom du package\").` Notez qu'une fois que le *package* est installé, il est enregistré localement sur votre ordinateur et y reste à moins de le désinstaller avec la fonction `remove.packages(\"nom du package\").`\n\nAutrement dit, il n'est pas nécessaire de les installer à chaque ouverture de R! Pour utiliser les fonctions d'un *package*, vous devez préalablement le charger avec la fonction `library(\"Nom du package\")` (équivalent à la fonction `import` de Python).\n\nPour plus d'informations sur l'installation et le chargement de *packages*, consultez la [section suivante](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html#sec-0123) [@RBoldAir].\n:::\n:::\n\n### Importation de données vectorielles {#sec-0111}\n\nLa fonction `st_read` de `sf` permet d'importer une multitude de formats de données géographiques, comme des fichiers *shapefile* (`shp`), *GeoPackage* (`GPKG`), *GeoJSON* (`geojson`), *sqlite* (`sqlite`), *geodatabase d'ESRI* (`FileGDB`), *Geoconcept* (`gxt`), *Keyhole Markup Language* (`kml`), *Geography Markup Language* (`gml`), etc.\n\n#### Importation d'un fichier *shapefile* {#sec-01111}\n\nLe code R ci-dessous permet d'importer des couches géographiques au format *shapefile*. Notez que la fonction `list.files(pattern = \".shp\")` renvoie préalablement la liste des couches *shapefile* présentes dans le dossier de travail.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Chargement des packages\nlibrary(\"sf\")\nlibrary(\"terra\")\nlibrary(\"tmap\")\nlibrary(\"ggplot2\")\nlibrary(\"ggpubr\")\nlibrary(\"foreign\")\nlibrary(\"xlsx\")\nlibrary(\"rmapshaper\")\nlibrary(\"RColorBrewer\")\n## Obtention d'une liste des shapefiles dans le dossier de travail\nlist.files(path = \"data/chap01/shp\", pattern = \".shp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"AbidjanPtsGPS.shp\"                         \n [2] \"AbidjanSegRue.shp\"                         \n [3] \"Arrondissements.shp\"                       \n [4] \"IncidentsSecuritePublique.shp\"             \n [5] \"Installations_sportives_et_recreatives.shp\"\n [6] \"Pistes_cyclables.shp\"                      \n [7] \"PolyX.shp\"                                 \n [8] \"PolyY.shp\"                                 \n [9] \"Quebec.shp\"                                \n[10] \"Segments_de_rue.shp\"                       \n```\n\n\n:::\n\n```{.r .cell-code}\n## Importation des shapefiles avec sf\nArrondissements <- st_read(\"data/chap01/shp/Arrondissements.shp\", quiet=TRUE)\nInstallationSport <- st_read(\"data/chap01/shp/Installations_sportives_et_recreatives.shp\", quiet=TRUE)\nPistesCyclables <- st_read(\"data/chap01/shp/Pistes_cyclables.shp\", quiet=TRUE)\nRues <- st_read(\"data/chap01/shp/Segments_de_rue.shp\", quiet=TRUE)\n```\n:::\n\n\n\n\n\n\nRegardons à présent la structure des couches importées. Pour ce faire, nous utilisons la fonction `head(nom du DataFrame, n=2)`; notez que le paramètre `n` permet de spécifier le nombre des premiers enregistrements à afficher. Les informations suivantes sont ainsi disponibles :\n\n-   `6 fields` : six champs attributaires (`TYPE`, `DETAIL`, `NOM`, `SURFACE`, `ECLAIRAGE`, `OBJECTID`).\n\n-   `Geometry type POINT` : le type de géométrie est **point**.\n\n-   `Bounding box:  xmin: -8009681 ymin: 5686891 xmax: -8001939 ymax: 5696536` : les quatre coordonnées définissant l'enveloppe de la couche.\n\n-   `Projected CRS: WGS 84 / Pseudo-Mercator` : la projection cartographique. Ici, une projection cartographique utilisée par Google Maps et OpenStreetMap.\n\n-   La géométrie est enregistrée dans le champ `geometry`. Pour le premier enregistrement, nous avons la valeur `POINT (-8001939 5686891)`, soit un point avec les coordonnées géographiques (x,y) entre parenthèses.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(InstallationSport, n=2)   # Visualisation des deux premiers enregistrements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -8009681 ymin: 5686891 xmax: -8001939 ymax: 5696536\nProjected CRS: WGS 84 / Pseudo-Mercator\n   TYPE DETAIL                     NOM SURFACE ECLAIRAGE OBJECTID\n1 Aréna   <NA>    Aréna Eugène-Lalonde    <NA>      <NA>        1\n2 Aréna   <NA> Aréna Philippe-Bergeron    <NA>      <NA>        2\n                  geometry\n1 POINT (-8001939 5686891)\n2 POINT (-8009681 5696536)\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(InstallationSport)       # Noms de champs (colonnes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TYPE\"      \"DETAIL\"    \"NOM\"       \"SURFACE\"   \"ECLAIRAGE\" \"OBJECTID\" \n[7] \"geometry\" \n```\n\n\n:::\n\n```{.r .cell-code}\nView(InstallationSport)        # Afficher l'ensemble de la table attributaire\n```\n:::\n\n\n\n\n\n\nExplorons les types de géométries et la projection des autres couches avec le code ci-dessous. En résumé, les types de géométries sont :\n\n-   Des géométries simples\n\n    -   `point` : un seul point.\n\n    -   `linestring` : une séquence de deux points et plus formant une ligne.\n\n    -   `polygon` : un seul polygone formé par une séquence de points pouvant contenir un ou plusieurs polygones intérieurs formant des trous.\n\n-   Des géométries multiples\n\n    -   `multipoint` : plusieurs points pour une même observation.\n\n    -   `multilinestring` : plusieurs lignes pour une même observation.\n\n    -   `multipolygon` : plusieurs polygones pour une même observation.\n\n-   Une collection de géométries (`Geometrycollection`) qui peut contenir différents types de géométries décrites ci-dessus pour une même observation.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(PistesCyclables, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 3 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: -8010969 ymin: 5666202 xmax: -7997972 ymax: 5697954\nProjected CRS: WGS 84 / Pseudo-Mercator\n                       NOM OBJECTID SHAPE__Len                       geometry\n1     Axe de la Massawippi        1   13944.09 MULTILINESTRING ((-8010969 ...\n2 Axe de la Saint-François        2   19394.28 MULTILINESTRING ((-8001909 ...\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(Rues, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 16 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: -8013896 ymin: 5681299 xmax: -8008810 ymax: 5695980\nProjected CRS: WGS 84 / Pseudo-Mercator\n  ID         TOPONYMIE NOROUTE NUMEROCIVI NUMEROCI_1 NUMEROCI_2 NUMEROCI_3\n1  1 Rue Oliva-Turgeon      NA          0          0          0          0\n2  9      Rue Melville      NA          0          0          0          0\n     NOMGENERIQ TYPERUE TYPESEGMEN VITESSE         TYPESENSUN MUNICIPALI\n1 OLIVA-TURGEON     Rue     Locale      50 Pas de sens unique      43027\n2      MELVILLE     Rue     Locale      50 Pas de sens unique      43027\n  OBJECTID SHAPE__Len              CIRCULATIO                       geometry\n1        1   114.7781 Interdite en tout temps MULTILINESTRING ((-8008810 ...\n2        2   114.4441 Interdite en tout temps MULTILINESTRING ((-8013782 ...\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(Arrondissements, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -8027109 ymin: 5668860 xmax: -8000502 ymax: 5704391\nProjected CRS: WGS 84 / Pseudo-Mercator\n  NUMERO                                                         NOM\n1      1 Arrondissement de Brompton–Rock Forest–Saint-Élie–Deauville\n2      4                                  Arrondissement des Nations\n                        geometry\n1 POLYGON ((-8005013 5702777,...\n2 POLYGON ((-8005680 5690860,...\n```\n\n\n:::\n:::\n\n\n\n\n\n\nVisualisons quelques couches importées avec `ggplot()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Arrondissements et rues\nggplot()+ geom_sf(data = Arrondissements, lwd = .8)+\n  geom_sf(data = Rues, aes(colour = TYPESEGMEN))\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n## Arrondissements, pistes cyclables et installations sportives\nggplot()+ geom_sf(data = Arrondissements, lwd = .8)+\n  geom_sf(data = PistesCyclables, aes(colour = NOM), lwd = .5)+\n  geom_sf(data = InstallationSport)\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-4-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n#### Importation d'une couche dans un *GeoPackage* {#sec-01112}\n\nPour importer une couche stockée dans un *GeoPackage* (GPKG), vous devez spécifier le fichier et la couche avec respectivement les paramètres `dsn` et `layer` de la fonction `st_read`. Le code ci-dessous permet d'importer les secteurs de recensement de la région métropolitaine de recensement de Sherbrooke pour l'année 2021. Notez que la fonction `st_layers(dsn)` permet d'obtenir la liste des couches contenues dans le fichier GPKG, avec le type de géométrie, les nombre d'entités spatiales et de champs, et la projection cartographique pour chacune d'elles.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Nom du fichier GPKG\nfichierGPKG <- \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\"\n## Liste des couches dans le GPKG\nst_layers(dsn=fichierGPKG, do_count = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDriver: GPKG \nAvailable layers:\n           layer_name geometry_type features fields\n1            SherbRMR Multi Polygon        1     12\n2            SherbSDR Multi Polygon       11     12\n3             SherbSR Multi Polygon       50     10\n4             SherbAD Multi Polygon      333     10\n5             SherbIL Multi Polygon     2734     12\n6        RegionEstrie Multi Polygon        1      5\n7          sdr_Estrie Multi Polygon       89      6\n8        DREstrie2021 Multi Polygon        7      6\n9 DivisionsRecens2021 Multi Polygon       98      6\n                           crs_name\n1 NAD83 / Statistics Canada Lambert\n2 NAD83 / Statistics Canada Lambert\n3 NAD83 / Statistics Canada Lambert\n4 NAD83 / Statistics Canada Lambert\n5 NAD83 / Statistics Canada Lambert\n6 NAD83 / Statistics Canada Lambert\n7 NAD83 / Statistics Canada Lambert\n8 NAD83 / Statistics Canada Lambert\n9 NAD83 / Statistics Canada Lambert\n```\n\n\n:::\n\n```{.r .cell-code}\n## Importation d'une couche\nSR.RMRSherb <- st_read(dsn = fichierGPKG, \n                       layer = \"SherbSR\", quiet=TRUE)\n## Affichage des deux premiers enregistrements\nhead(SR.RMRSherb, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 7762066 ymin: 1271201 xmax: 7765357 ymax: 1274082\nProjected CRS: NAD83 / Statistics Canada Lambert\n                IDUGD      SRIDU   SRNOM SUPTERRE PRIDU SRpop_2021 SRtlog_2021\n1 2021S05074330001.00 4330001.00 0001.00   3.1882    24       5637        2918\n2 2021S05074330002.00 4330002.00 0002.00   0.8727    24       1868        1169\n  SRrhlog_2021 RMRcode   HabKm2                           geom\n1         2756     433 1768.082 MULTIPOLYGON (((7764998 127...\n2         1063     433 2140.484 MULTIPOLYGON (((7763361 127...\n```\n\n\n:::\n\n```{.r .cell-code}\n## Visualisation rapide des secteurs avec ggplot\nggplot()+ geom_sf(data = SR.RMRSherb, lwd = .5)\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-5-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n#### Importation d'une couche dans une *geodatabase* d'ESRI {#sec-01113}\n\nLa logique est la même qu'avec un *GeoPackage*, nous spécifions le chemin de la *geodatabase* et la couche avec les paramètres `dsn` et `layer`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAffectDuTerritoire <- st_read(dsn = \"data/chap01/geodatabase/Sherbrooke.gdb\", \n                              layer = \"AffectationsDuTerritoire\", quiet=TRUE)\n## Visualisation des affectations du sol avec ggplot\nggplot()+ geom_sf(data = AffectDuTerritoire, aes(fill = TYPE), lwd = .2)\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n#### Importation de données GPS {#sec-01114}\n\nEn géomatique appliquée, il est fréquent de collecter des données sur le terrain avec un appareil GPS. Les données ainsi collectées peuvent être enregistrées dans différents formats de données dépendamment de l'appareil GPS utilisé : *GPS eXchange Format* (GPX), *Garmin's Flexible and Interoperable Data Transfer* (FIT), *Training Center XML* (TCX), etc.\n\n##### Importation de coordonnées GPS longitude/latitude au format *csv* {#sec-011142}\n\nUne personne ayant collecté des données sur le terrain pourrait aussi vous les transmettre dans un fichier *csv* (fichier texte délimité par des virgules). Il convient d'importer le fichier de coordonnées GPS dans R dans un *DataFrame* (avec la fonction `read.csv`). Une fois importé, nous constatons qu'il comprend trois champs :\n\n-   `id` : un champ identifiant avec des valeurs uniques.\n\n-   `lon` : longitude.\n\n-   `lat` : latitude.\n\nLes points sont projetés en longitude/latitude (WGS84 long/lat, EPSG : 4326).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Importation du fichier csv\nPointsGPS <- read.csv(\"data/chap01/gps/pointsGPS.csv\")\nhead(PointsGPS)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id       lon      lat\n1  1 -71.99985 45.36010\n2  2 -71.99096 45.37535\n3  3 -71.98444 45.46964\n4  4 -72.09873 45.37126\n5  5 -72.04880 45.41035\n6  6 -71.95000 45.32570\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPour convertir le *DataFrame* en un objet `sf`, nous utilisons la fonction `st_as_sf` en spécifiant les champs pour les coordonnées et la projection cartographique.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Importation du fichier csv\nPointsGPS <- st_as_sf(PointsGPS, coords = c(\"lon\",\"lat\"), crs = 4326)\n```\n:::\n\n\n\n\n\n\nLes points ainsi créés sont localisés dans la ville de Sherbrooke.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Affichage des points avec le package tmap\nlibrary(\"tmap\")\ntmap_mode(\"view\") ## Mode actif de tmap\ntm_shape(PointsGPS)+\n  tm_dots(size = 0.05, shape = 21, col = \"red\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/Chap01/gps.jpg){width=5.03in}\n:::\n:::\n\n\n\n\n\n\n\n\n##### Importation de coordonnées GPS au format *GPX* {#sec-011141}\n\nLe format [GPX](https://fr.wikipedia.org/wiki/GPX_(format_de_fichier)) est certainement le format de stockage et d'échange de coordonnées GPS le plus utilisé. Les informations géographiques (x,y) et temporelles (date et heure) sont respectivement enregistrées en degrés longitude/latitude (projection WSG) (WGS84, EPSG : 4326) et en temps universel coordonné (UTC, format ISO 8601).\n\nPour importer un fichier GPX, nous utilisons le *package* `gpx`. S'il n'est pas installé sur votre ordinateur, lancez la commande `install.packages(\"gpx\")` dans la console de R; n'oubliez pas de le charger avec `library(\"gpx\")`! Ensuite, importez le fichier GPX avec la fonction `read_gpx`, enregistrez la trace GPS dans un *DataFrame* et convertissez-la en objet `sf`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"gpx\")\n## Importation du fichier GPX\nTraceGPS <- read_gpx(\"data/chap01/gps/TraceGPS.gpx\")\n## Cette trace GPS comprend trois listes : routes, tracks et waypoints\n## Les points sont stockés dans tracks\nnames(TraceGPS)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"routes\"    \"tracks\"    \"waypoints\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## Pour visualiser les données, il suffit de lancer la ligne\n## ci-dessous (mise en commentaire car le résultat est un peu long...)\n# head(TraceGPS)\nTraceGPS <- TraceGPS$tracks$`ID1_PA_2021-12-03_TRAJET01.gpx`\n## Conversion du DataFrame en objet sf\nTraceGPS <- st_as_sf(TraceGPS, coords = c(\"Longitude\",\"Latitude\"), crs = 4326)\n## Visualisation des premiers enregistrements\nhead(TraceGPS, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 4 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -4.022827 ymin: 5.327383 xmax: -4.022825 ymax: 5.327387\nGeodetic CRS:  WGS 84\n  Elevation                Time extensions Segment ID\n1      40.8 2021-12-03 08:38:49         NA          1\n2      40.6 2021-12-03 08:38:50         NA          1\n                    geometry\n1 POINT (-4.022827 5.327387)\n2 POINT (-4.022825 5.327383)\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLa trace GPS correspond à un trajet réalisé à vélo à Abidjan (Côte d'Ivoire) le 3 décembre 2021. Cette trace a été obtenue avec une montre Garmin et comprend un point chaque seconde.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"view\")\ntm_basemap(leaflet::providers$OpenStreetMap)+\ntm_shape(TraceGPS)+\n  tm_dots(size = 0.001, shape = 21, col = \"red\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/Chap01/gps_abidjan.jpg){width=5.04in}\n:::\n:::\n\n\n\n\n\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**La structure de la classe `sf`**\n:::\n\n::: bloc_aller_loin-body\nLa classe `sf` est composée de trois éléments (@fig-ClasseSf) :\n\n-   L'objet **`simple feature geometry (sfg)`** est la géométrie d'une observation. Tel que vu plus haut, elle est une géométrie simple (`point`, `linestring`, `polygon`), multiple (`multipoint`, `multilinestring`, `multipolygon`) ou une collection de géométries différentes (`Geometrycollection`). Pour définir chacune de ces géométries, nous utilisons les méthodes `st_point()`, `st_linestring()`, `st_polygon()`, `st_multipoint()`, `st_multilinestring()`, `st_multipolygon()` et `Geometrycollection()`.\n\n-   L'objet **`simple feature column (sfc)`** est simplement une liste de `simple feature geometry (sfg)`. Elle représente la colonne `geometry` d'une couche vectorielle `sf`.\n\n-   L'objet **`data.frame`** correspond à la table attributaire.\n\nUne **`simple feature`** correspond ainsi à une observation (ligne) d'un objet `sf`, soit une entité spatiale comprenant l'information sémantique (attributs) et l'information spatiale (géométrie).\n\n![Structure de la classe `sf`](images/Chap01/ClassSFFinal.png){#fig-ClasseSf width=\"90%\" fig-align=\"center\"}\n\nVoyons un exemple concret : créons une couche `sf` comprenant les trois entités spatiales décrites dans la @fig-ClasseSf.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Création des géométries : simple feature geometry (sfg)\npoint1 = st_point(c(-8001939, 5686891))\npoint2 = st_point(c(-8009681, 5696536))\npoint3 = st_point(c(-7998695, 5689743))\n## Création d'une liste de géométries : simple feature geometry (sfc)\n## avec la projection cartographique EPSG 3857\npoints_sfc = st_sfc(point1, point2, point3, crs = 3857)\n## Création de la table attributaire : objet data.frame\ntable_attr = data.frame(TYPE = c(\"Aréna\", \"Aréna\",\"Aréna\"),\n                       NOM = c(\"Aréna Eugène-Lalonde\", \n                               \"Aréna Philippe-Bergeron\",\n                               \"Centre Julien-Ducharme\"),\n                       OBJECTID = c(1, 2, 3))\n## Création de l'objet sf\nArena_sf = st_sf(table_attr, geometry = points_sfc)\n## Le résultat est bien identique à celui de la figure ci-dessus\nhead(Arena_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 3 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -8009681 ymin: 5686891 xmax: -7998695 ymax: 5696536\nProjected CRS: WGS 84 / Pseudo-Mercator\n   TYPE                     NOM OBJECTID                 geometry\n1 Aréna    Aréna Eugène-Lalonde        1 POINT (-8001939 5686891)\n2 Aréna Aréna Philippe-Bergeron        2 POINT (-8009681 5696536)\n3 Aréna  Centre Julien-Ducharme        3 POINT (-7998695 5689743)\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n:::\n\n### Importation de données *raster* {#sec-0112}\n\nLa fonction `terra::rast` permet d'importer des images de différents formats (GeoTiff, ESRI, ENVI, ERDAS, BIN, GRID, etc.). Nous importons ci-dessous cinq feuillets de [modèles numériques d'altitude (MNA) à l'échelle du 1/20000](https://www.donneesquebec.ca/recherche/dataset/modeles-numeriques-d-altitude-a-l-echelle-de-1-20-000) couvrant la ville de Sherbrooke. La @fig-MNA présente l'un d'entre eux.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Liste des fichiers GeoTIFF dans le dossier\nlist.files(path=\"data/chap01/raster\", pattern = \".tif\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"f21e05_101.tif\"         \"f21e05_101.tif.aux.xml\" \"f21e05_201.tif\"        \n [4] \"f21e05_201.tif.aux.xml\" \"f21e12_101.tif\"         \"f21e12_101.tif.aux.xml\"\n [7] \"f31h08_102.tif\"         \"f31h08_102.tif.aux.xml\" \"f31h08_202.tif\"        \n[10] \"f31h08_202.tif.aux.xml\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## Importation des fichiers\nf21e05_101 <- terra::rast(\"data/chap01/raster/f21e05_101.tif\")\nf21e05_201 <- terra::rast(\"data/chap01/raster/f21e05_201.tif\")\nf31h08_102 <- terra::rast(\"data/chap01/raster/f31h08_102.tif\")\nf31h08_202 <- terra::rast(\"data/chap01/raster/f31h08_202.tif\")\nf21e12_101 <- terra::rast(\"data/chap01/raster/f21e12_101.tif\")\n## Visualisation des informations sur l'image f21e05_101\nf21e05_101\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 1409, 2798, 1  (nrow, ncol, nlyr)\nresolution  : 9e-05, 9e-05  (x, y)\nextent      : -72.00095, -71.74913, 45.24907, 45.37588  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat NAD83 (EPSG:4269) \nsource      : f21e05_101.tif \nname        : f21e05_101 \nmin value   :   143.4273 \nmax value   :   423.5806 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualisation de l'image\nterra::plot(f21e05_101, \n     main=\"Modèle numérique d'altitude à l’échelle de 1/20 000 (f21e05_101)\")\n```\n\n::: {.cell-output-display}\n![Modèle numérique d'élévation au 1/20000 (feuillet f21e05_101)](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-MNA-1.pdf){#fig-MNA fig-align='center' fig-pos='H' width=65%}\n:::\n:::\n\n\n\n\n\n\n## Manipulation de données vectorielles {#sec-012}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n***Package*** `sf` **et opérations géométriques**\n:::\n\n::: bloc_objectif-body\nLe *package* `sf` est une librairie extrêmement complète permettant de réaliser une multitude d'opérations géométriques sur des couches vectorielles comme dans un système d'information géographique (SIG). Notre objectif n'est pas de toutes les décrire, mais d'aborder les principales. Au fil de vos projets avec `sf`, vous apprendrez d'autres fonctions. Pour ce faire, n'hésitez pas à consulter :\n\n-   Une belle [*Cheatsheet*](https://github.com/rstudio/cheatsheets/blob/main/sf.pdf) sur `sf`. Allez y jeter un œil, cela vaut la peine!\n\n-   Sur le [site CRAN](https://cran.r-project.org/web/packages/sf/index.html) de `sf`, vous trouverez plusieurs vignettes explicatives (exemples de code documentés).\n\n-   La [documentation complète en PDF](https://cran.r-project.org/web/packages/sf/sf.pdf).\n\nLa syntaxe `methods(class = 'sfc')` renvoie la liste des méthodes implémentées dans le *package* `sf`. Pour accéder à l'aide en ligne de l'une d'entre elles, écrivez simplement `?Nom de la fonction` (ex. : `?st_buffer`).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class = 'sfc')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] [                            [<-                         \n [3] as.data.frame                c                           \n [5] coerce                       format                      \n [7] fortify                      identify                    \n [9] initialize                   ms_clip                     \n[11] ms_dissolve                  ms_erase                    \n[13] ms_explode                   ms_filter_islands           \n[15] ms_innerlines                ms_lines                    \n[17] ms_points                    ms_simplify                 \n[19] Ops                          points                      \n[21] print                        rep                         \n[23] scale_type                   show                        \n[25] slotsFromS3                  st_area                     \n[27] st_as_binary                 st_as_grob                  \n[29] st_as_s2                     st_as_sf                    \n[31] st_as_text                   st_bbox                     \n[33] st_boundary                  st_break_antimeridian       \n[35] st_buffer                    st_cast                     \n[37] st_centroid                  st_collection_extract       \n[39] st_concave_hull              st_convex_hull              \n[41] st_coordinates               st_crop                     \n[43] st_crs                       st_crs<-                    \n[45] st_difference                st_exterior_ring            \n[47] st_geometry                  st_inscribed_circle         \n[49] st_intersection              st_intersects               \n[51] st_is                        st_is_full                  \n[53] st_is_valid                  st_line_merge               \n[55] st_m_range                   st_make_valid               \n[57] st_minimum_rotated_rectangle st_nearest_points           \n[59] st_node                      st_normalize                \n[61] st_point_on_surface          st_polygonize               \n[63] st_precision                 st_reverse                  \n[65] st_sample                    st_segmentize               \n[67] st_set_precision             st_shift_longitude          \n[69] st_simplify                  st_snap                     \n[71] st_sym_difference            st_transform                \n[73] st_triangulate               st_triangulate_constrained  \n[75] st_union                     st_voronoi                  \n[77] st_wrap_dateline             st_write                    \n[79] st_z_range                   st_zm                       \n[81] str                          summary                     \n[83] text                         vec_cast.sfc                \n[85] vec_ptype2.sfc               vect                        \nsee '?methods' for accessing help and source code\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n:::\n\n### Fonctions relatives à la projection cartographique {#sec-0121}\n\nLes trois principales fonctions relatives à la projection cartographique des couches vectorielles sont :\n\n-   `st_crs(x)` pour connaître la projection géographique d'un objet `sf`.\n\n-   `st_transform(x, cr)` pour modifier la projection cartographique.\n\n-   `st_is_longlat(x)` pour vérifier si les coordonnées sont en degrés longitude/latitude.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Importation d'un shapefile pour la province de Québec\nProvinceQc <- st_read(\"data/chap01/shp/Quebec.shp\", quiet = TRUE)\n## La projection est EPSG:3347 - NAD83 / Statistics Canada Lambert,\n## soit la projection conique conforme de Lambert\nst_crs(ProvinceQc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: NAD83 / Statistics Canada Lambert \n  wkt:\nPROJCRS[\"NAD83 / Statistics Canada Lambert\",\n    BASEGEOGCRS[\"NAD83\",\n        DATUM[\"North American Datum 1983\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4269]],\n    CONVERSION[\"Statistics Canada Lambert\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",63.390675,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",-91.8666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",77,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",6200000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",3000000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Topographic mapping (small scale).\"],\n        AREA[\"Canada - onshore and offshore - Alberta; British Columbia; Manitoba; New Brunswick; Newfoundland and Labrador; Northwest Territories; Nova Scotia; Nunavut; Ontario; Prince Edward Island; Quebec; Saskatchewan; Yukon.\"],\n        BBOX[38.21,-141.01,86.46,-40.73]],\n    ID[\"EPSG\",3347]]\n```\n\n\n:::\n\n```{.r .cell-code}\n## Reprojection de la couche en WGS84 long/lat (EPSG:4326)\nProvinceQc.4326 <- st_transform(ProvinceQc, crs = 4326)\n## longitude/latitude?\nst_is_longlat(ProvinceQc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nst_is_longlat(ProvinceQc.4326)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLa @fig-Projections démontre bien que les deux couches sont projetées différemment.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nMap1 <- ggplot()+geom_sf(data = ProvinceQc)+coord_sf(crs = st_crs(ProvinceQc))+\n        labs(subtitle = \"Conique conforme de Lambert (EPSG : 3347)\")\n\nMap2 <- ggplot()+geom_sf(data = ProvinceQc.4326)+coord_sf(crs = st_crs(ProvinceQc.4326))+\n        labs(subtitle = \"WGS84 long/lat (EPSG : 4326)\")\n\ncomp_plot <- ggarrange(Map1, Map2, ncol = 2, nrow = 1)\nannotate_figure(comp_plot,\n                top = text_grob(\"Province de Québec\",\n                                face = \"bold\", size = 12, just = \"center\")\n                )\n```\n\n::: {.cell-output-display}\n![Deux projections cartographiques](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-Projections-1.pdf){#fig-Projections fig-align='center' fig-pos='H' width=75%}\n:::\n:::\n\n\n\n\n\n\n### Fonctions d'opérations géométriques sur une couche {#sec-0122}\n\nIl existe une quinzaine de fonctions d'opérations géométriques sur une couche dans le *package* `sf` dont le résultat renvoie de nouvelles géométries ([voir la documentation suivante](https://r-spatial.github.io/sf/reference/geos_unary.html)). Nous décrivons ici uniquement celles qui nous semblent les plus utilisées :\n\n-   `st_bbox(x)` renvoie les coordonnées minimales et maximales des géométries d'un objet `sf`. Pour créer l'enveloppe d'un objet `sf`, il suffit donc d'écrire `st_as_sfc(st_bbox(x))`.\n\n-   `st_boundary(x)` renvoie les limites (contours) des géométries d'un objet `sf`.\n\n-   `st_convex_hull(x)` crée l'enveloppe convexe des géométries d'un objet `sf`.\n\n-   `st_combine(x)` regroupe les géométries d'un objet `sf` en une seule géométrie, sans les réunir ni résoudre les limites internes.\n\n-   `st_union(x)` fusionne les géométries d'un objet `sf` en une seule géométrie.\n\n-   `st_buffer(x, dist, endCapStyle = c(\"ROUND\", \"FLAT\", \"SQUARE\"), joinStyle = c(\"ROUND\", \"MITRE\", \"BEVEL\"))` crée des zones tampons d'une distance définie avec le paramètre `dist`. Cette fonction s'applique à des points, à des lignes et à des polygones.\n\n-   `st_centroid(x)` crée des points au centre de chaque géométrie d'un objet `sf`. Elle s'applique donc à des lignes et à des polygones.\n\n-   `st_point_on_surface(x)` crée un point au centre de chaque polygone d'un objet `sf` .\n\n-   `st_simplify(x, dTolerance)` simplifie les contours de géométries (lignes ou polygones) avec une tolérance exprimée en mètres (paramètre `dTolerance`) d'un objet `sf` .\n\n-   `st_voronoi(x, bOnlyEdges = TRUE)` crée des polygones de Thiessen, appelés aussi polygones de Voronoï pour des points. Attention, le paramètre `bOnlyEdges = TRUE` renvoie des lignes tandis que `bOnlyEdges = FALSE` renvoie des polygones.\n\n#### Enveloppe et union d'une couche {#sec-01221}\n\nLe code ci-dessous crée une enveloppe (en bleu) et un polygone fusionné (en rouge) pour les arrondissements de la ville de Sherbrooke (@fig-EnveloppeUnion). La couche résultante de l'opération `st_as_sfc(st_bbox(x))` est ainsi l'équivalent des outils `Emprise` de QGIS et `Minimum Bounding Geometry (Geometry Type = Envelope)` d'ArcGIS Pro.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Enveloppe sur les arrondissements de la ville de Sherbrooke\nArrond.Enveloppe <- st_as_sfc(st_bbox(Arrondissements))\n## Fusionne les géométries en une seule en résolvant les limites internes\nArrond.Union <- st_union(Arrondissements)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(Arrond.Enveloppe) + tm_borders(col = \"blue\", lwd=2)+\n  tm_shape(Arrond.Union) + tm_borders(col = \"red\", lwd=2)+\n  tm_layout(frame = FALSE)+\n  tm_scale_bar(c(0,5,10))\n```\n\n::: {.cell-output-display}\n![Enveloppe sur une couche](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-EnveloppeUnion-1.pdf){#fig-EnveloppeUnion fig-align='center' fig-pos='H' width=65%}\n:::\n:::\n\n\n\n\n\n\n#### Enveloppe orientée {#sec-01222}\n\nLa fonction `st_bbox` de `sf` produit des rectangles englobant des géométries qui sont orientées nord-sud. Il est possible de générer des rectangles orientés autour de géométries pour minimiser leur emprise et ainsi mieux représenter l'orientation de la géométrie initiale. Il n'existe pas de fonction dans `sf` pour le faire, mais le *package* `foot` offre une implémentation facile d'utilisation. Notez que `foot` n'est pas déposé sur CRAN et doit être téléchargé depuis *Github* avec la ligne de code ci-dessous.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github(\"wpgp/foot\", build_vignettes = FALSE)\n```\n:::\n\n\n\n\n\n\nLa couche résultante de l'opération `fs_mbr(x, returnShape = TRUE)` (@fig-EnveloppeOrientee, b) est ainsi l'équivalent des outils `Emprise orientée minimale (OMBB)` de QGIS et `Minimum Bounding Geometry (Geometry Type = Rectangle by area)` d'ArcGIS Pro.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# devtools::install_github(\"wpgp/foot\", build_vignettes = TRUE) \nlibrary(foot, quietly = TRUE)\n## Rectangles (enveloppes) orientés \nrectangles_oriented <- fs_mbr(Arrondissements, returnShape = TRUE)\nrectangles_oriented <- st_as_sf(rectangles_oriented,\n                                crs = st_crs(Arrondissements))\nrectangles_oriented$NOM <- Arrondissements$NOM\n## Rectangles non orientés (nord-sud)\nst_bbox_by_feature = function(x) {\n  x = st_geometry(x)\n  f <- function(y) st_as_sfc(st_bbox(y))\n  do.call(\"c\", lapply(x, f))\n}\nrectangles <- st_as_sf(st_bbox_by_feature(Arrondissements),\n                       crs = st_crs(Arrondissements))\nrectangles$NOM <- Arrondissements$NOM\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Enveloppes classiques et orientées](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-EnveloppeOrientee-1.pdf){#fig-EnveloppeOrientee fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\n#### Centroïdes et centre de surface {#sec-01223}\n\nLe code ci-dessous extrait les centres géométriques, c'est-à-dire les centroïdes (en bleu) et les points à l'intérieur des polygones (en rouge) pour les arrondissements de la ville de Sherbrooke (@fig-CentroidesPointsInterieur). Ces deux opérations correspondent aux outils `centroïdes` et `Point dans la surface` de QGIS et `Feature to Point (avec l'option Inside)` d'ArcGIS Pro.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Centroïdes et points dans les polygones sur les arrondissements\nArrond.centroide <- st_centroid(Arrondissements)\nArrond.pointpoly <- st_point_on_surface(Arrondissements)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Centroïdes et points à l'intérieur des polygones](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CentroidesPointsInterieur-1.pdf){#fig-CentroidesPointsInterieur fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\n#### Zone tampon (*buffer*) {#sec-01224}\n\nUne simple ligne de code permet de créer des zones tampons (équivalent des outils `Analyse vectorielle/Tampon` dans QGIS et `Buffer` dans ArcGIS Pro). Une fois les zones créées, utilisez la fonction `st_union` pour fusionner les tampons en un polygone (@fig-ZoneTampon).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Zones tampons de 1000 mètres autour des installations sportives et récréatives\nInstSports.buffer <- st_buffer(InstallationSport, dist = 1000)\n## Si vous souhaitez fusionner les zones tampons, utilisez la fonction st_union\nInstSports.bufferUnion <- st_union(InstSports.buffer)\n## Zones tampons de 500 mètres autour des lignes\nPistesCyclables.buffer <- st_buffer(PistesCyclables, dist = 500)\nPistesCyclables.bufferUnion <- st_union(PistesCyclables.buffer)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Zones tampons](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-ZoneTampon-1.pdf){#fig-ZoneTampon fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\nNotez que pour des polygones, il est possible de créer des polygones intérieurs comme suit : `st_buffer(x, dist = - Valeur)`. Par exemple, le code ci-dessous crée des polygones de 200 mètres autour et à l'intérieur du parc du Mont-Bellevue de la ville de Sherbrooke (@fig-ZoneTampon2).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Importation de la couche des aires aménagées de la ville de Sherbrooke\nAiresAmenag <- st_read(dsn = \"data/chap01/geodatabase/Sherbrooke.gdb\",\n                       layer = \"AiresAmenagees\", quiet = TRUE)\n## Sélection du parc du Mont-Bellevue\nMontBellevue <- subset(AiresAmenag, NOM == \"Parc du Mont-Bellevue\")\n## Création d'une zone tampon autour du parc\nMontBellevue.ZTA500 <- st_buffer(MontBellevue, dist = 200)\n## Création d'une zone tampon à l'intérieur du parc\nMontBellevue.ZTI500 <- st_buffer(MontBellevue, dist = -200)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Zone tampon intérieure et zone tampon extérieure](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-ZoneTampon2-1.pdf){#fig-ZoneTampon2 fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\n#### Simplification de géométries {#sec-01225}\n\nLa simplification ou généralisation d'une couche de lignes ou de polygones permet de supprimer des sommets tout en gardant le même nombre de géométries dans la couche résultante. Cette opération peut être réalisée dans QGIS avec l'outil `simplifier` et dans ArcGIS Pro avec l'outil `Generalize`. Deux raisons principales peuvent motiver le recours à cette opération :\n\n-   La réduction de la taille du fichier, surtout si la couche est utilisée pour de la cartographie interactive sur Internet avec des formats vectoriels comme le SVG (*Scalable Vector Graphics*), le KML ou le GeoJSON.\n\n-   L'utilisation de la couche à une plus petite échelle cartographique nécessitant la suppression de détails.\n\nLe code suivant permet de simplifier les contours des arrondissements de la ville de Sherbrooke avec des tolérances de 250, 500, 1000 et 2000 mètres. Plus la valeur de la tolérance est élevée, plus les contours sont simplifiés (@fig-Simplification). Notez que l'algorithme de Douglas-Peucker [@douglas1973algorithms] a été implémenté dans la fonction `st_simplify`. Bien qu'intéressant, cet algorithme ne conserve pas les frontières entre les polygones.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Simplification des contours avec différentes distances de tolérance\nArrond.simplify250m <- st_simplify(Arrondissements, \n                                   preserveTopology = TRUE, \n                                   dTolerance = 250)\nArrond.simplify500m <- st_simplify(Arrondissements, \n                                   preserveTopology = TRUE, \n                                   dTolerance = 500)\nArrond.simplify1000m <- st_simplify(Arrondissements, \n                                    preserveTopology = TRUE, \n                                    dTolerance = 1000)\nArrond.simplify2000m <- st_simplify(Arrondissements, \n                                    preserveTopology = TRUE, \n                                    dTolerance = 2000)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Simplification des contours de géométries](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-Simplification-1.pdf){#fig-Simplification fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\nPour remédier au problème des frontières non conservées, utilisez l'algorithme de Visvalingam et Whyatt [-@visvalingam1993line] avec la fonction `ms_simplify` du *package* `rmapshaper` (@fig-SimplificationVisvalingam), tel qu'illustré dans le code ci-dessous. À titre de rappel, pour l'installer et le charger sur votre ordinateur, tapez dans la console : `install.packages(\"rmapshaper\")` et `library(\"rmapshaper\")`. Le paramètre `keep` permet de définir la proportion de points à retenir : plus sa valeur est faible, plus la simplification est importante.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Simplification des contours avec l'algorithme de Visvalingam–Whyatt](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-SimplificationVisvalingam-1.pdf){#fig-SimplificationVisvalingam fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\n#### Enveloppe convexe (*convex hull*) {#sec-01226}\n\nLe code ci-dessous permet de créer l'enveloppe convexe pour des points (@fig-ConvexHull). Notez que cette fonction peut également s'appliquer à des lignes et à des polygones. Elle correspond aux outils `Enveloppe convexe` de QGIS et `Feature to Point (avec l'option Convex hull)` d'ArcGIS Pro.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Enveloppe convexe autour des points GPS\nPointsGPS.Convexhull <- st_convex_hull(st_union(PointsGPS))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Enveloppe convexe autour de points](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-ConvexHull-1.pdf){#fig-ConvexHull fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\n#### Enveloppe concave (*concave hull*) {#sec-01227}\n\nUne extension possible du polygone convexe est le polygone concave qui a une superficie plus réduite. Il n'existe pas de fonction dans `sf` qui l'implémente. Il faut donc installer un *package* supplémentaire, soit `concaveman`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(concaveman)\n## Convex hull autour des points GPS\nPointsGPS.Concavhull <- concaveman(PointsGPS)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Enveloppe concave autour de points](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-ConcaveHull-1.pdf){#fig-ConcaveHull fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n\n\nNotez que comparativement au polygone convexe (@fig-ConcaveHull), le polygone concave peut auvoir plus d'une solution possible ([lire l'article suivant](https://portailsig.org/content/sur-la-creation-des-enveloppes-concaves-concave-hull-et-les-divers-moyens-d-y-parvenir-forme.html)). Plus spécifiquement, il faut choisir son degré de concavité. Dans la fonction `concaveman::concaveman`, le paramètre `concavity` prend une valeur numérique, qui, si elle tend vers l'infini, produit un polygone convexe (@fig-ConcaveHull2).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggpubr)\n# test avec plusieurs valeur de concavité\nconcav_values <- c(1,1.5,3,8)\nplots <- lapply(concav_values, function(i){\n  Concavhull <- concaveman(PointsGPS, concavity = i)\n  this_plot <- ggplot()+\n    geom_sf(data = Concavhull)+\n    geom_sf(data = PointsGPS)+\n    labs(subtitle = paste0(\"Concavité : \",i))+\n      theme(axis.text.x = element_blank(),\n            axis.text.y = element_blank(),\n            axis.ticks = element_blank())\n  return(this_plot)\n})\nggarrange(plotlist = plots)\n```\n\n::: {.cell-output-display}\n![Enveloppe concave autour de points](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-ConcaveHull2-1.pdf){#fig-ConcaveHull2 fig-align='center' fig-pos='H' width=80%}\n:::\n:::\n\n\n\n\n\n\nDans QGIS, il existe plusieurs *plugins* permettant de générer des enveloppes concaves, ainsi qu'une fonction installée de base avec GRASS (`v.concave.hull`).\n\n### Fonctions d'opérations géométriques entre deux couches {#sec-01213}\n\nLes opérations entre deux couches sont bien connues et largement utilisées dans les SIG. Bien entendu, plusieurs fonctions de ce type sont disponibles dans `sf` et renvoient une nouvelle couche géographique `sf` :\n\n-   `st_intersection(x, y)` génère l'intersection entre les géométries de deux couches. À ne pas confondre avec la fonction `st_intersects(x, y)` qui permet de construire une requête spatiale.\n\n-   `st_union(x, y)` génère l'union entre les géométries de deux couches.\n\n-   `st_difference(x, y)` crée une géométrie à partir de `x` qui n'est pas en intersection avec `y.`\n\n-   `st_sym_difference(x, y)` crée une géométrie représentant les portions des géométries `x` et `y` qui ne s'intersectent pas.\n\n-   `st_crop(x, y, xmin, ymin, xmax, ymax)` extrait les géométries de `x` comprises dans un rectangle.\n\nEn guise de comparaison, toutes ces fonctions sont disponibles dans la boîte à outils de traitement de QGIS (dans le groupe `recouvrement de vecteur`) et les outils de la catégorie `Overlay du Geoprocessing` d'ArcGIS Pro. Le code ci-dessous illustre comment réaliser des intersections et des unions entre deux couches polygonales.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Importation des deux couches\npolysX <- st_read(\"data/chap01/shp/PolyX.shp\", quiet = TRUE)\npolysY <- st_read(\"data/chap01/shp/PolyY.shp\", quiet = TRUE)\n## Intersection des deux couches\n## Les géométries récupèrent les attributs des deux couches\nInter.XY <- st_intersection(polysX, polysY)\nhead(Inter.XY)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -8006904 ymin: 5684822 xmax: -8006602 ymax: 5685184\nProjected CRS: WGS 84 / Pseudo-Mercator\n  X_id Y_id                       geometry\n1  X.a  Y.d POLYGON ((-8006753 5684838,...\n2  Y.b  Y.d POLYGON ((-8006788 5684908,...\n```\n\n\n:::\n\n```{.r .cell-code}\n## Intersection entre deux couches préalablement fusionnées : \n## Le résutat est une seule géométrie\nInter.XYUnion <- st_intersection(st_union(polysX), st_union(polysY))\n## Union des deux couches\nUnion.XY <- st_union(st_union(polysX), st_union(polysY))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-39-1.pdf)\n:::\n:::\n\n\n\n\n\n\nLa fonction `st_intersection` peut aussi être utilisée comme la méthode `clip` dans un SIG (ArcGIS Pro ou QGIS). En guise d'exemple, dans le code ci-dessous, nous extrayons les points GPS localisés sur le territoire de la ville de Sherbrooke (@fig-Clip).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Nous nous assurons que les deux couches ont la même projection\nPointsGPS <- st_transform(PointsGPS, st_crs(Arrond.Union))\n# Extraction des points\nPointsGPS.Sherb <- st_intersection(PointsGPS, Arrond.Union)\n# Visualisation avant et après\nCarte1 <- ggplot()+geom_sf(data = Arrond.Union)+geom_sf(data = PointsGPS)+\n          labs(subtitle = \"Avant l'intersection\")+\n          theme(axis.text.x = element_blank(),\n                axis.text.y = element_blank(),\n                axis.ticks = element_blank())\nCarte2 <- ggplot()+geom_sf(data = Arrond.Union)+geom_sf(data = PointsGPS.Sherb)+\n          labs(subtitle = \"Après l'intersection\")+\n          theme(axis.text.x = element_blank(),\n                axis.text.y = element_blank(),\n                axis.ticks = element_blank())\nggarrange(Carte1, Carte2, ncol = 2, nrow = 1)\n```\n\n::: {.cell-output-display}\n![Fonction `st_intersection()` équivalente à la méthode clip dans un SIG](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-Clip-1.pdf){#fig-Clip fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\nQuelques lignes de code suffisent pour générer les différences de superposition entre les géométries de couches géographiques (@fig-Clip2).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Différences entre deux couches\nDiff.XY <- st_difference(st_union(polysX), st_union(polysY))\nDiff.YX <- st_difference(st_union(polysY), st_union(polysX))\nDiff.symXY <- st_sym_difference(st_union(polysY), st_union(polysX))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nMapInterU <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\ntm_shape(Inter.XYUnion)+tm_polygons(col = \"tomato4\", alpha = .5, \n                            border.col =\"black\", lwd = 1)\n\nMapDiffXY <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\n             tm_shape(Diff.XY)+\n             tm_polygons(col = \"red\", alpha = .5,border.col =\"black\", lwd = 1)+\n             tm_layout(main.title = \"st_difference(st_union(polysX), st_union(polysY))\", \n                       main.title.size = .8)\n\nMapDiffYX <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\n             tm_shape(Diff.YX)+\n             tm_polygons(col = \"yellow\", alpha = .5,border.col =\"black\", lwd = 1)+\n             tm_layout(main.title = \"st_difference(st_union(polysY), st_union(polysX))\", \n                       main.title.size = .8)\n\nMapSymDiffYX <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\n             tm_shape(Diff.symXY)+\n             tm_polygons(col = \"green\", alpha = .5,border.col =\"black\", lwd = 1)+\n             tm_layout(main.title = \"st_sym_difference(st_union(polysY), st_union(polysX))\",\n                       main.title.size = .8)\n\ntmap_arrange(MapZone, MapDiffXY, MapDiffYX, MapSymDiffYX, ncol=2, nrow=2)\n```\n\n::: {.cell-output-display}\n![Différences de superposition entre des géométries de différentes couches](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-Clip2-1.pdf){#fig-Clip2 fig-align='center' fig-pos='H' width=75%}\n:::\n:::\n\n\n\n\n\n\n### Fonctions de mesures géométriques et de récupération des coordonnées géographiques {#sec-0124}\n\nLes principales fonctions de mesures géométriques et de coordonnées géographiques sont :\n\n-   `st_area(x)` calcule la superficie des polygones ou des multipolygones d'une couche `sf` .\n\n-   `st_length(x)` calcule la longueur des lignes ou des polylignes d'une couche `sf` .\n\n-   `st_distance(x, y)` calcule la distance 2D entre deux objets `sf`, exprimée dans le système de coordonnées de référence.\n\n-   `st_coordinates(x)` renvoie les coordonnées géographiques de géométries.\n\nCi-dessous, nous affichons les superficies des quatre arrondissements, puis nous enregistrons les superficies en m^2^ et en km^2^ dans deux nouveaux champs dénommés `SupM2` et `SupKm2.`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Superficie des polygones des arrondissements\nst_area(Arrondissements)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnits: [m^2]\n[1] 477791738 119343215  58289370  87034244\n```\n\n\n:::\n\n```{.r .cell-code}\n## Ajout de champs de superficie dans la table attributaire\nArrondissements$SupM2 <- as.numeric(st_area(st_transform(Arrondissements, crs = 2949)))\nArrondissements$SupKm2 <- as.numeric(st_area(st_transform(Arrondissements, crs = 2949)))/1000000\nhead(Arrondissements, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -8027109 ymin: 5668860 xmax: -8000502 ymax: 5704391\nProjected CRS: WGS 84 / Pseudo-Mercator\n  NUMERO                                                         NOM\n1      1 Arrondissement de Brompton–Rock Forest–Saint-Élie–Deauville\n2      4                                  Arrondissement des Nations\n                        geometry     SupM2    SupKm2\n1 POLYGON ((-8005013 5702777,... 235580454 235.58045\n2 POLYGON ((-8005680 5690860,...  58861606  58.86161\n```\n\n\n:::\n:::\n\n\n\n\n\n\nDe manière très semblable, calculons la longueur de géométries étant des lignes ou des multilignes.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Longueurs en mètres\nPistesCyclables$longMetre <- as.numeric(st_length(st_transform(PistesCyclables, crs = 2949)))\nPistesCyclables$longKm <- as.numeric(st_length(st_transform(PistesCyclables, crs = 2949)))/10000\nhead(PistesCyclables, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 5 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: -8010969 ymin: 5666202 xmax: -7997972 ymax: 5697954\nProjected CRS: WGS 84 / Pseudo-Mercator\n                       NOM OBJECTID SHAPE__Len                       geometry\n1     Axe de la Massawippi        1   13944.09 MULTILINESTRING ((-8010969 ...\n2 Axe de la Saint-François        2   19394.28 MULTILINESTRING ((-8001909 ...\n  longMetre    longKm\n1  9807.769 0.9807769\n2 13602.324 1.3602324\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPour calculer la longueur d'un périmètre, il faut préalablement récupérer son contour avec la méthode `st_boundary`, puis calculer la longueur avec `st_length`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Conversion des polygones en lignes\nArrond.Contour <- st_boundary(Arrondissements)\n## Calcul de la longueur et enregistrement dans deux nouveaux champs\nArrondissements$PerimetreMetre <- as.numeric(st_length(Arrond.Contour))\nArrondissements$PerimetreKm <- as.numeric(st_length(Arrond.Contour)) / 1000\nhead(Arrondissements)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 4 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -8027109 ymin: 5668860 xmax: -7993013 ymax: 5704391\nProjected CRS: WGS 84 / Pseudo-Mercator\n  NUMERO                                                         NOM\n1      1 Arrondissement de Brompton–Rock Forest–Saint-Élie–Deauville\n2      4                                  Arrondissement des Nations\n3      3                               Arrondissement de Lennoxville\n4      2                                Arrondissement de Fleurimont\n                        geometry     SupM2    SupKm2 PerimetreMetre PerimetreKm\n1 POLYGON ((-8005013 5702777,... 235580454 235.58045      143771.63   143.77163\n2 POLYGON ((-8005680 5690860,...  58861606  58.86161       50476.65    50.47665\n3 POLYGON ((-7993443 5684778,...  28776861  28.77686       43531.03    43.53103\n4 POLYGON ((-7999483 5693167,...  42882506  42.88251       44172.25    44.17225\n```\n\n\n:::\n:::\n\n\n\n\n\n\nCalculons désormais la distance 2D (euclidienne) entre les centres des arrondissements. Nous utilisons donc la fonction `st_distance(x)`, puisque nous avons une seule couche (`x = Arrond.pointpoly`).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Longueurs en mètres\nst_distance(Arrond.pointpoly)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnits: [m]\n         1         2         3         4\n1     0.00 10458.989 21787.479 18047.846\n2 10458.99     0.000 11555.203  8627.962\n3 21787.48 11555.203     0.000  9622.735\n4 18047.85  8627.962  9622.735     0.000\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAdmettons que nous souhaitons calculer la distance entre les centres des quatre arrondissements et l'hôtel de ville de Sherbrooke dont les coordonnées en degrés (WGS84, EPSG : 4326) sont les suivantes : -71.89306, 45.40417. Nous utilisons alors la fonction `st_distance(x, y)` dans laquelle les paramètres `x` et `y` sont les arrondissements et l'hôtel de ville. Quelques lignes de code suffisent à créer une couche pour l'hôtel de ville, à calculer les distances et à les stocker dans un nouveau champ attributaire de la couche arrondissement.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Création d'un objet sf pour l'hôtel de ville\nHotelVille <- data.frame(ID = 1,\n                         Nom = \"Hôtel de ville\",\n                         lon = -71.89306,\n                         lat = 45.40417)\nHotelVille <- st_as_sf(HotelVille, coords = c(\"lon\",\"lat\"), crs = 4326)\nhead(HotelVille)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1 feature and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -71.89306 ymin: 45.40417 xmax: -71.89306 ymax: 45.40417\nGeodetic CRS:  WGS 84\n  ID            Nom                   geometry\n1  1 Hôtel de ville POINT (-71.89306 45.40417)\n```\n\n\n:::\n\n```{.r .cell-code}\n## Nous nous assurons que les deux couches ont la même projection\nHotelVille <- st_transform(HotelVille, st_crs(Arrond.pointpoly))\n## Calcul des distances\nArrondissements$DistHVMetre <- as.numeric(st_distance(Arrond.pointpoly,HotelVille))\nArrondissements$DistHVKm <- as.numeric(st_distance(Arrond.pointpoly,\n                                                   HotelVille)) / 1000\nhead(Arrondissements)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 4 features and 8 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -8027109 ymin: 5668860 xmax: -7993013 ymax: 5704391\nProjected CRS: WGS 84 / Pseudo-Mercator\n  NUMERO                                                         NOM\n1      1 Arrondissement de Brompton–Rock Forest–Saint-Élie–Deauville\n2      4                                  Arrondissement des Nations\n3      3                               Arrondissement de Lennoxville\n4      2                                Arrondissement de Fleurimont\n                        geometry     SupM2    SupKm2 PerimetreMetre PerimetreKm\n1 POLYGON ((-8005013 5702777,... 235580454 235.58045      143771.63   143.77163\n2 POLYGON ((-8005680 5690860,...  58861606  58.86161       50476.65    50.47665\n3 POLYGON ((-7993443 5684778,...  28776861  28.77686       43531.03    43.53103\n4 POLYGON ((-7999483 5693167,...  42882506  42.88251       44172.25    44.17225\n  DistHVMetre  DistHVKm\n1   14661.518 14.661518\n2    4662.164  4.662164\n3    9058.677  9.058677\n4    4050.374  4.050374\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIl est fréquent de vouloir enregistrer les coordonnées géographiques dans des champs attributaires. Dans le code ci-dessous, nous créons deux champs (`x` et `y`) dans lesquels nous enregistrons les coordonnées géographiques des points au centre de la surface de chaque arrondissement. Pour ce faire, nous utilisons la méthode `st_coordinates` .\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Coordonnées des centres de la surface des polygones\nxy <- st_coordinates(st_point_on_surface(Arrondissements))\nhead(xy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            X       Y\n[1,] -8017707 5686628\n[2,] -8007570 5684053\n[3,] -7997637 5678149\n[4,] -7999683 5687552\n```\n\n\n:::\n\n```{.r .cell-code}\n## Enregistrement dans la couche Arrondissements. Notez que :\n## xy[,1] signale de récupérer toutes les valeurs de la première colonne, soit X\n## xy[,2] signale de récupérer toutes les valeurs de la deuxième colonne, soit Y\nArrondissements$X <- xy[,1] \nArrondissements$Y <- xy[,2]\n```\n:::\n\n\n\n\n\n\n### Jointures spatiales {#sec-0125}\n\nEn géomatique, il est fréquent de réaliser des jointures spatiales, soit une opération qui consiste à joindre les attributs d'une couche géographique à une autre à partir d'une relation spatiale. Prenons deux exemples construits avec les installations sportives et récréatives (couche `InstallationSport`) et les arrondissements de la ville de Sherbrooke (`Arrondissements`).\n\nPremièrement, pour les installations sportives et récréatives (couche `InstallationSport`), nous souhaitons ajouter dans la table attributaire les champs `NUMERO` et `NOM` issus de la couche des arrondissements de la ville de Sherbrooke (`Arrondissements`). Grâce à ces deux champs, nous pouvons connaître dans quel arrondissement chaque installation sportive est située.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Jointure spatiale avec le paramètre st_intersects\nInstallS.join <- st_join(InstallationSport, Arrondissements, join = st_intersects)\n## Visualisation des deux premiers enregistrements\nhead(InstallS.join, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 16 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -8009681 ymin: 5686891 xmax: -8001939 ymax: 5696536\nProjected CRS: WGS 84 / Pseudo-Mercator\n   TYPE DETAIL                   NOM.x SURFACE ECLAIRAGE OBJECTID NUMERO\n1 Aréna   <NA>    Aréna Eugène-Lalonde    <NA>      <NA>        1      2\n2 Aréna   <NA> Aréna Philippe-Bergeron    <NA>      <NA>        2      1\n                                                        NOM.y     SupM2\n1                                Arrondissement de Fleurimont  42882506\n2 Arrondissement de Brompton–Rock Forest–Saint-Élie–Deauville 235580454\n     SupKm2 PerimetreMetre PerimetreKm DistHVMetre  DistHVKm        X       Y\n1  42.88251       44172.25    44.17225    4050.374  4.050374 -7999683 5687552\n2 235.58045      143771.63   143.77163   14661.518 14.661518 -8017707 5686628\n                  geometry\n1 POINT (-8001939 5686891)\n2 POINT (-8009681 5696536)\n```\n\n\n:::\n\n```{.r .cell-code}\n## Suppression des champs utiles\nInstallS.join[c(\"SupM2\", \"SupKm2\", \"PerimetreMetre\", \n                       \"PerimetreKm\", \"DistHVMetre\",  \"DistHVKm\")] <- list(NULL)\n## Modification des noms de champs : NOM.x et NOM.y\nnames(InstallS.join)[names(InstallS.join) == \"NOM.x\"] <- \"NomInstallation\"\nnames(InstallS.join)[names(InstallS.join) == \"NOM.y\"] <- \"NomArrondissement\"\nhead(InstallS.join, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 2 features and 10 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -8009681 ymin: 5686891 xmax: -8001939 ymax: 5696536\nProjected CRS: WGS 84 / Pseudo-Mercator\n   TYPE DETAIL         NomInstallation SURFACE ECLAIRAGE OBJECTID NUMERO\n1 Aréna   <NA>    Aréna Eugène-Lalonde    <NA>      <NA>        1      2\n2 Aréna   <NA> Aréna Philippe-Bergeron    <NA>      <NA>        2      1\n                                            NomArrondissement        X       Y\n1                                Arrondissement de Fleurimont -7999683 5687552\n2 Arrondissement de Brompton–Rock Forest–Saint-Élie–Deauville -8017707 5686628\n                  geometry\n1 POINT (-8001939 5686891)\n2 POINT (-8009681 5696536)\n```\n\n\n:::\n:::\n\n\n\n\n\n\nDeuxièmement, une autre jointure classique consiste à dénombrer les points compris dans des polygones, soit une opération SIG communément appelée *POINT-IN-POLYGON*.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Sélection des points dans les polygones des arrondissements\n## Notez que la relation spatiale pour la jointure est st_contains\n## Nous aurions pu aussi utiliser st_intersects\nArrondissements$NbInstall = lengths(st_contains(Arrondissements, InstallationSport))\nhead(Arrondissements$NbInstall)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 125 166  29 116\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Autres relations spatiales à appliquer lors de la jointure spatiale**\n:::\n\n::: bloc_aller_loin-body\nAvec le paramètre `join` de la méthode `st_join`, il est possible de spécifier la jointure spatiale avec différentes méthodes : `st_contains_properly`, `st_contains`, `st_covered_by`, `st_covers`, `st_crosses`, `st_disjoint`, `st_equals_exact`, `st_equals`, `st_is_within_distance`, `st_nearest_feature`,`st_overlaps`, `st_touches` et `st_within`.\n\nN'hésitez pas à consulter la documentation de la fonction en tapant`?st_join` dans la console R.\n:::\n:::\n\n### Requêtes spatiales {#sec-0126}\n\nDans un logiciel SIG, la sélection d'entités spatiales par localisation est une opération courante, équivalente à *Select By Location* dans ArcGis Pro ou *Sélection par localisation* dans QGIS.\n\nLe *package* `sf` permet de réaliser des requêtes spatiales avec notamment les méthodes suivantes :\n\n-   `st_contains(x, y)` renvoie les géométries de `x` qui contiennent celles de `y`. Cette fonction est donc l'inverse de `st_within`.\n\n-   `st_disjoint(x, y)` renvoie les géométries de `x` qui ne partagent aucune portion de celles de `y`. Cette fonction est donc l'inverse de `st_intersects(x, y)`.\n\n-   `st_equals(x, y)` renvoie les géométries de `x` qui sont identiques à celles de `y`.\n\n-   `st_intersects(x, y)` renvoie les géométries de `x` qui partagent au moins une partie de celles de `y`. Elle est donc l'inverse de `st_disjoints(x, y)`.\n\n-   `st_nearest_feature(x, y)` renvoie, pour chaque géométrie `x`, la géométrie de `y` qui est la plus proche.\n\n-   `st_overlaps(x, y)` cette fonction est très semblable à `st_intersects(x, y)`. Toutefois, les types de géométries de `x` et de `y` doivent être identiques, c'est-à-dire deux couches de lignes ou de couches de polygones. Aussi, une géométrie ne peut pas contenir complètement l'autre comme avec `st_within(x, y)` et `st_contains(x, y)`.\n\n-   `st_touches(x, y)` renvoie les géométries de `x` qui sont tangentes à celles de `x` sans qu'elles se chevauchent. Par exemple, deux arrondissements peuvent se toucher, c'est-à-dire qu'ils partagent une frontière commune sans que l'un chevauche l'autre.\n\n-   `st_within(x, y)` renvoie les géométries de `x` qui sont comprises intégralement dans celles de `y`. Cette fonction est donc l'inverse de `st_contains(x, y)`.\n\n-   `st_within_distance(x, y, dist =)` renvoie les géométries de `x` qui sont situées à une certaine distance euclidienne de celles de `y`.\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Modification de l'affichage du résultat de la requête spatiale : le paramètre** `sparse`\n:::\n\n::: bloc_astuce-body\nPar défaut, le résultat d'une requête spatiale renvoie une liste d'indices pour les géométries `x` et `y`. Il est aussi possible de renvoyer la matrice complète entre `x` et `y`, avec les valeurs `TRUE` quand la relation spatiale est vérifiée et `FALSE` pour une situation inverse.\n\nPrenons deux exemples pour illustrer le tout.\n\nLa figure ci-dessous représente les quatre arrondissements de la ville de Sherbrooke. Notez que les numéros correspondent aux indices des géométries.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  NUMERO                                                         NOM\n1      1 Arrondissement de Brompton–Rock Forest–Saint-Élie–Deauville\n2      4                                  Arrondissement des Nations\n3      3                               Arrondissement de Lennoxville\n4      2                                Arrondissement de Fleurimont\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-51-1.pdf){width=50%}\n:::\n:::\n\n\n\n\n\n\nAppliquons une requête spatiale entre les arrondissements avec `st_intersects` et `sparse = TRUE`. Pour chaque arrondissement, nous obtenons une liste des arrondissements qui l'intersectent.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_intersects(Arrondissements, Arrondissements, sparse = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSparse geometry binary predicate list of length 4, where the predicate\nwas `intersects'\n 1: 1, 2, 4\n 2: 1, 2, 3, 4\n 3: 2, 3, 4\n 4: 1, 2, 3, 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAvec `sparse = FALSE`, nous obtenons une matrice complète de dimension 4 X 4 arrondissements. Nous constatons que l'arrondissement `1` intersecte lui-même (évidemment!) et les arrondissements `2` et `4`, mais il n'intersecte pas le `3`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_intersects(Arrondissements, Arrondissements, sparse = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2]  [,3] [,4]\n[1,]  TRUE TRUE FALSE TRUE\n[2,]  TRUE TRUE  TRUE TRUE\n[3,] FALSE TRUE  TRUE TRUE\n[4,]  TRUE TRUE  TRUE TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n:::\n\nConstruisons des requêtes plus complexes comprenant deux couches.\n\nPremièrement, écrivons une requête spatiale pour sélectionner les segments des pistes cyclables qui intersectent le parc du Mont-Bellevue. Pour ce faire, nous utilisons la fonction `st_intersects` avec l'argument `sparse = FALSE` et enregistrons le résultat dans un nouveau champ dénommé `ParcMB.intersect` qui prendra les valeurs `TRUE` ou `FALSE`.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-54-1.pdf){width=75%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Intersection\nRequeteSpatiale <- st_intersects(PistesCyclables, MontBellevue, sparse = FALSE)\nhead(RequeteSpatiale)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1]\n[1,] FALSE\n[2,] FALSE\n[3,] FALSE\n[4,] FALSE\n[5,] FALSE\n[6,] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n## Création d'un nouveau champ\nPistesCyclables$ParcMB.intersect <- RequeteSpatiale[, 1]\nhead(PistesCyclables)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 6 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: -8010969 ymin: 5666202 xmax: -7997216 ymax: 5697954\nProjected CRS: WGS 84 / Pseudo-Mercator\n                       NOM OBJECTID  SHAPE__Len                       geometry\n1     Axe de la Massawippi        1 13944.08678 MULTILINESTRING ((-8010969 ...\n2 Axe de la Saint-François        2 19394.27693 MULTILINESTRING ((-8001909 ...\n3   Axe du Ruisseau-Dorman        3 16337.23985 MULTILINESTRING ((-7999121 ...\n4        Réseau utilitaire        4   467.23254 MULTILINESTRING ((-8000179 ...\n5        Réseau utilitaire        5    15.57987 MULTILINESTRING ((-8004036 ...\n6        Réseau utilitaire        6   823.83428 MULTILINESTRING ((-8003649 ...\n    longMetre      longKm ParcMB.intersect\n1  9807.76890 0.980776890            FALSE\n2 13602.32404 1.360232404            FALSE\n3 11469.13476 1.146913476            FALSE\n4   327.46928 0.032746928            FALSE\n5    10.95083 0.001095083            FALSE\n6   578.59143 0.057859143            FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n## Nous constatons qu'un seul segment intersecte le parc\ntable(PistesCyclables$ParcMB.intersect)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n  272     1 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Création d'une nouvelle couche pour la sélection\nPistesCyclables.Selection <- PistesCyclables[PistesCyclables$ParcMB.intersect== TRUE, ]\n## Visualisation\ntm_shape(MontBellevue) + tm_fill(col=\"lightgreen\")+ tm_borders(col = \"black\", lwd=2)+\ntm_shape(PistesCyclables.Selection)+tm_lines(col=\"red\", lwd=1)\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-55-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nCréons une deuxième requête spatiale pour sélectionner les points GPS situés à moins de cinq kilomètres de l'hôtel de ville de Sherbrooke avec la méthode `st_is_within_distance`.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"view\")\ntm_shape(PointsGPS) + tm_dots(col=\"green\", size = .05) +\ntm_shape(HotelVille)+tm_dots(col=\"black\", size = .25)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/Chap01/points5kmhoteldeville.jpg){width=5.04in}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Requête spatiale\nRequeteSpatiale <- st_is_within_distance(PointsGPS, HotelVille, \n                                         5000, sparse = FALSE)\n## Ajout d'un champ pour la requête\nPointsGPS$HotelVille2km <- RequeteSpatiale[, 1]\n## Nous constatons que 17 points GPS sont à moins de 5 km\ntable(PointsGPS$HotelVille2km)\n## Création d'une nouvelle couche pour la sélection\nPointsGPS.selection <- PointsGPS[PointsGPS$HotelVille2km == TRUE, ]\n## Visualisation\ntm_shape(PointsGPS.selection) + tm_dots(col=\"red\", size = .05)+\ntm_shape(HotelVille)+tm_dots(col=\"black\", size = .25)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/Chap01/points5kmhoteldeville_b.jpg){width=6.72in}\n:::\n:::\n\n\n\n\n\n\n\n\nFinalement, avec la méthode `st_within`, nous constatons que seuls deux points GPS sont situés dans le parc du Mont-Bellevue.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Requête spatiale\nRequeteSpatiale <- st_within(st_transform(PointsGPS, st_crs(MontBellevue)),\n                             MontBellevue, sparse = FALSE)\ntable(RequeteSpatiale[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n   87     2 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Manipulation des données attributaires {#sec-0127}\n\nDans cette section, nous verrons comment importer une table attributaire, puis la joindre à une couche géographique, ajouter et calculer de nouveaux champs et réaliser des requêtes attributaires.\n\n#### Importation d'une table attributaire {#sec-01271}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Joindre les attributs d'une table externe à une couche vectorielle `sf`**\n:::\n\n::: bloc_objectif-body\nDans un SIG, joindre une table à une couche géographique vectorielle est une opération courante. Par exemple, il est fréquent de joindre des données socioéconomiques issues d'un recensement à une couche géographique (divisions de recensement, subdivisions de recensement, secteurs de recensement, aires de diffusion, etc.).\n\nPour ce faire, vous devez importer les données dans un *DataFrame* de R. Ces données peuvent être stockées dans différents formats de fichiers (texte délimité par des virgules (extension *csv*), *dBase* (*dbf*), Excel (*xlsx*)) ou dans des fichiers provenant de logiciels statistiques commerciaux comme Stata, SAS et SPSS (*dta*, *sas7bdat*, *sav*).\n\nDans cette section, nous voyons seulement l'importation de fichiers texte délimités par des virgules, de fichiers Excel et *dBase*. Concernant ce dernier type de fichier, notez que la table attributaire d'une couche Esri Shapefile est stockée dans un fichier *dBase*! Il peut être intéressant d'importer la table sans les géométries.\n\nPour une description détaillée de l'importation d'autres fichiers (entre autres Stata, SAS et SPSS), consultez la section intitulée [*Manipulation d'un DataFrame*](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html#sec-0142) [@RBoldAir].\n:::\n:::\n\nDans le code ci-dessous, nous voyons comment importer trois types de fichiers :\n\n-   `read.csv(file)` pour importer un fichier délimité par des virgules. Cette fonction est de base avec R, ce qui signifie qu'elle ne nécessite pas l'installation d'un *package*.\n\n-   `read.dbf(file)` pour importer un fichier *dBase*. Cette fonction est rattachée au *package* `foreign` que vous devez installer si ce n'est pas déjà fait (commande `install.packages(\"foreign\")`) et le charger (commande `library(\"foreign\")`).\n\n-   `read.xlsx(file)` pour importer un fichier Excel. Cette fonction est rattachée au *package* `xlsx` que vous devez installer si ce n'est pas déjà fait (commande `install.packages(\"xlsx\")`) et le charger (commande `library(\"xlsx\")`).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"xlsx\")      # package pour importer des fichiers Excel\nlibrary(\"foreign\")   # package pour importer des fichiers dBase\n## Importation du fichier csv\nt1 <- Sys.time()\ndfCSV <- read.csv(file = \"data/chap01/tables/SRQC2021.csv\",\n                    header = TRUE,\n                    dec = \".\",    # séparateur de décimales qui peut être remplacé par ,\n                    sep = \",\"     # séparateur des champs qui peut être remplacé par ;\n                    )\nt2 <- Sys.time()\ncat(\"temps de traitement (CSV) : \", \n    as.numeric(difftime(t2,t1,units=\"secs\")),\n    \" secondes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntemps de traitement (CSV) :  0.0197618  secondes\n```\n\n\n:::\n\n```{.r .cell-code}\n## Importation d'un fichier Excel avec le nom de fichier et de la feuille Excel\n## sheetIndex = 1 signale l'importation de la première feuille Excel\nt1 <- Sys.time()\ndfExcel <- read.xlsx(file = \"data/chap01/tables/ADSRQC2021.xlsx\",\n                      sheetIndex = 2)\nt2 <- Sys.time()\ncat(\"temps de traitement (Excel) : \", \n    as.numeric(difftime(t2,t1,units=\"secs\")),\n    \" secondes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntemps de traitement (Excel) :  9.996  secondes\n```\n\n\n:::\n\n```{.r .cell-code}\n## Importation du fichier dBase\nt1 <- Sys.time()\ndfDbf <- read.dbf(file = \"data/chap01/tables/ADQC2021.dbf\")\nt2 <- Sys.time()\ncat(\"temps de traitement (dBase) : \", \n    as.numeric(difftime(t2,t1,units=\"secs\")),\n    \" secondes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntemps de traitement (dBase) :  0.159807  secondes\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Exportation du fichier Excel dans un fichier texte**\n:::\n\n::: bloc_astuce-body\nLe temps nécessaire pour importer un fichier Excel est bien plus long que pour des fichiers texte et *dBase*! Par conséquent, si vous travaillez avec Excel, il est vivement conseillé de l'exporter vers un fichier texte (dans Excel, `Fichier/Enregistrer sous/type de fichier CSV`).\n:::\n:::\n\nQuelques lignes suffisent pour explorer la structure des données importées avec les fonctions `nrow`, `ncol`, `colnames` (respectivement le nombre de lignes, le nombre de colonnes et les noms des colonnes du `dataframe`).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Nombre de lignes et de colonnes\nnrow(dfCSV)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2245\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(dfCSV)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 40\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"le DataFrame dfCSV a\", nrow(dfCSV), \"lignes (observations)\",\n    'et', ncol(dfCSV), \"colonnes\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nle DataFrame dfCSV a 2245 lignes (observations) et 40 colonnes\n```\n\n\n:::\n\n```{.r .cell-code}\n## Noms des champs\ncolnames(dfCSV)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"SRIDU\"                     \"PopTotAge\"                \n [3] \"Pop0_14\"                   \"Pop15_64\"                 \n [5] \"Pop65plus\"                 \"TotalLog\"                 \n [7] \"MaisonIndiv\"               \"MaisonJumulee\"            \n [9] \"MaisonRangee\"              \"AppartDuplex\"             \n[11] \"AppartMoins5E\"             \"Appart5EtPlus\"            \n[13] \"AutreMaisonIndivAttenante\" \"LogementMobile\"           \n[15] \"TotalMenag\"                \"Menage1pers\"              \n[17] \"Menage2pers\"               \"Menage3pers\"              \n[19] \"Menage4pers\"               \"Menage5pPlus\"             \n[21] \"RevMedMenage\"              \"PopTotMFRApI\"             \n[23] \"PopTotMFR\"                 \"PopTotMFRPct\"             \n[25] \"TotalMenag2\"               \"Proprietaire\"             \n[27] \"Locataire\"                 \"TotalLog2\"                \n[29] \"Log1960ouAv\"               \"Log1961_80\"               \n[31] \"Log1981_90\"                \"Log1991_00\"               \n[33] \"Log2001_05\"                \"Log2006_10\"               \n[35] \"Log2011_15\"                \"Log2016_21\"               \n[37] \"ValeurMedLog\"              \"ValeurMoyLog\"             \n[39] \"LoyerMedian\"               \"LoyerMoyen\"               \n```\n\n\n:::\n\n```{.r .cell-code}\n## Affichage des deux premières observations\nhead(dfCSV, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                                      SRIDU PopTotAge Pop0_14\n1 4470001.01 (SR), Drummondville (RMR) (4470001.01) (00000)      5080     810\n2 4470001.02 (SR), Drummondville (RMR) (4470001.02) (00000)      3400     175\n  Pop15_64 Pop65plus TotalLog MaisonIndiv MaisonJumulee MaisonRangee\n1     3285       985     2280        1290           185          210\n2     1305      1920     1815         155            75           85\n  AppartDuplex AppartMoins5E Appart5EtPlus AutreMaisonIndivAttenante\n1           70           415             0                        15\n2           15          1485             0                         5\n  LogementMobile TotalMenag Menage1pers Menage2pers Menage3pers Menage4pers\n1            100       2285         705         895         325         225\n2              0       1810         985         670         100          45\n  Menage5pPlus RevMedMenage PopTotMFRApI PopTotMFR PopTotMFRPct TotalMenag2\n1          130        69000         5085       520         10.2        2295\n2           15        47600         2885       545         18.9        1820\n  Proprietaire Locataire TotalLog2 Log1960ouAv Log1961_80 Log1981_90 Log1991_00\n1         1445       850      2295         115        590        535        485\n2          485      1335      1820          50        310        375        405\n  Log2001_05 Log2006_10 Log2011_15 Log2016_21 ValeurMedLog ValeurMoyLog\n1        155         70         75        265       250000       250200\n2        215        200        120        140       250000       305000\n  LoyerMedian LoyerMoyen\n1         695        742\n2         740        737\n```\n\n\n:::\n:::\n\n\n\n\n\n\n#### Jointure attributaire avec la couche géographique `sf` {#sec-01272}\n\nLes données importées dans la table attributive proviennent du recensement de Statistique Canada de 2021 et sont ancrées au niveau des secteurs de recensement (SR) des régions métropolitaines de recensement (RMR) et des agglomérations de recensement (AR) du Québec. Pour les SR de la RMR de Sherbrooke, les données de la couche géométrique sont importées à partir d'un fichier shapefile. Aussi, nous constatons que les deux sources de données ont un champ commun `SRIDU`, soit l'identifiant unique des SR, mais que l'information y est présentée différemment :\n\n-   Dans la couche géographique `SR.RMRSherb` (objet *sf*), nous avons une observation avec la valeur `4470001.01`, soit un champ avec dix caractères.\n\n-   Dans la table attributaire `dfCSV` (*DataFrame*), nous avons une observation avec la valeur `4470001.01 (SR), Drummondville (RMR) (4470001.01) (00000)`.\n\nPar conséquent, avant d'appliquer une jointure, nous modifions le champ `SRIDU` de ce *DataFrame* afin qu'il ait aussi dix caractères avec la ligne de code suivante : `dfCSV$SRIDU <- substr(dfCSV$SRIDU, 1, 10)`. De la sorte, nous récupérons uniquement les dix premiers caractères.\n\nFinalement, la jointure est réalisée avec la fonction `merge` avec laquelle nous spécifions le résultat de la jointure (`SR.RMRSherbDonnees`), la couche géographique (`SR.RMRSherb`), la table attributaire (`dfCSV`) et le champ commun aux deux avec l'option (`by =\"SRIDU\"`) :\n\n`SR.RMRSherbDonnees <- merge(SR.RMRSherb, dfCSV, by = \"SRIDU\").`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Importation des SR de la RMR de Sherbrooke\nSR.RMRSherb <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                       layer = \"SherbSR\", quiet=TRUE)\n## Visualisation des premiers enregistrements\nhead(as.data.frame(SR.RMRSherb), n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                IDUGD      SRIDU   SRNOM SUPTERRE PRIDU SRpop_2021 SRtlog_2021\n1 2021S05074330001.00 4330001.00 0001.00   3.1882    24       5637        2918\n2 2021S05074330002.00 4330002.00 0002.00   0.8727    24       1868        1169\n  SRrhlog_2021 RMRcode   HabKm2                           geom\n1         2756     433 1768.082 MULTIPOLYGON (((7764998 127...\n2         1063     433 2140.484 MULTIPOLYGON (((7763361 127...\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(dfCSV, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                                      SRIDU PopTotAge Pop0_14\n1 4470001.01 (SR), Drummondville (RMR) (4470001.01) (00000)      5080     810\n2 4470001.02 (SR), Drummondville (RMR) (4470001.02) (00000)      3400     175\n  Pop15_64 Pop65plus TotalLog MaisonIndiv MaisonJumulee MaisonRangee\n1     3285       985     2280        1290           185          210\n2     1305      1920     1815         155            75           85\n  AppartDuplex AppartMoins5E Appart5EtPlus AutreMaisonIndivAttenante\n1           70           415             0                        15\n2           15          1485             0                         5\n  LogementMobile TotalMenag Menage1pers Menage2pers Menage3pers Menage4pers\n1            100       2285         705         895         325         225\n2              0       1810         985         670         100          45\n  Menage5pPlus RevMedMenage PopTotMFRApI PopTotMFR PopTotMFRPct TotalMenag2\n1          130        69000         5085       520         10.2        2295\n2           15        47600         2885       545         18.9        1820\n  Proprietaire Locataire TotalLog2 Log1960ouAv Log1961_80 Log1981_90 Log1991_00\n1         1445       850      2295         115        590        535        485\n2          485      1335      1820          50        310        375        405\n  Log2001_05 Log2006_10 Log2011_15 Log2016_21 ValeurMedLog ValeurMoyLog\n1        155         70         75        265       250000       250200\n2        215        200        120        140       250000       305000\n  LoyerMedian LoyerMoyen\n1         695        742\n2         740        737\n```\n\n\n:::\n\n```{.r .cell-code}\n## Modification du champ SRIDU du DataFrame dfCSV\ndfCSV$SRIDU <- substr(dfCSV$SRIDU, 1, 10)\n## Jointure attributaire avec la fonction merge\nSR.RMRSherbDonnees <- merge(SR.RMRSherb, \n                           dfCSV, \n                           by = \"SRIDU\")\n```\n:::\n\n\n\n\n\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Jointure avec deux champs ayant des noms différents**\n:::\n\n::: bloc_astuce-body\nEn résumé, une jointure attributaire s'écrit :\n\n`NouvelObjetSf <- merge(X, Y, by = \"Nom du champ commun pour la jointure\")`\n\navec `X` et `Y` étant respectivement l'objet `sf` (couche géographique) et la table attributaire à joindre. Si les champs pour la jointure ont des noms différents, il est possible d'écrire :\n\n`NouvelObjetSf <- merge(X, Y, by.x = \"Champ X pour la jointure\", by.y = \"Champ Y pour la jointure\")`\n\nCe type de jointure conserve uniquement les observations qui sont communes à la couche géographique et à la table attributaire. Concrètement, si une couche comprend 100 entités spatiales et la table attributaire uniquement 80 observations, la couche résultante (`NouvelObjetSf`) aura uniquement 80 entités spatiales (bien entendu, quand les valeurs concordent...).\n\nLorsque vous souhaitez quand même conserver toutes les entités spatiales de la couche géographique de départ, écrivez :\n\n`NouvelObjetSf <- merge(X, Y, by = \"Nom du champ commun pour la jointure\", all.x = TRUE)`\n\nDans la nouvelle couche `Sf`, les entités spatiales de `X` qui n'ont pas été appariées avec les observations de la table attributaire `Y` auront des valeurs nulles (`NA`) pour les champs de `X` ajoutés au `NouvelObjetSf`.\n\nPour obtenir plus d'informations sur les différentes variantes d'une jointure, tapez `?merge` dans la console.\n:::\n:::\n\n#### Ajout et calcul de champs {#sec-01273}\n\nDans la [section @sec-0124], nous avons vu comment ajouter des champs relatifs à la géométrie (aire, longueur, distance, coordonnées de centroïdes). Dans un SIG, il est courant de calculer de nouveaux champs à partir de champs existants dans la table attributaire (par exemple, avec les outils *Calculatrice de champ* dans QGIS ou *Calculate Field* dans ArcGIS Pro).\n\nCe type de traitement est aussi très simple à réaliser dans R. Pour ce faire, nous utilisons des [opérateurs mathématiques, relationnels et logiques](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html#sec-0135) comme dans n'importe quel logiciel de SIG. En guise d'exemple, nous calculons ci-dessous les pourcentages d'enfants de moins de 15 ans et de locataires. Ces pourcentages sont arrondis à deux décimales avec la fonction `round`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Création et cacul de nouveau champs\nSR.RMRSherbDonnees$PctPop0_14 <- round(SR.RMRSherbDonnees$Pop0_14 / \n                                     SR.RMRSherbDonnees$PopTotAge * 100, 2)\n\nSR.RMRSherbDonnees$PctLocataire <- round(SR.RMRSherbDonnees$Locataire / \n                                     SR.RMRSherbDonnees$TotalMenag2 * 100, 2)\n```\n:::\n\n\n\n\n\n\n#### Requêtes attributaires {#sec-01274}\n\nDans un SIG, il est fréquent de réaliser une requête attributaire pour explorer les données (par exemple, avec les outils *Select By Attributes* dans ArcGIS Pro et *Sélection avec expression* dans QGIS) et exporter le résultat de la requête dans une nouvelle couche (*Export Features* dans ArcGIS Pro et *Sauvegarder les entités sélectionnées sous...*).\n\nDans le code ci-dessous, vous trouverez plusieurs exemples de requêtes attributaires. Remarquez que les résultats des requêtes sont enregistrés dans de nouveaux objets `sf` (couches géographiques) dénommés `Requete1` à `Requete5`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Sélection de l'axe cyclable de la Magog\n#############################################\n# Affichage des valeurs uniques pour le champ NOM de la couche PistesCyclables\nunique(PistesCyclables$NOM)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Axe de la Massawippi\"         \"Axe de la Saint-François\"    \n [3] \"Axe du Ruisseau-Dorman\"       \"Réseau utilitaire\"           \n [5] \"Tronçon fermé temporairement\" \"Détour\"                      \n [7] \"Axe de la Magog\"              \"Axe du Ruisseau-Kee\"         \n [9] \"Axe de la Magog Sud\"          NA                            \n[11] \"Axe du Sommet\"               \n```\n\n\n:::\n\n```{.r .cell-code}\n## Requête attributaire et enregistrement du résultat dans un nouvel objet sf\nRequete1 <- subset(PistesCyclables, NOM == \"Axe de la Magog\")\ncat(nrow(Requete1), \"enregistrements sélectionnés sur\", nrow(PistesCyclables))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n15 enregistrements sélectionnés sur 273\n```\n\n\n:::\n\n```{.r .cell-code}\n## Si vous souhaitez connaître uniquement le nombre d'enregistrements sélectionnés\n## sans créer un nouvel objet sf, il suffit d'écrire :\nnrow(subset(PistesCyclables, NOM == \"Axe de la Magog\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n\n```{.r .cell-code}\n## Sélection des SR dont la moitié ou plus des logements sont en location\n##########################################################################\n## Sommaire statistique sur le champ pourcentage de locataires\nsummary(SR.RMRSherbDonnees$PctLocataire)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   6.92   18.03   41.63   43.81   65.95   93.83 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Requête attributaire et enregistrement du résultat dans un nouvel objet sf\nRequete2 <- subset(SR.RMRSherbDonnees, PctLocataire >= 50)\ncat(nrow(Requete2), \"enregistrements sélectionnés sur\", nrow(SR.RMRSherbDonnees))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n20 enregistrements sélectionnés sur 50\n```\n\n\n:::\n\n```{.r .cell-code}\n## Sélection des installations sportives avec un éclairage dans \n## l'arrondissement des Nations (deux critères dans la requête)\n##########################################################################\nunique(InstallS.join$NomArrondissement)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Arrondissement de Fleurimont\"                               \n[2] \"Arrondissement de Brompton–Rock Forest–Saint-Élie–Deauville\"\n[3] \"Arrondissement des Nations\"                                 \n[4] \"Arrondissement de Lennoxville\"                              \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(InstallS.join$ECLAIRAGE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nNon Oui \n 46  85 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Requête attributaire avec un opérateur AND (&)\nRequete3 <- subset(InstallS.join,\n                   NomArrondissement == \"Arrondissement des Nations\" & \n                   ECLAIRAGE == \"Oui\")\ncat(nrow(Requete3), \"enregistrements sélectionnés sur\", nrow(InstallS.join))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n30 enregistrements sélectionnés sur 436\n```\n\n\n:::\n\n```{.r .cell-code}\n## Sélection des SR avec deux critères et un opérateur OR (|)\n##########################################################################\n## Sommaires statistiques sur deux champs\nsummary(SR.RMRSherbDonnees$LoyerMoyen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  570.0   679.5   729.0   768.4   847.5  1200.0 \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(SR.RMRSherbDonnees$ValeurMedLog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 200000  235500  250000  272520  300000  476000 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Requête attributaire avec un opérateur OR \nRequete4 <- subset(SR.RMRSherbDonnees,\n                   LoyerMoyen < 700 | ValeurMedLog < 250000)\ncat(nrow(Requete4), \"enregistrements sélectionnés sur\", nrow(SR.RMRSherbDonnees))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n27 enregistrements sélectionnés sur 50\n```\n\n\n:::\n\n```{.r .cell-code}\n## Sélection de différents types d'installations sportives\n##########################################################################\nunique(InstallS.join$TYPE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Aréna\"                          \"Tir à l'arc\"                   \n [3] \"Pétanque\"                       \"Jeu de galets\"                 \n [5] \"Planche à roulettes\"            \"Préau et plancher de danse\"    \n [7] \"Patinoire à bandes mobiles\"     \"Surface, anneau ou étang glacé\"\n [9] \"Patinoire à bandes fixes\"       \"Plage\"                         \n[11] \"Jeu d'eau\"                      \"Piste multifonctionnelle\"      \n[13] \"Glissade sur tube\"              \"Jeu de fers\"                   \n[15] \"Piscine\"                        \"Tennis\"                        \n[17] \"Baseball\"                       \"Basketball\"                    \n[19] \"Football\"                       \"Volleyball\"                    \n[21] \"Ultimate frisbee\"               \"Pickleball\"                    \n[23] \"Soccer\"                         \"Jeu modulaire\"                 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Requête attributaire avec un opérateur %in%\nRequete5 <- subset(InstallS.join,\n                             TYPE %in% c(\"Aréna\", \"Piscine\", \"Jeu d'eau\"))\ncat(nrow(Requete5), \"enregistrements sélectionnés sur\", nrow(InstallS.join))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n26 enregistrements sélectionnés sur 436\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Manipulation de données matricielles (*raster*) {#sec-013}\n\nEn géomatique, les données matricielles (*raster*) sont une représentation de l'information spatiale sous forme d'une grille rectangulaire composée de cellules élémentaires de taille identique appelées pixels, soit une image. Chaque pixel a une valeur pour une caractéristique spécifique, comme l'altitude, la température, l'utilisation du sol, etc. Les données matricielles sont couramment employées dans les systèmes d'information géographique (SIG) pour la cartographie, l'analyse et la prise de décision en géomatique.\n\nDans cette section, nous abordons uniquement des fonctions simples de manipulation de données matricielles, notamment le mosaïquage et découpage d'images, et les requêtes attributaires sur des images.\n\n### Mosaïquage et découpage d'images {#sec-0131}\n\nUne fois plusieurs images importées, il est fréquent de vouloir les fusionner. Pour ce faire, nous utilisons deux méthodes du *package* `terra` :\n\n-   `terra::merge` fusionne plusieurs images (objets de type `SpatRasters`) pour former un nouvel objet `SpatRasters` dont l'étendue est recalculée en fonction des images fusionnées. Par contre, quand les images se chevauchent, les valeurs des pixels dans les zones de chevauchement seront prises dans le même ordre que les images.\n\n-   `terra::mosaic` fusionne aussi plusieurs images. Toutefois, dans les zones de chevauchement, les moyennes des pixels sont calculées. Selon la documentation de `terra`, cette méthode serait plus rapide que la précédente. Dans le code ci-dessous, nous fusionnons les feuillets de modèles numériques d'altitude (MNA) importés dans la [section @sec-0112].\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Les GeoTIFF importés avec terra sont bien des SpatRaster\nclass(f21e05_101)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SpatRaster\"\nattr(,\"package\")\n[1] \"terra\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## Création d'une liste pour les cinq feuillets SpatRaster\nrlist <- list(f21e05_101, f21e05_201, f31h08_102,\n              f31h08_202, f21e12_101)\nrsrc <- sprc(rlist)\n## Création de la mosaïque\nMosaicSherb <- mosaic(rsrc)\nMosaicSherb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 4187, 5575, 1  (nrow, ncol, nlyr)\nresolution  : 9e-05, 9e-05  (x, y)\nextent      : -72.25087, -71.74913, 45.24907, 45.6259  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat NAD83 (EPSG:4269) \nsource(s)   : memory\nvarname     : f21e05_101 \nname        : f21e05_101 \nmin value   :   123.7184 \nmax value   :   845.0474 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nVous constatez ci-dessus que la projection des images est lon/lat NAD83 (EPSG:4269).\n\nD'autres fonctions permettent de découper une image en fonction d'une autre image (objet `SpatRaster` de `terra`) ou d'un objet `terra` vectoriel (`SpatVector`) :\n\n-   `crop(x, y)` découpe une image `x` en prenant l'étendue de `y`.\n\n-   `mask(x, y)` découpe une image `x` en prenant la zone (pixels avec des valeurs non nulles ou objets vectoriels) de `y`. Les pixels en dehors de cette zone auront nulle comme valeur (`NA` dans R).\n\nEn guise d'exemple, découpons la mosaïque avec le polygone de la ville de Sherbrooke en utilisant la méthode `mask`. Attention, les deux sources de données doivent avoir la même projection et il faut préalablement convertir l'objet `sf` en objet `SpatVector` de `terra`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Changement de projection pour le polygone de la ville de Sherbrooke\n## Application de la même projection que celle de la mosaïque\nVilleSherb.EPSG4269 <- st_transform(Arrond.Union, crs(MosaicSherb))\n# Convertir l'objet sf en un objet SpatVector de terra\nVilleSherb.SpatVector = vect(VilleSherb.EPSG4269)\n## Découpage de la mosaïque avec le polygone de la ville de Sherbrooke\nMosaicSherbCrop <- terra::mask(MosaicSherb, VilleSherb.SpatVector)\nMosaicSherbCrop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 4187, 5575, 1  (nrow, ncol, nlyr)\nresolution  : 9e-05, 9e-05  (x, y)\nextent      : -72.25087, -71.74913, 45.24907, 45.6259  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat NAD83 (EPSG:4269) \nsource(s)   : memory\nvarname     : f21e05_101 \nname        : f21e05_101 \nmin value   :        126 \nmax value   :        390 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Constatez ci-dessus que le nom de l'image est f21e05_101.\n## Pour le changer, utilisez la fonction names()\nnames(MosaicSherbCrop) = \"Elevation\"\nMosaicSherbCrop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 4187, 5575, 1  (nrow, ncol, nlyr)\nresolution  : 9e-05, 9e-05  (x, y)\nextent      : -72.25087, -71.74913, 45.24907, 45.6259  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat NAD83 (EPSG:4269) \nsource(s)   : memory\nvarname     : f21e05_101 \nname        : Elevation \nmin value   :       126 \nmax value   :       390 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Visualisation du résultat\nplot(MosaicSherbCrop)\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-67-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n### Requêtes attributaires sur des images {#sec-0132}\n\nAvant d'effectuer une requête, il est judicieux d'explorer les valeurs des pixels de l'image avec un histogramme et la fonction `summary(Nom de l'image)` (valeurs minimales, maximales, quartiles, moyenne et valeurs nulles -- `NA`).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Sommaire statistique des valeurs\nsummary(MosaicSherbCrop)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Elevation    \n Min.   :126.0  \n 1st Qu.:197.7  \n Median :227.6  \n Mean   :225.4  \n 3rd Qu.:251.4  \n Max.   :389.9  \n NA's   :78040  \n```\n\n\n:::\n\n```{.r .cell-code}\n## Histogramme\nhist(MosaicSherbCrop,\n     main = \"Mosaïque du MNA pour la ville de Sherbrooke\",\n     xlab = \"Élévation (mètres)\", ylab = \"Fréquence\",\n     col = \"lightgreen\")\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-68-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n## Histogramme en barre de 125 à 400 avec un saut de 25 mètres \nhist(MosaicSherbCrop,\n     main = \"Mosaïque du MNA pour la ville de Sherbrooke\",\n     xlab = \"Élévation (mètres)\", ylab = \"Fréquence\",\n     breaks = seq(from = 125, to = 400, by = 25),\n     col = \"lightgreen\")\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-68-2.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Sélection des pixels avec une élévation d'au moins 300 mètres\nMosaicSherbCrop300 = clamp(MosaicSherbCrop, lower = 300)\nplot(MosaicSherbCrop300, \n     main = \"Pixels avec une élévation d'au moins 300 mètres\")\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-69-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n## Sélection des pixels avec une élévation de 200 à 300 mètres\nMosaicSherbCrop200_300 = clamp(MosaicSherbCrop, lower = 200, upper = 300)\nplot(MosaicSherbCrop200_300,\n     main = \"Pixels avec une élévation de 200 à 300 mètres\")\n```\n\n::: {.cell-output-display}\n![](01-ManipulationDonneesSpatiales_files/figure-pdf/unnamed-chunk-69-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n## Exportation de données spatiales de R vers des formats géographiques {#sec-014}\n\n### Exportation de données vectorielles `sf` {#sec-0141}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Pourquoi exporter des objets `sf` vers différents formats géographiques?**\n:::\n\n::: bloc_objectif-body\nPlusieurs méthodes d'analyse de données spatiales ne sont pas implémentées dans les logiciels de SIG comme ArcGIS Pro ou QGIS d'où l'intérêt de recourir à R ou à Python. La démarche méthodologique classique comprend alors trois étapes :\n\n-   Importer des données géographiques.\n\n-   Réaliser des analyses avancées dans R ou Python.\n\n-   Exporter les résultats finaux vers différents formats géographiques (*shapefile*, *GeoPackage*, *geodatabase* d'ESRI, etc.).\n\nTrois raisons majeures motivent l'exportation des données :\n\n-   Cartographier les résultats finaux dans votre logiciel SIG préféré.\n\n-   Partager les données avec des personnes n'utilisant pas R.\n\n-   Réaliser éventuellement d'autres analyses dans votre logiciel de SIG préféré.\n:::\n:::\n\nDans la [section @sec-011], nous avons vu que la fonction `st_read()` du *package* `sf` permet d'importer une multitude de formats géographiques. Pour exporter avec `sf`, utilisez simplement la fonction `st_write()`. Le code ci-dessous illustre comment exporter des objets `sf` aux formats *shapefile* (`shp`), *GeoPackage* (`GPKG`), *Keyhole Markup Language* (`kml`) et *GeoJSON*. Par défaut, `st_write()` n'écrase pas un fichier existant; pour l'écraser, ajoutez le paramètre `append = FALSE`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Exportation au format shapefile\nst_write(PointsGPS, # couche sf\n         \"data/chap01/export/PointsGPS.shp\",  # chemin et nom du fichier\n         append = FALSE, # pour écraser le fichier s'il existe\n         driver = \"ESRI Shapefile\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDeleting layer `PointsGPS' using driver `ESRI Shapefile'\nWriting layer `PointsGPS' to data source \n  `data/chap01/export/PointsGPS.shp' using driver `ESRI Shapefile'\nWriting 89 features with 1 fields and geometry type Point.\n```\n\n\n:::\n\n```{.r .cell-code}\n## Exportation dans une couche dans GPKG\nst_write(PointsGPS, \n         dsn = \"data/chap01/export/Data.gpkg\", \n         layer = \"PointsGPS\",\n         append = FALSE, \n         driver = \"GPKG\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDeleting layer `PointsGPS' using driver `GPKG'\nWriting layer `PointsGPS' to data source \n  `data/chap01/export/Data.gpkg' using driver `GPKG'\nWriting 89 features with 1 fields and geometry type Point.\n```\n\n\n:::\n\n```{.r .cell-code}\n## Exportation vers un fichier KML\nst_write(PointsGPS, \n         dsn = \"data/chap01/export/PointsGPS.kml\", \n         append = FALSE,\n         driver=\"KML\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWriting layer `PointsGPS' to data source \n  `data/chap01/export/PointsGPS.kml' using driver `KML'\nWriting 89 features with 1 fields and geometry type Point.\n```\n\n\n:::\n\n```{.r .cell-code}\n## Exportation vers un fichier GeoJSON\nst_write(PointsGPS, \n         dsn = \"data/chap01/export/PointsGPS.geojson\", \n         append = FALSE,\n         driver=\"GeoJSON\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDeleting layer not supported by driver `GeoJSON'\nDeleting layer `PointsGPS' failed\nWriting layer `PointsGPS' to data source \n  `data/chap01/export/PointsGPS.geojson' using driver `GeoJSON'\nUpdating existing layer PointsGPS\nWriting 89 features with 1 fields and geometry type Point.\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLe paramètre `driver` de la fonction `st_write` permet de spécifier le format du fichier. Pour obtenir la liste des formats qu'il est possible d'importer et d'exporter, tapez dans la console `st_drivers()` ou consultez le @tbl-ListeDrivers.\n\n\n\n\n\n\n::: {#tbl-ListeDrivers .cell tbl-cap='Liste des formats avec le *package* `sf` (`st_drivers`)'}\n::: {.cell-output-display}\n\n\n|               |Nom            |                                         Description| Écriture| Si vecteur|Si raster |\n|:--------------|:--------------|---------------------------------------------------:|--------:|----------:|:---------|\n|PCIDSK         |PCIDSK         |                                PCIDSK Database File|     TRUE|       TRUE|TRUE      |\n|netCDF         |netCDF         |                          Network Common Data Format|     TRUE|       TRUE|TRUE      |\n|PDS4           |PDS4           |                        NASA Planetary Data System 4|     TRUE|       TRUE|TRUE      |\n|VICAR          |VICAR          |                                     MIPL VICAR file|     TRUE|       TRUE|TRUE      |\n|JP2OpenJPEG    |JP2OpenJPEG    |       JPEG-2000 driver based on JP2OpenJPEG library|    FALSE|       TRUE|TRUE      |\n|PDF            |PDF            |                                      Geospatial PDF|     TRUE|       TRUE|TRUE      |\n|MBTiles        |MBTiles        |                                             MBTiles|     TRUE|       TRUE|TRUE      |\n|BAG            |BAG            |                          Bathymetry Attributed Grid|     TRUE|       TRUE|TRUE      |\n|EEDA           |EEDA           |                               Earth Engine Data API|    FALSE|      FALSE|TRUE      |\n|OGCAPI         |OGCAPI         |                                              OGCAPI|    FALSE|       TRUE|TRUE      |\n|ESRI Shapefile |ESRI Shapefile |                                      ESRI Shapefile|     TRUE|      FALSE|TRUE      |\n|MapInfo File   |MapInfo File   |                                        MapInfo File|     TRUE|      FALSE|TRUE      |\n|UK .NTF        |UK .NTF        |                                             UK .NTF|    FALSE|      FALSE|TRUE      |\n|LVBAG          |LVBAG          |                         Kadaster LV BAG Extract 2.0|    FALSE|      FALSE|TRUE      |\n|OGR_SDTS       |OGR_SDTS       |                                                SDTS|    FALSE|      FALSE|TRUE      |\n|S57            |S57            |                                      IHO S-57 (ENC)|     TRUE|      FALSE|TRUE      |\n|DGN            |DGN            |                                    Microstation DGN|     TRUE|      FALSE|TRUE      |\n|OGR_VRT        |OGR_VRT        |                            VRT - Virtual Datasource|    FALSE|      FALSE|TRUE      |\n|Memory         |Memory         |                                              Memory|     TRUE|      FALSE|TRUE      |\n|CSV            |CSV            |                        Comma Separated Value (.csv)|     TRUE|      FALSE|TRUE      |\n|GML            |GML            |                     Geography Markup Language (GML)|     TRUE|      FALSE|TRUE      |\n|GPX            |GPX            |                                                 GPX|     TRUE|      FALSE|TRUE      |\n|KML            |KML            |                       Keyhole Markup Language (KML)|     TRUE|      FALSE|TRUE      |\n|GeoJSON        |GeoJSON        |                                             GeoJSON|     TRUE|      FALSE|TRUE      |\n|GeoJSONSeq     |GeoJSONSeq     |                                    GeoJSON Sequence|     TRUE|      FALSE|TRUE      |\n|ESRIJSON       |ESRIJSON       |                                            ESRIJSON|    FALSE|      FALSE|TRUE      |\n|TopoJSON       |TopoJSON       |                                            TopoJSON|    FALSE|      FALSE|TRUE      |\n|OGR_GMT        |OGR_GMT        |                            GMT ASCII Vectors (.gmt)|     TRUE|      FALSE|TRUE      |\n|GPKG           |GPKG           |                                          GeoPackage|     TRUE|       TRUE|TRUE      |\n|SQLite         |SQLite         |                                 SQLite / Spatialite|     TRUE|      FALSE|TRUE      |\n|ODBC           |ODBC           |                   Open Database Connectivity (ODBC)|    FALSE|      FALSE|TRUE      |\n|WAsP           |WAsP           |                                    WAsP .map format|     TRUE|      FALSE|TRUE      |\n|PGeo           |PGeo           |                           ESRI Personal GeoDatabase|    FALSE|      FALSE|TRUE      |\n|MSSQLSpatial   |MSSQLSpatial   |               Microsoft SQL Server Spatial Database|     TRUE|      FALSE|TRUE      |\n|PostgreSQL     |PostgreSQL     |                                  PostgreSQL/PostGIS|     TRUE|      FALSE|TRUE      |\n|MySQL          |MySQL          |                                               MySQL|     TRUE|      FALSE|TRUE      |\n|OpenFileGDB    |OpenFileGDB    |                                        ESRI FileGDB|     TRUE|       TRUE|TRUE      |\n|DXF            |DXF            |                                         AutoCAD DXF|     TRUE|      FALSE|TRUE      |\n|CAD            |CAD            |                                      AutoCAD Driver|    FALSE|       TRUE|TRUE      |\n|FlatGeobuf     |FlatGeobuf     |                                          FlatGeobuf|     TRUE|      FALSE|TRUE      |\n|Geoconcept     |Geoconcept     |                                          Geoconcept|     TRUE|      FALSE|TRUE      |\n|GeoRSS         |GeoRSS         |                                              GeoRSS|     TRUE|      FALSE|TRUE      |\n|VFK            |VFK            |                Czech Cadastral Exchange Data Format|    FALSE|      FALSE|TRUE      |\n|PGDUMP         |PGDUMP         |                                 PostgreSQL SQL dump|     TRUE|      FALSE|TRUE      |\n|OSM            |OSM            |                           OpenStreetMap XML and PBF|    FALSE|      FALSE|TRUE      |\n|GPSBabel       |GPSBabel       |                                            GPSBabel|     TRUE|      FALSE|TRUE      |\n|OGR_PDS        |OGR_PDS        |                        Planetary Data Systems TABLE|    FALSE|      FALSE|TRUE      |\n|WFS            |WFS            |                       OGC WFS (Web Feature Service)|    FALSE|      FALSE|TRUE      |\n|OAPIF          |OAPIF          |                                  OGC API - Features|    FALSE|      FALSE|TRUE      |\n|EDIGEO         |EDIGEO         |                       French EDIGEO exchange format|    FALSE|      FALSE|TRUE      |\n|SVG            |SVG            |                            Scalable Vector Graphics|    FALSE|      FALSE|TRUE      |\n|Idrisi         |Idrisi         |                                Idrisi Vector (.vct)|    FALSE|      FALSE|TRUE      |\n|XLS            |XLS            |                                     MS Excel format|    FALSE|      FALSE|TRUE      |\n|ODS            |ODS            | Open Document/ LibreOffice / OpenOffice Spreadsheet|     TRUE|      FALSE|TRUE      |\n|XLSX           |XLSX           |                      MS Office Open XML spreadsheet|     TRUE|      FALSE|TRUE      |\n|Elasticsearch  |Elasticsearch  |                                      Elastic Search|     TRUE|      FALSE|TRUE      |\n|Carto          |Carto          |                                               Carto|     TRUE|      FALSE|TRUE      |\n|AmigoCloud     |AmigoCloud     |                                          AmigoCloud|     TRUE|      FALSE|TRUE      |\n|SXF            |SXF            |                         Storage and eXchange Format|    FALSE|      FALSE|TRUE      |\n|Selafin        |Selafin        |                                             Selafin|     TRUE|      FALSE|TRUE      |\n|JML            |JML            |                                        OpenJUMP JML|     TRUE|      FALSE|TRUE      |\n|PLSCENES       |PLSCENES       |                              Planet Labs Scenes API|    FALSE|       TRUE|TRUE      |\n|CSW            |CSW            |              OGC CSW (Catalog  Service for the Web)|    FALSE|      FALSE|TRUE      |\n|VDV            |VDV            |                 VDV-451/VDV-452/INTREST Data Format|     TRUE|      FALSE|TRUE      |\n|MVT            |MVT            |                                 Mapbox Vector Tiles|     TRUE|      FALSE|TRUE      |\n|NGW            |NGW            |                                         NextGIS Web|     TRUE|       TRUE|TRUE      |\n|MapML          |MapML          |                                               MapML|     TRUE|      FALSE|TRUE      |\n|GTFS           |GTFS           |                  General Transit Feed Specification|    FALSE|      FALSE|TRUE      |\n|PMTiles        |PMTiles        |                                      ProtoMap Tiles|     TRUE|      FALSE|TRUE      |\n|JSONFG         |JSONFG         |                    OGC Features and Geometries JSON|     TRUE|      FALSE|TRUE      |\n|MiraMonVector  |MiraMonVector  |                  MiraMon Vectors (.pol, .arc, .pnt)|     TRUE|      FALSE|TRUE      |\n|TIGER          |TIGER          |                              U.S. Census TIGER/Line|    FALSE|      FALSE|TRUE      |\n|AVCBin         |AVCBin         |                            Arc/Info Binary Coverage|    FALSE|      FALSE|TRUE      |\n|AVCE00         |AVCE00         |                       Arc/Info E00 (ASCII) Coverage|    FALSE|      FALSE|TRUE      |\n|HTTP           |HTTP           |                               HTTP Fetching Wrapper|    FALSE|       TRUE|TRUE      |\n\n\n:::\n:::\n\n\n\n\n\n\n### Exportation de données *raster* {#sec-0142}\n\nL'exportation d'objets `SpatRasters` de `terra` est très simple avec la méthode `terra::writeRaster`. En guise d'exemple, le code ci-dessous exporte la mosaïque de MNA dans un fichier GeoTIFF. Notez que le paramètre `filetype` permet de spécifier d'autres formats d'images de la liste qui est disponible au lien suivant : [*https://gdal.org/drivers/raster/index.html*](https://gdal.org/drivers/raster/index.html). En guise d'exemple, les paramètres `EIR`, `ENVI`, `RST`, `ERS` et `GRASS` permettent d'exporter vers les logiciels de télédétection ERDAS, ENVI, Idrisi, ERMapper et GRASS, tandis que le paramètre `GPKG` permet d'exporter vers un *GeoPackage* raster.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nterra::writeRaster(MosaicSherbCrop, \"data/chap01/export/MosaicSherb.tif\", \n                   filetype = \"GTiff\", \n                   overwrite = TRUE)\n```\n:::\n\n\n\n\n\n\n## Cartographie avec R {#sec-015}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Pourquoi cartographier des données dans R?**\n:::\n\n::: bloc_objectif-body\nVous avez certainement un logiciel de SIG préféré pour construire une carte thématique (QGIS ou ArcGIS Pro par exemple). Puisqu'en quelques clics de souris, il est facile de réaliser une carte dans un SIG, quel est donc l'intérêt d'écrire des lignes de code pour afficher une carte dans R? Autrement dit, pourquoi devriez-vous vous compliquer la vie à apprendre de la syntaxe R pour produire une simple carte? Savoir cartographier dans R a plusieurs avantages :\n\n-   Cartographier rapidement les résultats d'une analyse dans R permet d'éviter des allers-retours (exportation et importation de données) entre R et un logiciel de SIG. Or, la cartographie fait partie intégrante d'une démarche méthodologique d'analyse ou de modélisation spatiale. Vous restez ainsi dans le même environnement de travail (R) jusqu'à l'obtention de vos résultats finaux. Une fois ces derniers obtenus, vous pouvez les exporter et construire une carte très élaborée dans un logiciel de SIG.\n\n-   La syntaxe R n'est pas si compliquée. Quelques lignes de code écrites pour une première analyse peuvent être réutilisées, modifiées et bonifiées pour une autre analyse. Au fil de vos projets, vous construirez des cartes de plus en plus élaborées. Autrement dit, après quelques heures d'investissement, vous deviendrez une personne experte en cartographie dans R!\n:::\n:::\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n\n**Quels *packages* utiliser pour la cartographie dans R?**\n:::\n\n::: bloc_package-body\nIl existe plusieurs *packages* R pour la cartographie, notamment :\n\n-   `ggplot2` est certainement le meilleur *package* R pour réaliser des graphiques [@ggplot2Package]. Il permet désormais de construire des cartes.\n\n-   `cartography` permet de construire efficacement des cartes thématiques [@cartographyPackage]. Pour avoir une idée de son potentiel, consultez cette [*Cheatsheet*](http://riatelab.github.io/cartography/vignettes/cheatsheet/cartography_cheatsheet.pdf).\n\n-   `tmap` [@tmapArticle] est actuellement l'un des *packages* les plus complets et les plus utilisés pour construire des cartes thématiques.\n\n-   Des *packages* spécifiques permettent de créer des cartes interactives sur Internet, notamment `mapview`, `mapdeck` et `leaflet`. Ce dernier est basé sur la librairie JavaScript, largement utilisée dans le domaine de la cartographie sur Internet.\n\nDans cette section, nous utilisons uniquement `tmap` dont plusieurs ressources sont disponibles sur Internet :\n\n-   Sur le [site CRAN de `tmap`](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html), une excellente vignette intitulée *tmap: get started!*\n\n-   [Un article dans Journal of Statistical Software](https://doi.org/10.18637/jss.v084.i06) de Martijn Tennekes, créateur du *package* `tmap`.\n\n-   La [documentation complète en PDF](https://cran.r-project.org/web/packages/tmap/tmap.pdf).\n:::\n:::\n\n### Manipulation des couches géométriques {#sec-0151}\n\n#### Principales fonctions de représentation de couches vectorielles et matricielles {#sec-01511}\n\nIl existe trois catégories de fonctions pour paramétrer l'affichage de couches géographiques (@tbl-TmapMiseGeometrie).\n\n\n\n\n\n\n::: {#tbl-TmapMiseGeometrie .cell tbl-cap='Principales fonctions pour manipuler des couches vectorielles et matricielles'}\n::: {.cell-output-display}\n\n\\begin{longtable}[t]{lrcccc}\n\\toprule\nFonction & Description & Points & Lignes & Polyg. & Raster\\\\\n\\midrule\n\\addlinespace[0.3em]\n\\multicolumn{6}{l}{\\textbf{Fonction principale}}\\\\\n\\hspace{1em}tm\\_shape & Crée un élément tmap à partir d'une couche géographique vectorielle (sf) ou matricielle (raster) & X & X & X & X\\\\\n\\addlinespace[0.3em]\n\\multicolumn{6}{l}{\\textbf{Fonctions de base de manipulation}}\\\\\n\\hspace{1em}tm\\_polygons & Dessine des polygones (couleur et contour) &  &  & X & \\\\\n\\hspace{1em}tm\\_symbols & Dessine des symboles & X & X & X & \\\\\n\\hspace{1em}tm\\_lines & Dessine des lignes &  & X &  & \\\\\n\\hspace{1em}tm\\_text & Dessine des étiquettes à partir d'un champ & X & X & X & \\\\\n\\hspace{1em}tm\\_raster & Affiche un raster &  &  &  & X\\\\\n\\addlinespace[0.3em]\n\\multicolumn{6}{l}{\\textbf{Autres fonctions de manipulation}}\\\\\n\\hspace{1em}tm\\_fill & Dessine l'intérieur de polygones &  &  & X & \\\\\n\\hspace{1em}tm\\_border & Dessine les contours &  &  & X & \\\\\n\\hspace{1em}tm\\_bubbles & Dessine des cercles (notamment proportionnels) & X & X & X & \\\\\n\\hspace{1em}tm\\_squares & Dessine des carrés (notamment proportionnels) & X & X & X & \\\\\n\\hspace{1em}tm\\_dots & Dessine des points & X & X & X & \\\\\n\\hspace{1em}tm\\_markers & Dessine des icones avec étiquettes & X & X & X & \\\\\n\\bottomrule\n\\end{longtable}\n\n\n:::\n:::\n\n\n\n\n\n\n**Construction d'une carte simple avec une couche vectorielle et une couche matricielle**\n\nLe code ci-dessous permet d'afficher deux couches avec la fonction `tm_shape` : l'une vectorielle, l'autre matricielle (@fig-ArrondRaster1).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n# 1er objet tmap pour une couche raster\ntm_shape(MosaicSherbCrop)+\n  tm_raster(palette = terrain.colors(10))+\n# 1er objet tmap pour une couche vectorielle\ntm_shape(Arrondissements)+\n  tm_borders(col = \"black\", lwd = 3)+ # contour noir avec une épaisseur de trois points\n  tm_text(\"NUMERO\") # Étiquettes identifiant l'arrondissement\n```\n:::\n\n\n\n\n\n\n![Exemple de carte construite avec le *package* `tmap` avec une couche polygonale et une image](images/Chap01/Carte1.png){#fig-ArrondRaster1 width=\"50%\" fig-align=\"center\"}\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Ordre et hiérarchie des couches avec `tmap`**.\n:::\n\n::: bloc_attention-body\nVous avez compris qu'une couche est affichée avec la fonction `tm_shape` et que le `+` permet d'ajouter une ou plusieurs fonctions d'habillage à cette couche (`tm_polygons`, `tm_lines`, `tm_text`, `tm_raster`, etc.).\n\nIl est possible d'en superposer en utilisant plusieurs `tm_shape` comme suit :\n\n`tm_shape(Nom de la première couche)+` `... paramètres de la couche +` `tm_shape(Nom de la seconde couche)+` `... paramètres de la couche`\n\nNotez que la première couche est celle avec laquelle la projection et l'étendue de la carte sont définies. Il est toutefois possible de changer le tout en utilisant l'argument `is.master = TRUE` dans le `tm_shape` d'une couche donnée.\n:::\n:::\n\n**Construction d'une carte avec plusieurs couches vectorielles**\n\nLes lignes de code suivantes permettent de construire la @fig-fig2PolyPointsLignes avec trois couches `sf`.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n## Polygones\ntm_shape(Arrondissements)+\n  tm_text(\"NUMERO\")+ # Étiquettes identifiant l'arrondissement\n  tm_polygons(col=\"wheat\", border.col = \"black\", lwd = 3)+\n## Lignes\ntm_shape(Rues)+\n  tm_lines(col= \"gray\", lwd = 1)+\n## Points\ntm_shape(PointsGPS.Sherb)+\n  tm_dots(shape=21, col=\"blue\", size=.3)\n```\n\n::: {.cell-output-display}\n![Exemple de carte construite avec le *package* `tmap` avec plusieurs couches vectorielles (polygones, lignes, points)](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-fig2PolyPointsLignes-1.pdf){#fig-fig2PolyPointsLignes fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\nLa @fig-fig3PointsEtMarkers illustre la différence entre les fonctions `tm_dots` et `tm_markers`.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Points avec tm_dots()\nCartePoints <- \n  tm_shape(Arrondissements) + tm_polygons(col=\"wheat\", border.col = \"black\") +\n  tm_shape(PointsGPS.Sherb) + tm_dots(shape=21, col=\"blue\", size=.3)\n## Icones avec tm_markers()\nCarteMarkers <- \n  tm_shape(Arrondissements) + tm_polygons(col=\"wheat\", border.col = \"black\") +\n  tm_shape(PointsGPS.Sherb) + tm_markers(size = 0.2, border.col = rgb(0,0,0,0))\n## Combinaison des deux cartes\ntmap_arrange(CartePoints, CarteMarkers, ncol=2, nrow=1)\n```\n\n::: {.cell-output-display}\n![Exemple de carte `tmap` avec `tm_dots` et `tm_markers`](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-fig3PointsEtMarkers-1.pdf){#fig-fig3PointsEtMarkers fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\n#### Couleurs uniques et palette de couleurs dans `tmap` {#sec-01512}\n\nVous avez remarqué plus haut que plusieurs fonctions comprennent l'argument `col` pour spécifier une couleur. Pour connaître les trois manières de spécifier une couleur dans R -- nom de la couleur R (`lightblue` par exemple), code hexadécimal (`#f03b20` par exemple) ou notation RVBA (`rgb(0.2, 0.4, 0.4, 0)` par exemple) --, consultez [la section suivante](https://serieboldr.github.io/MethodesQuantitatives/03-magiedesgraphiques.html#sec-0315) [@RBoldAir].\n\nPour spécifier une palette de couleurs sur un champ dans différentes fonctions (entre autres, `tm_polygons`, `tm_lines`, `tm_fill`, `tm_dots`), il suffit d'utiliser deux arguments dans la fonction, soit `col=\"Nom du champ\"` et `palette=\"nom de la palette de couleurs\"`.\n\nLe *package* `tmap` intègre les palettes de deux autres *packages* : `viridisLite` [@viridisPackage] et `RColorBrewer` [@RColorBrewerPackage]. Le premier propose cinq palettes de couleurs : `viridis`, `magma`, `plasma`, `inferno`, `cividis`. Le second intègre une série de palettes de couleurs proposées par la géographe et cartographe Cynthia Brewer et ses collègues [@harrower2003colorbrewer; @brewer2003colorbrewer]. Vous avez probablement déjà exploré [leur site Internet](https://colorbrewer2.org/) où il est possible de sélectionner une palette en fonction du nombre de classes, de la nature des données et de la codification des couleurs (HEX, RGB, CMYK). Succinctement, `RColorBrewer` propose plusieurs palettes regroupées selon trois catégories :\n\n-   Palettes qualitatives à appliquer à une variable qualitative nominale comme son nom l'indique (@fig-ColorBrewerQual). Pour afficher les palettes et connaître leurs noms, tapez `display.brewer.all(type=\"qual\")` dans la console.\n\n-   Palettes séquentielles pour une variable continue avec des valeurs faibles à fortes (@fig-ColorBrewerSeq). Tapez `display.brewer.all(type=\"seq\")` dans la console.\n\n-   Palettes divergentes à appliquer à une variable continue dont les valeurs aux deux extrémités s'opposent (@fig-ColorBrewerDiv). Tapez `display.brewer.all(type=\"div\")` dans la console.\n\n![Palettes de couleurs qualitatives du *package* `RColorBrewer`](images/Chap01/RcolorBrewerQual.png){#fig-ColorBrewerQual width=\"40%\" fig-align=\"center\"}\n\n![Palettes de couleurs séquentielles du *package* `RColorBrewer`](images/Chap01/RcolorBrewerSeq.png){#fig-ColorBrewerSeq width=\"40%\" fig-align=\"center\"}\n\n![Palettes de couleurs divergentes du *package* `RColorBrewer`](images/Chap01/RcolorBrewerDiv.png){#fig-ColorBrewerDiv width=\"40%\" fig-align=\"center\"}\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Comparaison de palettes avec un nombre de classes défini**\n:::\n\n::: bloc_astuce-body\nSi vous connaissez le nombre de classes, mais que vous hésitez à choisir telle ou telle palette de couleurs, tapez dans la console :\n\n-   `display.brewer.all(n=5, type=\"seq\", exact.n=TRUE)`\n-   `display.brewer.all(n=5, type=\"div\", exact.n=TRUE)`\n-   `display.brewer.all(n=5, type=\"qual\", exact.n=TRUE)`\n\nD'autres arguments peuvent être ajoutés comme `colorblindFriendly=TRUE` qui renvoie uniquement des palettes de couleurs adaptées aux personnes daltoniennes. En guise d'exemple, avec cinq classes, il est possible de comparer neuf palettes divergentes et six autres adaptées aux personnes daltoniennes (@fig-RcolorBrewerAstuce).\n\n![Palettes de couleurs divergentes du *package* `RColorBrewer` avec cinq classes](images/Chap01/RcolorBrewerAstuce.png){#fig-RcolorBrewerAstuce width=\"60%\" fig-align=\"center\"}\n\nVous hésitez encore à choisir une palette de couleurs? Tapez la syntaxe ci-dessous dans la console pour afficher l'ensemble des palettes des *packages* `RColorBrewer` et `viridisLite`.\n\n`tmaptools::palette_explorer()`\n\nPour inverser les couleurs d'une palette, vous devez précéder le nom de la palette par un signe moins (exemple : `-Greens`).\n:::\n:::\n\n#### Cartographie d'une variable qualitative : valeurs uniques {#sec-01513}\n\n**Application à une couche de points**\n\nLe code ci-dessous illustre comment construire une carte thématique avec des couleurs appliquées à une variable qualitative nominale (champ `TYPE` de la couche `InstallationSport`) d'une couche de points (@fig-CarteVarQualPoints).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Carte\ntm_shape(Arrondissements)+\n  tm_borders()+\ntm_shape(InstallationSport)+\n  tm_dots(shape = 21,\n          size=.3,\n          col= \"TYPE\", \n          palette = \"Set1\", \n          title =\"Type d'installation\")+\ntm_layout(main.title = \"Installations sportives\",\n          frame=FALSE,\n          legend.position = c(\"left\", \"top\"),\n          legend.outside=TRUE)\n```\n\n::: {.cell-output-display}\n![Exemple de cartographie d'une variable qualitative sur des points](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CarteVarQualPoints-1.pdf){#fig-CarteVarQualPoints fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\n**Application à une couche de lignes**\n\nLe code ci-dessous illustre comment construire une carte thématique avec des couleurs appliquées à une variable qualitative nominale (champ `TYPESEGMEN`) d'une couche de lignes (@fig-CarteVarQualLignes).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Listes des valeurs uniques\ntable(Rues$TYPESEGMEN)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n      Artère    Autoroute Chemin privé  Collectrice       Locale \n        1459          380          467          579         4844 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Lignes\ntmap_mode(\"plot\")\ntm_shape(Rues)+\n  tm_lines(col= \"TYPESEGMEN\",\n           palette = c(\"red\", \"brown4\", \"cornsilk1\", \"lightpink\", \"gainsboro\"),\n           lwd = 2 \n           )\n```\n\n::: {.cell-output-display}\n![Exemple de cartographie d'une variable qualitative sur des lignes](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CarteVarQualLignes-1.pdf){#fig-CarteVarQualLignes fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\n**Application à une couche de polygones**\n\nLe code ci-dessous illustre comment construire une carte thématique avec des couleurs appliquées à une variable qualitative nominale (champ `SDRNOM` de la couche `AD2021`) d'une couche de polygones (@fig-CarteVarQualPoly).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Importation de la couche des aires de diffusion de 2021 pour la RMR de Sherbrooke\nAD2021 <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                  layer = \"SherbAD\", \n                  quiet = TRUE)\n## Carte\ntmap_mode(\"plot\")\ntm_shape(AD2021)+\n  tm_fill(col= \"SDRNOM\", \n          palette = \"Set2\", \n          lwd = 1, \n          title =\"Municipalité\")+\n  tm_borders(col=\"black\")+\ntm_layout(main.title = \"Aires de diffusion de 2021\",\n          frame =FALSE,\n          legend.position = c(\"left\", \"top\"),\n          legend.outside=TRUE)\n```\n\n::: {.cell-output-display}\n![Exemple de cartographie d'une variable qualitative sur des polygones](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CarteVarQualPoly-1.pdf){#fig-CarteVarQualPoly fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\n#### Cartographie d'une variable discrète : cercles proportionnels {#sec-01514}\n\nLa syntaxe ci-dessous permet de créer une carte avec des cercles proportionnels pour les municipalités de la région administrative de l'Estrie (@fig-CarteCerclesProport).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Importation des municipalités (subdivisions de recensements - SDR) de l'Estrie\nSDR.Estrie <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                  layer = \"sdr_Estrie\", quiet = TRUE)\n## Importation des MRC (divisions de recensements - DR) de l'Estrie\nDR.Estrie <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                  layer = \"DREstrie2021\",  quiet = TRUE)\n## Importation des données sur la population\nPopSDR <- read.csv(\"data/chap01/tables/SDR_Estrie.csv\")\nPopSDR$SDRidu <- as.character(PopSDR$SDRidu)\n## Fusion des données\nSDR.Estrie <- merge(SDR.Estrie, PopSDR, by.x = \"SDRIDU\", by.y = \"SDRidu\")\n## Construction de la carte\ntmap_mode(\"plot\")\ntm_shape(SDR.Estrie)+\n  tm_polygons(col=\"whitesmoke\", border.col = \"grey30\", lwd = 1)+\n  tm_bubbles(size = \"SDRpop_2021\",\n             border.col = \"black\",\n             col = \"tomato1\",\n             title.size = \"Population\",\n             scale = 3)+ # facteur multiplicateur pour la taille du cercle\ntm_shape(DR.Estrie)+\n  tm_borders(col=\"black\", lwd = 2)\n```\n\n::: {.cell-output-display}\n![Exemple de carte avec des cercles proportionnels](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CarteCerclesProport-1.pdf){#fig-CarteCerclesProport fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\n#### Cartographie d'une variable continue : cartes choroplèthes et méthodes de discrétisation {#sec-01515}\n\nL'argument `style`, qui est commun à plusieurs fonctions (`tm_polygons`, `tm_fill`, `tm_lines`, `tm_dots`, etc.), permet de choisir une méthode de discrétisation dont les principales sont :\n\n-   `fixed`: intervalles fixés par l'analyste.\n\n-   `equal`: intervalles égaux.\n\n-   `pretty`: intervalles arrondis aux nombres entiers.\n\n-   `quantile`: selon les quantiles (même nombre d'observations dans chaque classe).\n\n-   `jenks`: selon la méthode de Jenks.\n\n-   `sd`: selon l'écart-type.\n\nD'autres méthodes peuvent être utilisées comme `kmeans`, `hclust`, `bclust`, `fisher`, `dpih`, `headtails` et `log10_pretty.` En guise d'exemple, la @fig-CarteChropolete2 présente une discrétisation en cinq classes selon la méthode des quantiles. Notez aussi qu'il est possible de réaliser une carte avec un dégradé continu avec `style = \"cont\"` tel qu'illustré ci-dessous (@fig-CarteChropolete1).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Sélection des aires de diffusion de Sherbrooke\nAD2021.sherb <- subset(AD2021, SDRNOM == \"Sherbrooke\")\n## Carte\ntmap_mode(\"plot\")\ntm_shape(AD2021.sherb)+\n  tm_fill(col= \"HabKm2\", \n          palette = \"Reds\",  \n          style = \"cont\",\n          title =\"Hab./km2\")+\n  tm_borders(col=\"black\")\n```\n\n::: {.cell-output-display}\n![Exemple de carte choroplèthe avec une palette continue](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CarteChropolete1-1.pdf){#fig-CarteChropolete1 fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\nLa @fig-CarteChropolete2 utilise une discrétisation selon la méthode de quantiles avec cinq classes. Autrement dit, chaque classe comprend 20 % des aires de diffusion de la ville de Sherbrooke.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(AD2021.sherb)+\n  tm_fill(col= \"HabKm2\",\n          palette = \"Reds\",  \n          n = 5, # nombre de classes\n          style = \"quantile\",\n\t\t  legend.format = list(text.separator = \"à\"),\n          title =\"Hab./km2\")+\n  tm_borders(col=\"black\", lwd = .5)\n```\n\n::: {.cell-output-display}\n![Exemple de carte choroplèthe avec une discrétisation selon les quantiles](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CarteChropolete2-1.pdf){#fig-CarteChropolete2 fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\nLa @fig-MethoDiscretisation présente quatre méthodes de discrétisation différentes appliquées au revenu médian des ménages par secteur de recensement dans la région métropolitaine de recensement de Sherbrooke en 2021.\n\n![Différentes méthodes de discrétisation](images/Chap01/MethodesDiscretisation.png){#fig-MethoDiscretisation width=\"75%\" fig-align=\"center\"}\n\n### Cartes interactives {#sec-0152}\n\nAvec la fonction `tmap_mode`, il est possible de choisir l'un des deux modes de visualisation suivants :\n\n-   statique avec `tmap_mode(\"plot\")`.\n-   interactif avec `tmap_mode(\"view\")`.\n\nVous constaterez ci-dessous que par défaut, trois fonds de carte sont disponibles dans la carte interactive, soit dans l'ordre `Esri.WorldGrayCanvas`, `OpenStreetMap` et `Esri.WorldTopoMap`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Mode active tmap\ntmap_mode(\"view\")\n## Importation des couches\nArrond.sf = read_sf(\"data/chap01/shp/Arrondissements.shp\")\nInstallSR.sf = read_sf(\"data/chap01/shp/Installations_sportives_et_recreatives.shp\")\n## Carte\ntm_shape(InstallSR.sf)+ tm_dots(size = 0.05, shape = 21, col = \"red\")+\ntm_shape(Arrond.sf)+ tm_borders(col=\"black\", lwd= .5)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/Chap01/interactif_a.jpg){width=3.8in}\n:::\n:::\n\n\n\n\n\n\n\n\nIl est aussi possible de changer les fonds de carte avec la fonction `tm_basemap` tandis que la fonction `tm_tiles` permet de superposer une tuile (pour la toponymie par exemple) (@tbl-TmapCarteInteractive).\n\n\n\n\n\n\n::: {#tbl-TmapCarteInteractive .cell tbl-cap='Fonctions pour des cartes interactives'}\n::: {.cell-output-display}\n\n\n|Fonction     |Description                             |\n|:------------|:---------------------------------------|\n|`tmap_mode`  |Choisir le mode statique ou interactive |\n|`tm_basemap` |Spécifier un fond de carte              |\n|`tm_tiles`   |Spécifier une tuile de fond             |\n\n\n:::\n:::\n\n\n\n\n\n\nDans le code ci-dessous, nous utilisons uniquement deux fonds de carte. Remarquez les lignes avec l'argument `popup.vars` qui permet de définir les champs visibles dans la fenêtre surgissante (*pop-up*). Cliquez sur une installation sportive pour activer la fenêtre surgissante.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Carte\ntm_basemap(c(\"OpenStreetMap\", \"Esri.WorldTopoMap\"))+\ntm_shape(InstallSR.sf)+ \n  tm_dots(size = 0.05, shape = 21, col = \"red\",\n          # définition pour le pop-up (clic sur une installation)\n          popup.vars=c(\"Nom : \"=\"NOM\",\n                       \"Type : \" = \"TYPE\",\n                       \"Éclairage : \" = \"ECLAIRAGE\",\n                       \"Éclairage : \" = \"SURFACE\"),\n          id = \"OBJECTID\")+\ntm_shape(Arrond.sf)+ tm_borders(col=\"black\", lwd= .5)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/Chap01/gps.jpg){width=5.03in}\n:::\n:::\n\n\n\n\n\n\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Où trouver des fonds de carte?**\n:::\n\n::: bloc_astuce-body\nUne liste des fonds de carte **Leaflet** est disponible au [lien suivant](https://leaflet-extras.github.io/leaflet-providers/preview/).\n:::\n:::\n\n### Mise en page d'une carte {#sec-0153}\n\nLes principales fonctions de mise en page d'une carte sont présentées au @tbl-TmapMiseEnMap.\n\n\n\n\n\n\n::: {#tbl-TmapMiseEnMap .cell tbl-cap='Fonctions d\\'habillage d\\'une carte'}\n::: {.cell-output-display}\n\n\n|Fonction       |Description                                                       |Principaux arguments                                                                                                                                                      |\n|:--------------|:-----------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n|`tm_facets`    |Créer un élément `tmap` avec plusieurs  vignettes                 |`by`: groupé par colonne. `nrow` et `ncol`: nombres de lignes et de colonnes                                                                                              |\n|`tmap_arrange` |Fusionner plusieurs cartes dans une mise en page                  |`nrow` et `ncol`: nombre de lignes et de colonnes                                                                                                                         |\n|`tm_grid`      |Ajouter une grille de lignes de coordonnées (ex. long/lat)        |`x` et `y`: vecteurs pour les coordonnées                                                                                                                                 |\n|`tm_credits`   |Créer un texte pour spéficier l'auteur.e ou la source de la carte |`text`: texte. `size`: taille du texte. `fontfamily`: police du texte                                                                                                     |\n|`tm_scale_bar` |Créer une échelle                                                 |`break`: vecteur numérique pour l'échelle. `position`: position de l'échelle avec les valeurs `left`, `center`, `right`, `bottom`, `top`. Par exemple c('left', 'bottom') |\n|`tm_compass`   |Créer une flèche du nord                                          |`type`: type de flèche du Nord ('arrow', '4star', '8star', 'radar', 'rose')                                                                                               |\n|`tm_logo`      |Ajouter un logo à une carte                                       |`file`: chemin et nom du fichier ou URL                                                                                                                                   |\n|`tm_xlab`      |Ajouter un titre sur l'axe des X de la carte                      |`text`: nom de l'axe                                                                                                                                                      |\n|`tm_ylab`      |Ajouter un titre sur l'axe des Y de la carte                      |`text`: nom de l'axe                                                                                                                                                      |\n|`tm_layout`    |Spécifier des éléments de mise en page de la carte                |`title`: titre de la carte                                                                                                                                                |\n|`tm_legend`    |Paramétrer la légende de la carte                                 |`position`: position de la légende avec les valeurs `left`, `center`, `right`, `bottom`, `top`                                                                            |\n|`tmap_options` |Paramétrer et conserver plusieurs options sur la carte            |`unit`: unités de mesures ('imperial', 'km', 'm', 'mi', and 'ft')                                                                                                         |\n\n\n:::\n:::\n\n\n\n\n\n\n#### Combinaison de plusieurs cartes {#sec-01531}\n\nTel que décrit dans le @tbl-TmapMiseEnMap, il existe deux fonctions pour combiner deux cartes : `tmap_arrange` et `tm_facets`.\n\nPour ceux et celles réalisant régulièrement des graphiques dans R avec `ggplot2`, `tmap_arrange` est très similaire à la fonction `ggarrange` du *package* `ggpubr` qui permet de fusionner plusieurs graphiques. Globalement, le principe est le suivant : vous réalisez deux cartes ou plus que vous combinez dans une même sortie avec `tmap_arrange`. Vous trouverez ci-dessous un exemple avec deux cartes (@fig-CombinaisonAvecTmapArrange).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n## Carte 1\nCarte1 =  tm_shape(SDR.Estrie)+\n            tm_polygons(col=\"whitesmoke\", border.col = \"grey30\", lwd = 1)+\n            tm_bubbles(size = \"SDRpop_2021\",\n                       border.col = \"black\",\n                       col = \"tomato1\",\n                       title.size = \"Population\",\n                       scale = 3)+ # facteur multiplicateur pour la taille du cercle\n          tm_shape(DR.Estrie)+ tm_borders(col=\"black\", lwd = 2)\n## Calcul de la densité de population\nSDR.Estrie$HabKm2 <- as.numeric(SDR.Estrie$SDRpop_2021 / (st_area(SDR.Estrie) / 1000000))\n## Carte 2\nCarte2 =  tm_shape(SDR.Estrie)+\n              tm_fill(col= \"HabKm2\", \n                    palette = \"Reds\",  \n                    style = \"quantile\", n = 4,\n                    title =\"Hab./km2\",\n                    legend.format = list(text.separator = \"à\"))+\n              tm_borders(col=\"black\")+\n          tm_shape(DR.Estrie)+ tm_borders(col=\"black\", lwd = 2)\n## Combinaison des deux cartes\ntmap_arrange(Carte1, Carte2, ncol = 2, nrow = 1)\n```\n\n::: {.cell-output-display}\n![Exemple de combinaisons de carte avec `tmap_arrange`](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CombinaisonAvecTmapArrange-1.pdf){#fig-CombinaisonAvecTmapArrange fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\nQuant à la fonction `tm_facets`, elle permet de créer plusieurs cartes avec l'argument `by`. Prenons un exemple concret : vous disposez d'une couche géographique des municipalités du Québec et vous souhaitez réaliser une carte pour chaque région administrative. L'argument `by = \"Region\"` vous permet alors d'avoir une vignette par région. Dans l'exemple ci-dessous, nous avons cartographié la même variable (densité de population) pour différentes zones de la région métropolitaine de Sherbrooke (@fig-CombinaisonAvecFacets1).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n## Création d'une variable zone basée sur les noms des municipalités\nAD2021$Zone <- ifelse(AD2021$SDRNOM == \"Sherbrooke\", \"A. Sherbrooke\", \"\") \nAD2021$Zone <- ifelse(AD2021$SDRNOM %in% c(\"Compton\", \"Waterville\", \"Hatley\", \"North Hatley\"), \n                      \"B. Sud\", AD2021$Zone) \nAD2021$Zone <- ifelse(AD2021$SDRNOM %in% c(\"Orford\", \"Magog\", \"Saint-Denis-de-Brompton\"), \n                      \"C. Est\", AD2021$Zone) \nAD2021$Zone <- ifelse(AD2021$SDRNOM %in% c(\"Ascot Corner\", \"Val-Joli\", \"Stoke\"), \n                      \"C. Nord\", AD2021$Zone) \n## Création des cartes avec tm_facets\ntmap_mode(\"plot\")\ntm_shape(AD2021)+\n  tm_fill(col= \"HabKm2\",\n          palette = \"Reds\",  \n          n = 5, # nombre de classes\n          style = \"quantile\",\n          title =\"Hab./km2\",\n          legend.format = list(text.separator = \"à\"))+\n  tm_borders(col=\"black\", lwd = .5)+\n  tm_facets(by = \"Zone\")\n```\n\n::: {.cell-output-display}\n![Premier exemple de combinaison de cartes avec `tm_facets`](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CombinaisonAvecFacets1-1.pdf){#fig-CombinaisonAvecFacets1 fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\nL'utilisation de `tm_facets` peut être également très utile pour comparer les distributions spatiales de points à différentes années (@fig-CombinaisonAvecFacets2).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n## Importation des incidents\nIncidents <- st_read(\"data/chap01/shp/IncidentsSecuritePublique.shp\", quiet = TRUE)\n## Création des cartes avec tm_facets\ntmap_mode(\"plot\")\ntm_shape(Arrondissements) + \n  tm_polygons(col=\"wheat\", border.col = \"black\") +\ntm_shape(Incidents) +\n  tm_dots(shape=21, col=\"blue\", size=.2) +\ntm_facets(by = \"ANNEE\")\n```\n\n::: {.cell-output-display}\n![Deuxième exemple de combinaisons de carte avec `tm_facets`](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-CombinaisonAvecFacets2-1.pdf){#fig-CombinaisonAvecFacets2 fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\n#### Mise en page d'une carte {#sec-01532}\n\nNous reprenons la @fig-HabillageDuneCarte et l'habillons en ajoutant une échelle (`tm_scale_bar`), une flèche du Nord (`tm_compass`), la source et l'auteur (`tm_credits`) et un titre (`tm_layout`) (@fig-HabillageDuneCarte).\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Carte 1\ntmap_mode(\"plot\")\ntm_shape(SDR.Estrie)+\n            tm_fill(col= \"HabKm2\", palette = \"Greens\",  \n                    style = \"quantile\", n = 4,\n                    title =\"Hab./km2\",\n                    legend.format = list(text.separator = \"à\"))+\n            tm_bubbles(size = \"SDRpop_2021\", border.col = \"black\", col = \"tomato1\", scale = 3,\n                       title.size = \"Population\")+ \n            tm_borders(col=\"black\")+\n## Ajout de de la flèche du Nord\ntm_compass(position = c(\"right\", \"bottom\"), \n           size = 2)+\n## Ajout de l'échelle\ntm_scale_bar(breaks  = c(0, 25, 50),\n             position = c(\"right\", \"bottom\"))+\n## Ajout de la source\ntm_credits(\"Source : recensement de 2021, Statistique Canada\\nAuteur : Jéremy Lacartemplace.\", \n           position = c(\"right\", \"bottom\"),\n           size = 0.7,\n           align = \"right\") +\n## Légende  \ntm_legend(position = c(\"left\", \"top\"), \n          frame = FALSE, bg.color = \"white\")+\n## Modification de la mise en page\ntm_layout(main.title = \"Municipalités de l'Estrie\",\n          legend.outside = TRUE,\n          frame = FALSE)\n```\n\n::: {.cell-output-display}\n![Habillage d'une carte](01-ManipulationDonneesSpatiales_files/figure-pdf/fig-HabillageDuneCarte-1.pdf){#fig-HabillageDuneCarte fig-align='center' fig-pos='H' width=85%}\n:::\n:::\n\n\n\n\n\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Aller plus loin avec `tmap`?**\n:::\n\n::: bloc_aller_loin-body\nNous avons abordé uniquement les principales fonctions et arguments pour l'habillage d'une carte. Plusieurs exemples de très belles cartes créées avec `tmap` sont disponibles aux ressources suivantes :\n\n-   L'excellente vignette intitulée [*`tmap`: get started!*](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)\n\n-   [*Visualizing Spatial Data in R with tmap*](http://www.wvview.org/os_sa/10_Maps_with_tmap.html#visualizing-spatial-data-in-r-with-tmap).\n\n-   [*Making Maps with R*](https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html).\n\n-   Le chapitre [*Making maps with R*](https://geocompr.robinlovelace.net/adv-map.html) du livre [*Geocomputation with R*](https://geocompr.robinlovelace.net/index.html).\n:::\n:::\n\n### Exportation d'une carte {#sec-0154}\n\nUne fois la carte finalisée, il est possible de l'exporter dans différents formats avec la fonction `tmap_save` :\n\n-   En mode image (png, jpg, bmp, tiff) pour l'insérer dans un logiciel de traitement de texte (Word ou OpenOffice Writer) ou dans un éditeur LaTeX ([Overleaf](https://fr.overleaf.com/) par exemple).\n\n-   En mode vectoriel (PDF ou SVG) pour finaliser l'édition de la carte dans un logiciel de création graphique vectorielle (Illustrator par exemple).\n\n-   En HTML dans lequel la carte sera intégrée selon le mode de visualisation interactive, sous la forme d'un *widget* Leaflet.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Transformation en long/lat\n## Carte 1\ntmap_mode(\"plot\")\nCarte1 <- tm_shape(SDR.Estrie)+\n  tm_fill(col= \"HabKm2\", palette = \"Greens\", style = \"quantile\", n = 4, title =\"Hab./km2\")+\n  tm_bubbles(size = \"SDRpop_2021\", border.col = \"black\", col = \"tomato1\", scale = 3,\n                       title.size = \"Population\")+ \n  tm_borders(col=\"black\")+\n  tm_compass(position = c(\"right\", \"bottom\"), size = 2)+\n  tm_scale_bar(breaks  = c(0, 25, 50), position = c(\"right\", \"bottom\"))+\n  tm_credits(\"Source : recensement de 2021, Statistique Canada\\nAuteur : Jéremy Lacartemplace.\", \n           position = c(\"right\", \"bottom\"), size = 0.7, align = \"right\") +\n  tm_legend(position = c(\"left\", \"top\"), frame = FALSE, bg.color = \"white\")+\n  tm_layout(main.title = \"Municipalités de l'Estrie\", legend.outside = TRUE, frame = FALSE)\n\n## Exportation de la Carte1 au format png\ntmap_save(Carte1, filename = \"data/chap01/export/Carte1.png\", dpi = 600)\n## Exportation de la Carte1 au format PDF\ntmap_save(Carte1, filename = \"data/chap01/export/Carte1.pdf\")\n## Exportation de la Carte1 au format HTML\ntmap_save(Carte1, filename = \"data/chap01/export/Carte1.html\")\n```\n:::\n\n\n\n\n\n\n## Quiz de révision du chapitre {#sec-016}\n\n\n\n\n\n\n**Questions**\n\n* **La classe sf est composée de trois éléments :**\n\t+ simple feature geometry (sfg) : géométrie d'une observation\n\t+ simple feature column (sfc) : liste toutes les géométries d'une couche\n\t+ data.fame : données attributaires\n\t+ raster : données images\n\n\tRelisez au besoin la [section @sec-011142].\n\n* **Laquelle de ces fonctions permet de changer la projection cartographique d'une couche géographique?**\n\t+ st_crs(x)\n\t+ st_transform(x, crs)\n\t+ st_is_longlat(x)\n\n\tRelisez au besoin le début de la [section @sec-0121].\n\n* **Laquelle de ces fonctions n'est pas une fonction géométrique sur une couche?**\n\t+ st_bbox(x)\n\t+ st_union(x)\n\t+ st_point_on_surface(x)\n\t+ st_crop(x, y, xmin, ymin, xmax, ymax)\n\t+ st_centroid(x)\n\n\tRelisez au besoin la [section @sec-0122].\n\n* **Comparativement à l'algorithme de Douglas et Peucker, que permet l’algorithme de Visvalingam lors de la simplification des contours?**\n\t+ Il est plus rapide.\n\t+ Il permet de conserver les frontières.\n\n\tRelisez au besoin la [section @sec-01224].\n\n* **Tous les points sont compris dans leur enveloppe convexe.**\n\t+ Vrai\n\t+ Faux\n\n\tRelisez au besoin la [section @sec-01225].\n\n* **Quelles sont les quatre fonctions de mesures géométriques et de récupération des coordonnées géographiques?**\n\t+ st_area(x)\n\t+ st_length(x)\n\t+ st_distance(x,y)\n\t+ st_coordinates(x)\n\t+ st_union(x)\n\n\tRelisez au besoin la [section @sec-0124].\n\n* **Quelle est la différence entre les fonctions st_intersects(x, y) et st_intersection(x, y)?**\n\t+ Elles génèrent le même résultat.\n\t+ La première est une requête spatiale, la seconde renvoie l'intersection entre deux couches.\n\t+ La première renvoie l'intersection entre deux couches, la seconde est une requête spatiale.\n\n\tRelisez le deuxième encadré à la [section @sec-0126].\n\n* **Laquelle des fonctions sf permet d'exporter des données vectorielles?**\n\t+ st_read()\n\t+ st_write()\n\t+ writeRaster()\n\n\tRelisez au besoin la [section @sec-0141].\n\n\n**Réponses**\n\n * La classe sf est composée de trois éléments :\n\t+ simple feature geometry (sfg) : géométrie d'une observation\n\t+ simple feature column (sfc) : liste toutes les géométries d'une couche\n\t+ data.fame : données attributaires\n * Laquelle de ces fonctions permet de changer la projection cartographique d'une couche géographique?\n\t+ st_transform(x, crs)\n * Laquelle de ces fonctions n'est pas une fonction géométrique sur une couche?\n\t+ st_crop(x, y, xmin, ymin, xmax, ymax)\n * Comparativement à l'algorithme de Douglas et Peucker, que permet l’algorithme de Visvalingam lors de la simplification des contours?\n\t+ Il permet de conserver les frontières.\n * Tous les points sont compris dans leur enveloppe convexe.\n\t+ Vrai\n * Quelles sont les quatre fonctions de mesures géométriques et de récupération des coordonnées géographiques?\n\t+ st_area(x)\n\t+ st_length(x)\n\t+ st_distance(x,y)\n\t+ st_coordinates(x)\n * Quelle est la différence entre les fonctions st_intersects(x, y) et st_intersection(x, y)?\n\t+ La première est une requête spatiale, la seconde renvoie l'intersection entre deux couches.\n * Laquelle des fonctions sf permet d'exporter des données vectorielles?\n\t+ st_write()\n\n\n\n\n\n\n## Exercices de révision {#sec-017}\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 1.** Découpage des rues de l'arrondissement des Nations de la ville de Sherbrooke\n:::\n\n::: bloc_exercice-body\nComplétez le code ci-dessous avec les étapes suivantes :\n\n-   Requête attributaire pour créer un objet `sf` avec uniquement l'arrondissement des Nations à partir de la couche `Arrondissements` et le champ `NOM` (voir la [section @sec-01274]).\n\n-   Découpez les rues (`Rues`) sur le nouvel objet `sf` (voir la [section @sec-01213]).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n## Importation des deux couches\nArrond <- st_read(\"data/chap01/shp/Arrondissements.shp\", quiet = TRUE)\nRues <- st_read(\"data/chap01/shp/Segments_de_rue.shp\", quiet = TRUE)\n## Requête attributaire : création d'un objet sf pour l'arrondissement des Nations\ntable(Arrond$NOM)\nArrond.DesNations <- subset(À compléter)\n## Découper les rues avec le polygone de l'arrondissement des Nations\nRues.DesNations <- À compléter\n```\n:::\n\n\n\n\n\n\nCorrection à la [section @sec-12011].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 2.** Calcul d'un nouveau champ\n:::\n\n::: bloc_exercice-body\nCalculez un nouveau champ (`DistHVKM`) dans la couche des aires de diffusion (AD) (`AD.RMRSherb`) qui représente la distance en kilomètres entre l'hôtel de ville de Sherbrooke et les points des AD. Puis, cartographiez le champ `DistHVKM` en quatre classes selon la méthode de discrétisation par quantiles. Complétez le code ci-dessous avec les étapes suivantes :\n\n-   Ajoutez un champ pour la distance (`DistHVKM`) dans la couche `AD.RMRSherb` (voir la [section @sec-0124]).\n\n-   Cartographiez le champ `DistHVKM` en quatre classes selon la méthode des quantiles (voir la [section @sec-01515]).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(tmap)\n## Importation des deux couches\nAD.RMRSherb <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                       layer = \"SherbAD\", quiet = TRUE)\nHotelVille <- data.frame(ID = 1, Nom = \"Hôtel de ville\",\n                         lon = -71.89306, lat = 45.40417)\nHotelVille <- st_as_sf(HotelVille, coords = c(\"lon\",\"lat\"), crs = 4326)\n## Changement de projection avant de s'assurer que les deux couches ont la même\nHotelVille <- st_transform(HotelVille, st_crs(AD.RMRSherb))\n## Ajout d'un champ pour la distance en km à l'hôtel de ville pour les secteurs de recensement\nAD.RMRSherb$DistHVKM <- À compléter\n## Cartographie en quatre classes selon les quantiles\ntmap_mode(\"plot\")\ntm_shape(À compléter)+\n  tm_fill(À compléter)+\n  tm_borders(col=\"black\")\n```\n:::\n\n\n\n\n\n\nCorrection à la [section @sec-12012].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 3.** Importation d'une couche *shapefile*\n:::\n\n::: bloc_exercice-body\nImportez une couche *shapefile* pour les divisions de recensement et calculez la densité de population (nombre d'habitants au km^2^). Complétez le code ci-dessous avec les étapes suivantes :\n\n-   Faites une jointure attributaire entre la couche `DR.Qc` et la table `DR.Data` (voir la [section @sec-01272]).\n\n-   Calculez le champ `HabKm2`, soit la division entre les champs `DRpop_2021` et `SUPTERRE` (voir la [section @sec-01515]).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n## Importation de la couche des divisions de recensement du Québec\nDR.Qc <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                 layer = \"DivisionsRecens2021\", quiet = TRUE)\n## Importation du fichier csv des divisions de recensement\nDR.Data <- read.csv(\"data/chap01/tables/DRQC2021.csv\")\n## Jointure attributaire avec le champ IDUGD\nDR.Qc <- A compléter\n## Il y a déjà deux champs dans la table pour calculer la densité de population :\n## SUPTERRE : superficie en km2\n## DRpop_2021 : population en 2021\nDR.Qc$HabKm2 <- A compléter\nhead(DR.Qc, n=2)\nsummary(DR.Qc$HabKm2)\n```\n:::\n\n\n\n\n\n\nCorrection à la [section @sec-12013].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 4.** Coordonnées géographiques\n:::\n\n::: bloc_exercice-body\nVous recevez les coordonnées en degrés (WGS84, EPSG : 4326) : -71.91688, 45.37579. Créez un point pour cette localisation et calculez la distance la séparant du tronçon autoroutier le plus proche. Complétez le code ci-dessous avec les étapes suivantes :\n\n-   Faites une requête attributaire pour créer un objet `sf` avec uniquement les tronçons autoroutiers à partir de la couche `Rues` et le champ `TYPESEGMEN` (voir la [section @sec-01274]).\n\n-   Trouvez l'identifiant du tronçon le plus proche avec la fonction `st_nearest_feature` (voir la [section @sec-0126]).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n## Importation du réseau de rues\nRues <- st_read(\"data/chap01/shp/Segments_de_rue.shp\", quiet=TRUE)\nunique(Rues$TYPESEGMEN)\n## Sélection des tronçons autoroutiers\nAutoroutes <- À compléter\n## Création d'une couche sf pour le point avec les coordonnées\n## en degrés (WGS84, EPSG : 4326) : -71.91688, 45.37579\nPoint1_sf <- À compléter\n## Changement de projection avant de s'assurer que les deux couches ont la même\nPoint1_sf <- st_transform(Point1_sf, st_crs(Autoroutes))\n## Trouver le tronçon autoroutier le plus proche avec la fonction st_nearest_feature\nPlusProche <- À compléter\nprint(PlusProche)\nPoint1_sf$AutoroutePlusProche <- as.numeric(st_distance(Point1_sf,\n                                                        Autoroutes[PlusProche,]))\ncat(\"Distance à l'autoroute la plus proche :\", Point1_sf$AutoroutePlusProche, \"m.\")\n## Zone tampon\nZoneTampon <- st_buffer(Point1_sf, Point1_sf$AutoroutePlusProche)\n## Cartographie\ntmap_mode(\"view\")\ntm_shape(ZoneTampon)+\n  tm_borders(col= \"black\")+\ntm_shape(Autoroutes)+\n  tm_lines(col=\"red\")+\ntm_shape(Point1_sf)+\n  tm_dots(col= \"blue\", shape=21, size = .2)\n```\n:::\n\n\n\n\n\n\nCorrection à la [section @sec-12014].\n:::\n:::\n\n",
    "supporting": [
      "01-ManipulationDonneesSpatiales_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{\"knit_meta_id\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]}},\"value\":[{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"booktabs\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"longtable\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"array\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"multirow\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"wrapfig\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"float\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"colortbl\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"pdflscape\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"tabu\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"threeparttable\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"threeparttablex\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"ulem\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"normalem\"]},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"makecell\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"xcolor\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"booktabs\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"longtable\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"array\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"multirow\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"wrapfig\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"float\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"colortbl\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"pdflscape\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"tabu\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"threeparttable\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"threeparttablex\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"ulem\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"normalem\"]},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"makecell\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"xcolor\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]}]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}