{"title":"Correction des exercices","markdown":{"headingText":"Correction des exercices","headingAttr":{"id":"sec-chap12","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n## Exercices du chapitre 1 {#sec-1201}\n\n### Exercice 1 {#sec-12011}\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: false\nlibrary(sf)\n## Importation des deux couches\nArrond <- st_read(\"data/chap01/shp/Arrondissements.shp\", quiet = TRUE)\nRues <- st_read(\"data/chap01/shp/Segments_de_rue.shp\", quiet = TRUE)\n## Création d'un objet sf pour l'arrondissement des Nations : requête attributive\ntable(Arrondissements$NOM)\nArrond.DesNations <- subset(Arrondissements, \n                            NOM == \"Arrondissement des Nations\")\n## Découper les rues avec le polygone de l'arrondissement des nations\nRues.DesNations <- st_intersection(Rues, Arrond.DesNations)\n```\n\n### Exercice 2 {#sec-12012}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(tmap)\n## Importation des deux couches\nAD.RMRSherb <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                       layer = \"SherbAD\", quiet = T)\nHotelVille <- data.frame(ID = 1, Nom = \"Hotel de Ville\",\n                         lon = -71.89306, lat = 45.40417)\nHotelVille <- st_as_sf(HotelVille, coords = c(\"lon\",\"lat\"), crs = 4326)\n## Changement de projection avant de s'assurer que les deux couches aient la même\nHotelVille <- st_transform(HotelVille, st_crs(AD.RMRSherb))\n## Ajout d'un champ pour la distance en km à l'hôtel de Ville pour les secteurs de recensement\nAD.RMRSherb$DistHVKM <- as.numeric(st_distance(AD.RMRSherb,HotelVille)) / 1000\n## Cartographie en quatre classes selon les quantiles\ntmap_mode(\"plot\")\ntm_shape(AD.RMRSherb)+\n  tm_fill(col= \"DistHVKM\", \n          palette = \"Reds\",\n          n=4,\n          style = \"quantile\",\n          title =\"Distance à l'hôtel de Ville (km)\")+\n  tm_borders(col=\"black\")\n```\n\n### Exercice 3 {#sec-12013}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\n## Importation de la couche des divisions de recensement du Québec\nDR.Qc <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                 layer = \"DivisionsRecens2021\", quiet = T)\n## Importation du fichier csv des division de recensement\nDR.Data <- read.csv(\"data/chap01/tables/DRQC2021.csv\")\n## Jointure attributive avec le champ IDUGD\nDR.Qc <- merge(DR.Qc, DR.Data, by=\"IDUGD\")\n## Il y a déja deux champs dans la table pour calculer la densité de population :\n## SUPTERRE : superficie en km2\n## DRpop_2021 : population en 2021\nDR.Qc$HabKm2 <- DR.Qc$DRpop_2021 / DR.Qc$SUPTERRE\nhead(DR.Qc, n=2)\nsummary(DR.Qc$HabKm2)\n```\n\n### Exercice 4 {#sec-12014}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\n## Importation du réseau de rues\nRues <- st_read(\"data/chap01/shp/Segments_de_rue.shp\", quiet=T)\nunique(Rues$TYPESEGMEN)\n## Sélection des tronçons autoroutiers\nAutoroutes <- subset(Rues, TYPESEGMEN == \"Autoroute\")\n## Création d'une couche sf pour le point avec les coordonnées\n## en degrés (WGS84, EPSG : 4326) : -71.91688, 45.37579\nPoint1_sf <- data.frame(ID = 1,\n                         lon = -71.91688, lat = 45.37579)\nPoint1_sf <- st_as_sf(Point1_sf, coords = c(\"lon\",\"lat\"), crs = 4326)\n## Changement de projection avant de s'assurer que les deux couches aient la même\nPoint1_sf <- st_transform(Point1_sf, st_crs(Autoroutes))\n## Trouver le tronçon autoroutier le plus proche\nPlusProche <- st_nearest_feature(Point1_sf, Autoroutes)\nprint(PlusProche)\nPoint1_sf$AutoroutePlusProche <- as.numeric(st_distance(Point1_sf,\n                                                        Autoroutes[PlusProche,]))\ncat(\"Distance à l'autoroute la plus proche :\", Point1_sf$AutoroutePlusProche, \"m.\")\n## Zone tampon \nZoneTampon <- st_buffer(Point1_sf, Point1_sf$AutoroutePlusProche)\n## Cartographie\ntmap_mode(\"view\")\ntm_shape(ZoneTampon)+\n  tm_borders(col= \"black\")+\ntm_shape(Autoroutes)+\n  tm_lines(col=\"red\")+\ntm_shape(Point1_sf)+\n  tm_dots(col= \"blue\", shape=21, size = .2)\n```\n\n## Exercices du chapitre 2 {#sec-1202}\n\n### Exercice 1 {#sec-12021}\n\n![Exercice sur la contiguïté et les ordres d'adjacence](images/Chap10/ExoMatriceDeContiguiteCorrection.png){#fig-ExoMatriceDeContiguite width=\"65%\" fig-align=\"center\"}\n\n### Exercice 2 {#sec-12022}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(spdep)\nlibrary(tmap)\n## Importation de la couche des secteurs de recensement\nSRQc <- st_read(dsn = \"data/chap02/exercice/RMRQuebecSR2021.shp\", quiet=TRUE)\n\n## Matrice selon le partage d'un segment (Rook)\nRook <- poly2nb(SRQc, queen=FALSE)\nW.Rook <- nb2listw(Rook, zero.policy=TRUE, style = \"W\")\n\n## Coordonnées des centroïdes des entités spatiales\ncoords <- st_coordinates(st_centroid(SRQc))\n\n## Matrices de l'inverse de la distance\n# Trouver le plus proche voisin\nk1 <- knn2nb(knearneigh(coords))\nplusprochevoisin.max <- max(unlist(nbdists(k1,coords)))\n# Voisins les plus proches avec le seuil de distance maximal\nVoisins.DistMax <- dnearneigh(coords, 0, plusprochevoisin.max)\n# Distances avec le seuil maximum\ndistances <- nbdists(Voisins.DistMax, coords)\n# Inverse de la distance au carré\nInvDistances2 <- lapply(distances, function(x) (1/x^2))\n## Matrices de pondérations spatiales standardisées en ligne\nW_InvDistances2Reduite <- nb2listw(Voisins.DistMax, glist = InvDistances2, style = \"W\")\n\n## Matrice des plus proches voisins avec k = 2\nk2 <- knn2nb(knearneigh(coords, k = 2))\nW.k2 <-  nb2listw(k2, zero.policy=FALSE, style = \"W\")\n```\n\n### Exercice 3 {#sec-12023}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(spdep)\nlibrary(tmap)\n## Cartographie de la variable\ntm_shape(SRQc)+\n  tm_polygons(col=\"D1pct\", title = \"Premier décile de revenu (%)\",\n              style=\"quantile\", n=5, palette=\"Greens\")+\n  tm_layout(frame = F)+tm_scale_bar(c(0,5,10))\n\n## I de Moran avec la méthode Monte-Carlo avec 999 permutations\n# utilisez la fonction moran.mc\n# avec la matrice W.Rook\nmoran.mc(SRQc$D1pct, listw=W.Rook, zero.policy=TRUE,  nsim=999)\n# avec la matrice W_InvDistances2\nmoran.mc(SRQc$D1pct, listw=W_InvDistances2Reduite, zero.policy=TRUE,  nsim=999)\n# avec la matrice W.k2\nmoran.mc(SRQc$D1pct, listw=W.k2, zero.policy=TRUE,  nsim=999)\n```\n\nLes valeurs du *I* de Moran sont les suivantes : 0,69 pour la matrice *Rook*, 0,52 pour la matrice inverse de la distance au carré réduite et 0,75 pour la matrice selon le critère des deux plus proches voisins.\n\n### Exercice 4 {#sec-12024}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\n####################\n## Calcul du Z(Gi)\n####################\nSRQc$D1pct_localGetis <- localG(SRQc$D1pct, \n                                W.Rook, \n                                zero.policy=TRUE)\n# Définition des intervalles et des noms des classes\nclasses.intervalles = c(-Inf, -3.29, -2.58, -1.96, 1.96, 2.58, 3.29, Inf)\nclasses.noms = c(\"Point froid (p = 0,001)\", \n                \"Point froid (p = 0,01)\", \n                \"Point froid (p = 0,05)\", \n                \"Non significatif\",\n                \"Point chaud (p = 0,05)\", \n                \"Point chaud (p = 0,01)\", \n                \"Point chaud (p = 0,001)\")\n\n## Création d'un champ avec les noms des classes\nSRQc$D1pct_localGetisP <- cut(SRQc$D1pct_localGetis,\n                              breaks = classes.intervalles,\n                              labels = classes.noms)\n## Cartographie\ntm_shape(SRQc)+\n  tm_polygons(col =\"D1pct_localGetisP\", \n              title=\"Z(Gi)\", palette=\"-RdBu\", lwd = 1)+\n  tm_layout(frame =F)\n\n####################\n## Typologie LISA\n####################\n## Cote Z (variable centrée réduite)\nzx <- (SRQc$D1pct - mean(SRQc$D1pct))/sd(SRQc$D1pct)\n## variable X centrée réduite spatialement décalée avec une matrice Rook\nwzx <- lag.listw(W.Rook, zx)\n## I de Moran local (notez que vous pouvez aussi utiliser la fonction localmoran_perm)\nlocalMoranI  <- localmoran(SRQc$D1pct, W.Rook)\nplocalMoranI <- localMoranI[, 5]\n## Choisir un seuil de signification\nsignif = 0.05\n## Construction de la typologie\nTypologie <- ifelse(zx > 0 & wzx > 0, \"1. HH\", NA)\nTypologie <- ifelse(zx < 0 & wzx < 0, \"2. LL\", Typologie)\nTypologie <- ifelse(zx > 0 & wzx < 0, \"3. HL\", Typologie)\nTypologie <- ifelse(zx < 0 & wzx > 0, \"4. LH\", Typologie)\nTypologie <- ifelse(plocalMoranI > signif, \"Non sign\", Typologie)  # Non significatif\n## Enregistrement de la typologie dans un champ\nSRQc$TypoIMoran.D1pct <- Typologie\n## Couleurs\nCouleurs <- c(\"red\", \"blue\", \"lightpink\", \"skyblue2\", \"lightgray\")\nnames(Couleurs) <- c(\"1. HH\",\"2. LL\",\"3. HL\",\"4. LH\",\"Non sign\")\n## Cartographie\ntmap_mode(\"plot\")\ntm_shape(SRQc) + \n  tm_polygons(col = \"TypoIMoran.D1pct\", palette = Couleurs, \n              title =\"Autocorrélation spatiale locale\")+\n  tm_layout(frame = FALSE)\n```\n\n## Exercices du chapitre 3 {#sec-1203}\n\n### Exercice 1 {#sec-12031}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(tmap)\n## Importation des données \nArrondissements <-  st_read(dsn = \"data/chap03/Arrondissements.shp\", quiet=TRUE)\nIncidents <- st_read(dsn = \"data/chap03/IncidentsSecuritePublique.shp\", quiet=TRUE)\n## Changement de projection\nArrondissements <- st_transform(Arrondissements, crs = 3798) \nIncidents <- st_transform(Incidents, crs = 3798)\n## Couche pour les accidents\nAccidents <- subset(Incidents, Incidents$DESCRIPTIO %in% \n                      c(\"Accident avec blessés\", \"Accident mortel\"))\n## Coordonnées et projection cartographique\nxy <- st_coordinates(Accidents)\nProjCarto <- st_crs(Accidents)\n## Centre moyen\nCentreMoyen <- data.frame(X = mean(xy[,1]),\n                          Y = mean(xy[,2]))\nCentreMoyen <- st_as_sf(CentreMoyen, coords = c(\"X\", \"Y\"), crs = ProjCarto)\n# Distance standard combiné\nCentreMoyen$DS <- c(sqrt(mean((xy[,1] - mean(xy[,1]))**2 + \n                              (xy[,2] - mean(xy[,2]))**2)))\nCercleDS <- st_buffer(CentreMoyen, dist = CentreMoyen$DS)\nhead(CercleDS)\n```\n\n### Exercice 2 {#sec-12032}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(tmap)\n## Importation des données \nSR <- st_read(dsn = \"data/chap03/Recen2021Sherbrooke.gpkg\",\n              layer = \"DR_SherbSRDonnees2021\", quiet=TRUE)\n## Couche pour les accidents pour l'année 2021\nAcc2021 <- subset(Incidents, Incidents$DESCRIPTIO %in% \n                    c(\"Accident avec blessés\", \"Accident mortel\")\n                  & ANNEE==2021)\n## Nous nous assurons que les deux couches aient la même projection cartographique\nSR <- st_transform(SR, st_crs(Acc2021))\n## Calcul du nombre d'incidents par SR \nSR$Acc2021 <- lengths(st_intersects(SR, Acc2021))\n## Calcul du nombre de méfaits pour 1000 habitants\nSR$DensiteMAcc2021Hab <- SR$Acc2021 / (SR$SRpop_2021 / 1000)\n## Cartographie\ntm_shape(SR)+\n  tm_polygons(col=\"Acc2021\", style=\"pretty\", \n              title=\"Nombre pour 1000 habitants\",\n              border.col = \"black\", lwd = 1)+\n  tm_bubbles(size = \"DensiteMAcc2021Hab\", border.col = \"black\", alpha = .5,\n             col = \"aquamarine3\", title.size = \"Nombre\", scale = 1.5)+ \n  tm_layout(frame = FALSE)+tm_scale_bar(text.size = .5, c(0, 5, 10))\n```\n\n### Exercice 3 {#sec-12033}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(spatstat)\nlibrary(tmap)\nlibrary(terra)\n\n## Importation des données \nArrondissements <-  st_read(dsn = \"data/chap03/Arrondissements.shp\", quiet=TRUE)\nIncidents <- st_read(dsn = \"data/chap03/IncidentsSecuritePublique.shp\", quiet=TRUE)\n## Changement de projection\nArrondissements <- st_transform(Arrondissements, crs = 3798) \nIncidents <- st_transform(Incidents, crs = 3798)\n## Couche pour les méfaits pour l'année 2021\nM2021 <- subset(Incidents, DESCRIPTIO == \"Méfait\" & ANNEE==2021)\n## Pour accélérer les calculs, nous retenons uniquement l'arrondissement des Nations\n# Couche pour l'arrondissement des Nations\nArrDesNations <- subset(Arrondissements, NOM == \"Arrondissement des Nations\")\n# Sélection des accidents localisés dans l'arrondissement Des Nations\nRequeteSpatiale <- st_intersects(M2021, ArrDesNations, sparse = FALSE)\nM2021$Nations <- RequeteSpatiale[, 1]\nM2021Nations <- subset(M2021, M2021$Nations == TRUE)\n\n## Conversion des données sf dans le format de spatstat\n# la fonction as.owin est utilisée pour définir la fenêtre de travail\nfenetre <- as.owin(ArrDesNations)\n## Conversion des points au format ppp pour les différentes années\nM2021.ppp <- ppp(x = st_coordinates(M2021Nations)[,1],\n                 y = st_coordinates(M2021Nations)[,2],\n                 window = fenetre, check = T)\n\n## Kernel quadratique avec un rayon de 500 mètres et une taille de pixel de 50 mètres\nkdeQ <- density.ppp(M2021.ppp, sigma=500, eps=50, kernel=\"quartic\")\n## Conversion en raster\nRkdeQ <- terra::rast(kdeQ)*1000000\n## Projection cartographique\ncrs(RkdeQ) <- \"epsg:3857\"\n## Visualisation des résultats\ntmap_mode(\"plot\")\n  tm_shape(RkdeQ) + tm_raster(style = \"cont\", palette=\"Reds\", title = \"Gaussien\")+\n  tm_shape(M2021Nations) + tm_dots(col = \"black\", size = 0.01)+\n  tm_shape(ArrDesNations) + tm_borders(col = \"black\", lwd = 3)+\n  tm_layout(frame = F)\n```\n\n## Exercices du chapitre 4 {#sec-1204}\n\n### Exercice 1 {#sec-12041}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(tmap)\nlibrary(dbscan)\nlibrary(ggplot2)\n## Importation des données\nCollissions <- st_read(dsn = \"data/chap04/collisions.gpkg\", \n                       layer = \"CollisionsRoutieres\", \n                       quiet = T)\n## Collisions impliquant au moins une personne à vélo en 2020 et 2021\nColl.Velo <- subset(Collissions,\n                    Collissions$NB_VICTIMES_VELO > 0 &\n                      Collissions$AN %in% c(2020, 2021))\n## Coordonnées géographiques\nxy <- st_coordinates(Coll.Velo)\n## Graphique pour la distance au quatrième voisin le plus proche\nDistKplusproche <- kNNdist(xy, k = 4)\nDistKplusproche <- as.data.frame(sort(DistKplusproche, decreasing = FALSE))\nnames(DistKplusproche) <- \"distance\"\nggplot(data = DistKplusproche)+\n  geom_path(aes(x = 1:nrow(DistKplusproche), y = distance), size=1)+\n  labs(x = \"Points triés par ordre croissant selon la distance\",\n       y = \"Distance au quatrième point le plus proche\")+\n  geom_hline(yintercept=250, color = \"#08306b\", linetype=\"dashed\", size=1)+\n  geom_hline(yintercept=500, color = \"#00441b\", linetype=\"dashed\", size=1)+\n  geom_hline(yintercept=1000, color = \"#67000d\", linetype=\"dashed\", size=1)\n## DBSCAN avec les quatre distances\nset.seed(123456789)\ndbscan250  <- dbscan(xy, eps = 250, minPts = 4)\ndbscan500  <- dbscan(xy, eps = 500, minPts = 4)\ndbscan1000 <- dbscan(xy, eps = 1000, minPts = 4)\n## Affichage des résultats\ndbscan250\ndbscan500\ndbscan1000\n## Enregistrement dans la couche de points sf Coll.Velo\nColl.Velo$dbscan250 <- as.character(dbscan250$cluster)\nColl.Velo$dbscan500 <- as.character(dbscan500$cluster)\nColl.Velo$dbscan1000 <- as.character(dbscan1000$cluster)\n\nColl.Velo$dbscan250 <- ifelse(nchar(Coll.Velo$dbscan250) == 1,\n                              paste0(\"0\", Coll.Velo$dbscan250),\n                              Coll.Velo$dbscan250)\nColl.Velo$dbscan500 <- ifelse(nchar(Coll.Velo$dbscan500) == 1,\n                               paste0(\"0\", Coll.Velo$dbscan500),\n                               Coll.Velo$dbscan500)\nColl.Velo$dbscan1000 <- ifelse(nchar(Coll.Velo$dbscan1000) == 1,\n                               paste0(\"0\", Coll.Velo$dbscan1000),\n                               Coll.Velo$dbscan1000)\n## Extraction des agrégats\nAgregats.dbscan250  <- subset(Coll.Velo, dbscan250 != \"00\")\nAgregats.dbscan500  <- subset(Coll.Velo, dbscan500 != \"00\")\nAgregats.dbscan1000 <- subset(Coll.Velo, dbscan1000 != \"00\")\n## Cartographie des résultats\ntmap_mode(\"view\")\ntm_shape(Agregats.dbscan250)+tm_dots(col=\"dbscan250\", size = .05)\ntm_shape(Agregats.dbscan500)+tm_dots(col=\"dbscan500\", size = .05)\ntm_shape(Agregats.dbscan1000)+tm_dots(col=\"dbscan1000\", size = .05)\n```\n\n### Exercice 2 {#sec-12042}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(tmap)\nlibrary(dbscan)\nlibrary(ggplot2)\n## Importation des données\nCollissions <- st_read(dsn = \"data/chap04/collisions.gpkg\", layer = \"CollisionsRoutieres\")\n## Collisions impliquant au moins une personne à vélo en 2020 et 2021\nColl.Velo <- subset(Collissions,\n                    Collissions$NB_VICTIMES_VELO > 0 &\n                      Collissions$AN %in% c(2020, 2021))\n## Coordonnées géographiques\nxy <- st_coordinates(Coll.Velo)\nColl.Velo$x <- xy[,1]\nColl.Velo$y <- xy[,2]\n## Conversion du champ DT_ACCDN au format Date\nColl.Velo$DT_ACCDN <- as.Date(Coll.Velo$DT_ACCDN)\n## ST-DBSCAN avec eps1 = 500, esp2 = 30 et minpts = 4\nResultats.stdbscan <- stdbscan(x = Coll.Velo$x,\n                               y = Coll.Velo$y,\n                               time = Coll.Velo$DT_ACCDN,\n                               eps1 = 500,\n                               eps2 = 30,\n                               minpts = 4)\n## Enregistrement des résultats ST-DBSCAN dans la couche de points sf\nColl.Velo$stdbscan <- as.character(Resultats.stdbscan$cluster)\nColl.Velo$stdbscan <- ifelse(nchar(Coll.Velo$stdbscan) == 1,\n                             paste0(\"0\", Coll.Velo$stdbscan),\n                             Coll.Velo$stdbscan)\n## Nombre de points par agrégat avec la fonction table\ntable(Coll.Velo$stdbscan)\n## Sélection des points appartenant à un agrégat avec la fonction subset\nAgregats <- subset(Coll.Velo, stdbscan != \"00\")\n## Conversion de la date au format POSIXct\nAgregats$dtPOSIXct <- as.POSIXct(Agregats$DT_ACCDN, format = \"%Y/%m/%d\")\n## Tableau récapitulatif\nlibrary(\"dplyr\")  \nTableau.stdbscan <-\n  st_drop_geometry(Agregats) %>%\n  group_by(stdbscan) %>% \n  summarize(points = n(),\n            date.min = min(DT_ACCDN),\n            date.max = max(DT_ACCDN),\n            intervalle.jours = as.numeric(max(DT_ACCDN)-min(DT_ACCDN)))\n## Affichage du tableau\nprint(Tableau.stdbscan, n = nrow(Tableau.stdbscan))\n## Construction du graphique\nggplot(Agregats) + \n  geom_point(aes(x = dtPOSIXct, \n                 y = stdbscan, \n                 color = stdbscan),\n             show.legend = FALSE) +\n  scale_x_datetime(date_labels = \"%Y/%m\")+\n  labs(x= \"Temps\",\n       y= \"Identifiant de l'agrégat\",\n       title = \"ST-DBSCAN avec Esp1 = 1000, Esp2 = 21 et MinPts = 4\")\n## Création d'une couche pour les agrégats\nstdbcan.Agregats <- subset(Coll.Velo, stdbscan != \"00\")\n## Cartographie\ntmap_mode(\"view\")\n  tm_shape(stdbcan.Agregats)+\n    tm_dots(shape = 21, col=\"stdbscan\", size=.025, title = \"Agrégat\")\n```\n\n## Exercices du chapitre 5 {#sec-1205}\n\n### Exercice 1 {#sec-12051}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(tmap)\nlibrary(r5r)\n\nsetwd(\"data/chap05/Laval\")\nrJava::.jinit()\noptions(java.parameters = \"-Xmx2G\")\n\n# 1. Construction du réseau\ndossierdata <- paste0(getwd(),\"/_DataReseau\")\nlist.files(dossierdata)\nr5r_core <- setup_r5(data_path = dossierdata,\n                     elevation = \"TOBLER\",\n                     verbose = FALSE, overwrite = FALSE)\n\n# 2. Création de deux points\nPts <- data.frame(id = c(\"Station Morency\", \"Adresse 1\"),\n                  lon = c(-73.7199, -73.7183),\n                  lat = c(45.5585,  45.5861))\nPts <- st_as_sf(Pts, coords = c(\"lon\",\"lat\"), crs = 4326)\nStationMorency <- Pts[1,]\nAdresse1 <- Pts[2,]\n\n## 2.1. Trajets en automobile\nAuto.1 <- detailed_itineraries(r5r_core = r5r_core,\n                               origins = Adresse1,\n                               destinations = StationMorency,\n                               mode = \"CAR\",\n                               shortest_path = FALSE,\n                               drop_geometry = FALSE)\nAuto.2 <- detailed_itineraries(r5r_core = r5r_core,\n                               origins = StationMorency,\n                               destinations = Adresse1,\n                               mode = \"CAR\",\n                               shortest_path = FALSE,\n                               drop_geometry = FALSE)\n## 2.2. Trajets en vélo\nvelo.1 <- detailed_itineraries(r5r_core = r5r_core,\n                               origins = StationMorency,\n                               destinations = Adresse1,\n                               mode = \"BICYCLE\",\n                               bike_speed = 12,  # par défaut 12\n                               shortest_path = FALSE,\n                               drop_geometry = FALSE)\nvelo.2 <- detailed_itineraries(r5r_core = r5r_core,\n                               origins = Adresse1,\n                               destinations = StationMorency,\n                               mode = \"BICYCLE\",\n                               bike_speed = 12,  # par défaut 12\n                               shortest_path = FALSE,\n                               drop_geometry = FALSE)\n## 2.3. Trajets à pied\nmarche.1 <- detailed_itineraries(r5r_core = r5r_core,\n                                 origins = StationMorency,\n                                 destinations = Adresse1,\n                                 mode = \"WALK\",\n                                 walk_speed = 4.5,  # par défaut 3.6\n                                 shortest_path = FALSE,\n                                 drop_geometry = FALSE)\nmarche.2 <- detailed_itineraries(r5r_core = r5r_core,\n                                 origins = Adresse1,\n                                 destinations = StationMorency,\n                                 mode = \"WALK\",\n                                 walk_speed = 4.5,  # par défaut 12\n                                 shortest_path = FALSE,\n                                 drop_geometry = FALSE)\n\n## 2.4. Trajets en transport en commun\ndateheure.matin <- as.POSIXct(\"12-02-2024 08:00:00\",\n                              format = \"%d-%m-%Y %H:%M:%S\")\ndateheure.soir  <- as.POSIXct(\"12-02-2024 18:00:00\",\n                              format = \"%d-%m-%Y %H:%M:%S\")\n### Définir le temps de marche maximal\nminutes_marches_max <- 20\nTC.1 <- detailed_itineraries(r5r_core = r5r_core,\n                                 origins = Adresse1,\n                                 destinations = StationMorency,\n                                 mode = c(\"WALK\", \"TRANSIT\"),\n                                 max_walk_time = minutes_marches_max,\n                                 walk_speed = 4.5,\n                                 departure_datetime = dateheure.matin,\n                                 shortest_path = FALSE,\n                                 drop_geometry = FALSE)\nTC.2 <- detailed_itineraries(r5r_core = r5r_core,\n                                  origins = StationMorency,\n                                  destinations = Adresse1,\n                                  mode = c(\"WALK\", \"TRANSIT\"),\n                                  max_walk_time = minutes_marches_max,\n                                  walk_speed = 4.5,\n                                  departure_datetime = dateheure.soir,\n                                  shortest_path = FALSE,\n                                  drop_geometry = FALSE)\n\n\n# 4. Cartographie\n  # - Map1.Aller : Marche (de la résidence à la station de métro)\n  # - Map2.Aller : Vélo (de la résidence à la station de métro)\n  # - Map3.Aller : Auto (de la résidence à la station de métro)\n  # - Map4.Aller : Transport en commun (de la résidence à la station de métro)\ntmap_mode(view)\nMap1.Aller <- tm_shape(marche.1)+tm_lines(col=\"mode\", lwd = 3,\n                                      popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                     \"segment_duration\", \"distance\",\n                                                     \"total_duration\", \"total_distance\"))+\n              tm_shape(Adresse1)+tm_dots(col=\"green\", size = .15)+\n              tm_shape(StationMorency)+tm_dots(col=\"red\", size = .15)\n\nMap2.Aller <- tm_shape(velo.1)+tm_lines(col=\"mode\", lwd = 3,\n                                          popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                         \"segment_duration\", \"distance\",\n                                                         \"total_duration\", \"total_distance\"))+\n              tm_shape(Adresse1)+tm_dots(col=\"green\", size = .15)+\n              tm_shape(StationMorency)+tm_dots(col=\"red\", size = .15)\n\nMap3.Aller <- tm_shape(Auto.1)+tm_lines(col=\"mode\", lwd = 3,\n                                        popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                       \"segment_duration\", \"distance\",\n                                                       \"total_duration\", \"total_distance\"))+\n              tm_shape(Adresse1)+tm_dots(col=\"green\", size = .15)+\n              tm_shape(StationMorency)+tm_dots(col=\"red\", size = .15)\n\nMap4.Aller <- tm_shape(TC.1)+tm_lines(col=\"mode\", lwd = 3,\n                                        popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                       \"segment_duration\", \"distance\",\n                                                       \"total_duration\", \"total_distance\"))+\n              tm_shape(Adresse1)+tm_dots(col=\"green\", size = .15)+\n              tm_shape(StationMorency)+tm_dots(col=\"red\", size = .15)\n\ntmap_arrange(Map1.Aller, Map2.Aller, Map3.Aller, Map4.Aller, ncol = 2, nrow = 2)\n\n## Réaliser une figure avec quatre figures pour les trajets retour :\n  # - Map1.Retour : Marche (de la station de métro à la résidence)\n  # - Map2.Retour : Vélo (de la station de métro à la résidence)\n  # - Map3.Retour : Auto (de la station de métro à la résidence)\n  # - Map4.Retour : Transport en commun (de la station de métro à la résidence)\n\nMap1.Retour <- tm_shape(marche.2)+tm_lines(col=\"mode\", lwd = 3,\n                                          popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                         \"segment_duration\", \"distance\",\n                                                         \"total_duration\", \"total_distance\"))+\n  tm_shape(Adresse1)+tm_dots(col=\"red\", size = .15)+\n  tm_shape(StationMorency)+tm_dots(col=\"green\", size = .15)\n\nMap2.Retour <- tm_shape(velo.2)+tm_lines(col=\"mode\", lwd = 3,\n                                        popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                       \"segment_duration\", \"distance\",\n                                                       \"total_duration\", \"total_distance\"))+\n  tm_shape(Adresse1)+tm_dots(col=\"red\", size = .15)+\n  tm_shape(StationMorency)+tm_dots(col=\"green\", size = .15)\n\nMap3.Retour <- tm_shape(Auto.2)+tm_lines(col=\"mode\", lwd = 3,\n                                        popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                       \"segment_duration\", \"distance\",\n                                                       \"total_duration\", \"total_distance\"))+\n  tm_shape(Adresse1)+tm_dots(col=\"red\", size = .15)+\n  tm_shape(StationMorency)+tm_dots(col=\"green\", size = .15)\n\nMap4.Retour <- tm_shape(TC.2)+tm_lines(col=\"mode\", lwd = 3,\n                                      popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                     \"segment_duration\", \"distance\",\n                                                     \"total_duration\", \"total_distance\"))+\n  tm_shape(Adresse1)+tm_dots(col=\"red\", size = .15)+\n  tm_shape(StationMorency)+tm_dots(col=\"green\", size = .15)\n\ntmap_arrange(Map1.Retour, Map2.Retour, Map3.Retour, Map4.Retour, ncol = 2, nrow = 2)\n\n# 5. Arrêt de java\nr5r::stop_r5(r5r_core)\nrJava::.jgc(R.gc = TRUE)\n```\n\n### Exercice 2 {#sec-12052}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\n## Construction du réseau\nsetwd(\"data/chap05/Laval\")\nrJava::.jinit()\noptions(java.parameters = \"-Xmx2G\")\ndossierdata <- paste0(getwd(),\"/_DataReseau\")\nlist.files(dossierdata)\nr5r_core <- setup_r5(data_path = dossierdata,\n                     elevation = \"TOBLER\",\n                     verbose = FALSE, overwrite = FALSE)\n\n## Point pour la Station Morency\nStationMorency <- data.frame(id = \"Station Morency\",\n                             lon = -73.7199,\n                             lat = 45.5585,  45.5861)\nStationMorency <- st_as_sf(StationMorency, \n                           coords = c(\"lon\",\"lat\"), crs = 4326)\n\n# 1. Calcul d'isochrones à pied de 5, 10 et 15 minutes\nIso.Marche <- isochrone(r5r_core = r5r_core,\n                        origins = StationMorency,\n                        mode = \"WALK\",\n                        cutoffs = c(5, 10, 15),\n                        sample_size = .8,\n                        time_window = 120,\n                        progress = FALSE)\n# 1.2. Isochrone à vélo de 5, 10 et 15 minutes\nIso.Velo <- isochrone(r5r_core = r5r_core,\n                      origins = StationMorency,\n                      mode = \"BICYCLE\",\n                      cutoffs = c(10, 20, 30),\n                      sample_size = .8,\n                      time_window = 120,\n                      progress = FALSE)\n\n# 3. Cartographie les résultats\ntmap_mode(\"view\")\ntmap_options(check.and.fix = TRUE)\nCarte.Marche <- tm_shape(Iso.Marche)+\n                    tm_fill(col=\"isochrone\", \n                            alpha = .4, \n                            breaks = c(0, 5, 10, 15),\n                            title =\"Marche\",\n                            legend.format = list(text.separator = \"à\"))+\n                    tm_shape(StationMorency)+tm_dots(col=\"darkred\", size = .25)\n\nCarte.Velo <- tm_shape(Iso.Velo)+\n                    tm_fill(col=\"isochrone\", \n                            alpha = .4, \n                            breaks = c(0, 5, 10, 15),\n                            title =\"Vélo\",\n                            legend.format = list(text.separator = \"à\"))+\n                    tm_shape(StationMorency)+tm_dots(col=\"darkred\", size = .25)\n\n\ntmap_arrange(Carte.Marche, Carte.Velo, ncol = 2)\n\n# 4. Arrêt de java\nr5r::stop_r5(r5r_core)\nrJava::.jgc(R.gc = TRUE)\n```\n\n## Exercices du chapitre 6 {#sec-1206}\n\n### Exercice 1 {#sec-12061}\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(spNetwork)\nlibrary(future)\n\nfuture::plan(future::multisession(workers = 5))\n# Importation des données sur les collisions cycles et le réseau de rues\nCollisions <- st_read(dsn = \"data/chap06/Mtl/DonneesMTL.gpkg\", layer=\"CollisionsAvecCyclistes\", quiet=TRUE)\nReseauRues <- st_read(dsn = \"data/chap06/Mtl/DonneesMTL.gpkg\", layer=\"Rues\", quiet=TRUE)\nReseauRues$LineID <- 1:nrow(ReseauRues)\nLongueurKm <- sum(as.numeric(st_length(ReseauRues)))/1000\nCollisions <- st_transform(Collisions, st_crs(ReseauRues))\ncat(\"Informations sur les couches\",\n    \"\\n  Collisions avec cylistes :\", nrow(Collisions),\n    \"\\n  Réseau :\", round(LongueurKm,3), \"km\")\n# Cartographie\ntmap_mode(\"view\")\ntm_shape(ReseauRues) + tm_lines(\"black\") +\n  tm_shape(Collisions) + tm_dots(\"blue\", size = 0.025)+\ntm_scale_bar(c(0,1,2), position = 'left')+\n  tm_layout(frame = FALSE)\n\n\n## Évaluation des bandwidths de 100 à 1200 avec un saut de 50\neval_bandwidth <- bw_cv_likelihood_calc.mc(\n  bw_range = c(100,1200),\n  bw_step = 50,\n  lines = ReseauRues, \n  events = Collisions,\n  w = rep(1, nrow(Collisions)),\n  kernel_name = 'quartic',\n  method = 'discontinuous',\n  adaptive = FALSE,\n  max_depth = 10,\n  digits = 1,\n  tol = 0.1,\n  agg = 5,\n  grid_shape = c(5,5),\n  verbose = TRUE)\n\n## Graphique pour les bandwidths \nggplot(eval_bandwidth) + \n  geom_path(aes(x = bw, y = cv_scores)) + \n  geom_point(aes(x = bw, y = cv_scores), color = 'red')+\n  labs(x = \"Valeur de la bandwidth\", y = \"Valeur du CV\")\n```\n\n\n### Exercice 2 {#sec-12062}\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false \n#| eval: false\nlibrary(sf)\nlibrary(spNetwork)\nlibrary(future)\n## Création des lixels d'une longueur de 100 mètres\nlixels <- lixelize_lines(ReseauRues, 100, mindist = 50)\nlixels_centers <- spNetwork::lines_center(lixels)\n## Calcul de la NKDE continue\nintensity <- nkde.mc(lines = ReseauRues,\n                     events = Collisions,\n                     w = rep(1, nrow(Collisions)),\n                     samples = lixels_centers,\n                     kernel_name = 'quartic',\n                     bw = 500,\n                     adaptive = FALSE,\n                     method = 'continuous',\n                     max_depth = 8,\n                     digits = 1,\n                     tol = 0.1,\n                     agg = 5,\n                     verbose = FALSE,\n                     grid_shape = c(5,5))\nlixels$density <- intensity * 1000\n## Cartographie\ntm_shape(lixels) + \n  tm_lines(\"density\", lwd = 1.5, n = 7, style = \"fisher\",\n           legend.format = list(text.separator = \"à\"))+\n  tm_layout(frame=FALSE)\n```\n\n\n## Exercices du chapitre 7 {#sec-1207}\n\n### Exercice 1 {#sec-12071}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(spatialreg)\n# Matrice de contiguïté selon le partage d'un segment (Rook)\nload(\"data/chap06/DonneesLyon.Rdata\")\nRook <- poly2nb(LyonIris, queen=FALSE)\nRook <- poly2nb(LyonIris, queen=FALSE)\nW.Rook <- nb2listw(Rook, zero.policy=TRUE, style = \"W\")\n# Modèles\nformule <- \"PM25 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed\"\nModele.SLX <- lmSLX(formule, listw=W.Rook,  data = LyonIris)  # dataframe\nModele.SAR <- lagsarlm(formule, listw=W.Rook,  data = LyonIris,  type = 'lag')\nModele.SEM <- errorsarlm(formule, listw=W.Rook, data = LyonIris)\nModele.DurbinSpatial <- lagsarlm(formule, listw = W.Rook, data = LyonIris, type = \"mixed\")\nModele.DurbinErreur <- errorsarlm(formule, listw=W.Rook, data = LyonIris, etype = 'emixed')\n# Résultats des modèles\nsummary(Modele.SLX)\nsummary(Modele.SAR)\nsummary(Modele.SEM)\nsummary(Modele.DurbinSpatial)\nsummary(Modele.DurbinErreur)\n```\n\n### Exercice 2 {#sec-12072}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(mgcv)\nload(\"data/chap06/DonneesLyon.Rdata\")\n# Ajout des coordonnées x et y\nxy <- st_coordinates(st_centroid(LyonIris))\nLyonIris$X <- xy[,1]\nLyonIris$Y <- xy[,2]\n# Construction du modèle avec\nformule <- \"PM25 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed\"\nModele.GAM2 <- gam(PM25 ~  Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed+\n                           s(X, Y, k= 40),\n                          data = LyonIris)\nsummary(Modele.GAM2)\n```\n\n### Exercice 3 {#sec-12073}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(sf)\nlibrary(spgwr)\nload(\"data/chap06/DonneesLyon.Rdata\")\n# Ajout des coordonnées x et y\nxy <- st_coordinates(st_centroid(LyonIris))\nLyonIris$X <- xy[,1]\nLyonIris$Y <- xy[,2]\n# Optimisation du nombre de voisins avec le CV\nformule <- \"PM25 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed\"\nbwaCV.voisins  <- gwr.sel(formule,\n                          data = LyonIris,\n                          method = \"cv\",\n                          gweight=gwr.bisquare,\n                          adapt=TRUE,\n                          verbose = FALSE,\n                          RMSE = TRUE,\n                          longlat = FALSE,\n                          coords=cbind(LyonIris$X,LyonIris$Y))\n# Optimisation du nombre de voisins avec l'AIC\nformule <- \"PM25 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed\"\nbwaCV.voisins  <- gwr.sel(formule,\n                          data = LyonIris,\n                          method = \"AIC\",\n                          gweight=gwr.bisquare,\n                          adapt=TRUE,\n                          verbose = FALSE,\n                          RMSE = TRUE,\n                          longlat = FALSE,\n                          coords=cbind(LyonIris$X,LyonIris$Y))\n# Réalisation de la GWR\nModele.GWR <- gwr(formule,\n              data = LyonIris,\n              adapt=bwaCV.voisins,\n              gweight=gwr.bisquare,\n              hatmatrix=TRUE,\n              se.fit=TRUE,\n              coords=cbind(LyonIris$X,LyonIris$Y),\n              longlat=F)\n# Affichage des résultats\nModele.GWR\n```\n\n## Exercices du chapitre 8 {#sec-1208}\n\n### Exercice 1 {#sec-12081}\n\n```{r}\n#| echo: true \n#| message: false\n#| eval: false\nlibrary(rgeoda)\nlibrary(sf)\nlibrary(tmap)\n## Préparation des données\nload(\"data/Lyon.Rdata\")\nVarSocioEco <- c(\"Pct0_14\", \"Pct_65\", \"Pct_Img\", \"Pct_brevet\", \"NivVieMed\")\nData2 <- st_drop_geometry(LyonIris[VarSocioEco])\nqueen_w <- queen_weights(LyonIris)\n## Classification avec k = 4\nazp5_sa  <- azp_sa(p=4, w=queen_w, df=Data2, cooling_rate = 0.85)\nazp5_tab <- azp_tabu(p=4, w=queen_w, df=Data2, tabu_length = 10, conv_tabu = 10)\nskater5  <- rgeoda::skater(k=4, w=queen_w, df=Data2)\nredcap5  <- redcap(k = 4, w = queen_w, df = Data2, method = \"fullorder-wardlinkage\")\n## Cartographie des résultats\nLyonIris$SE.azp4_sa  <- as.character(azp5_tab$Clusters)\nLyonIris$SE.azp4_tab <- as.character(azp5_sa$Clusters)\nLyonIris$SE.skater4 <- as.character(skater5$Clusters)\nLyonIris$SE.recap4  <- as.character(redcap5$Clusters)\nCarte1 <- tm_shape(LyonIris)+tm_borders(col=\"gray\", lwd=.5)+\n  tm_fill(col=\"SE.azp4_sa\", palette = \"Set1\", title =\"\")+\n  tm_layout(frame=FALSE,  main.title = \"a. AZP-SA\",\n            main.title.position = \"center\", main.title.size = 1)\nCarte2 <- tm_shape(LyonIris)+tm_borders(col=\"gray\", lwd=.5)+\n  tm_fill(col=\"SE.azp4_tab\", palette = \"Set1\", title =\"\")+\n  tm_layout(frame=FALSE,  main.title = \"b. AZP-TABU\",\n            main.title.position = \"center\", main.title.size = 1)\nCarte3 <- tm_shape(LyonIris)+tm_borders(col=\"gray\", lwd=.5)+\n  tm_fill(col=\"SE.skater4\", palette = \"Set1\", title =\"\")+\n  tm_layout(frame=FALSE,  main.title = \"c. Skater\",\n            main.title.position = \"center\", main.title.size = 1)\nCarte4 <- tm_shape(LyonIris)+tm_borders(col=\"gray\", lwd=.5)+\n  tm_fill(col=\"SE.recap4\", palette = \"Set1\", title =\"\")+\n  tm_layout(frame=FALSE,  main.title = \"d. RECAP\",\n            main.title.position = \"center\", main.title.size = 1)\n\ntmap_arrange(Carte1, Carte2, Carte3, Carte4)\n```\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["css/quizlib.min.css"],"output-file":"12-Exercices.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.6.42","license":"CC BY-SA","crossref":{"lof-title":"Liste des figures","lot-title":"Listes des tableaux","fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleRefs.csl","colorlinks":true,"theme":{"light":["cosmo","css/r4ds.scss"]},"fontsize":"11pt","mainfont":"Helvetica Neue,Helvetica,Arial,sans-serif","monofont":"SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":100,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"pdflatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","filters":["lua/callout_custom_pdf.lua"],"output-file":"Méthodes_analyses_spatiales.pdf","toc":true,"toc-depth":4,"include-in-header":["tex-hacks/color-tables.tex","tex-hacks/code-font.tex","tex-hacks/fix-unicode-chars.tex","tex-hacks/image-on-title-page.tex","tex-hacks/callout.tex"]},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"block-headings":true,"license":"CC BY-SA","lang":"fr","crossref":{"lof-title":"Liste des figures","lot-title":"Listes des tableaux","fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleRefs.csl","documentclass":"scrbook","papersize":"letter","classoption":["open=any","twoside=false","french"],"hyperrefoptions":["pdfpagemode=UseOutlines","pdfdisplaydoctitle=true","pdfpagelayout=SinglePage","pdfstartpage=1"],"geometry":["top=20mm","left=15mm","right=15mm","heightrounded"],"fontfamily":"libertinus","fontfamilyoptions":["p"],"lof":true,"lot":true,"code-block-border-left":false,"fontsize":"11pt","urlcolor":"Green4","citecolor":"violet","linkcolor":"violet","colorlinks":true,"header-includes":["\\usepackage{xparse}","\\renewcommand{\\thepart}{} % Enlever numérotation des parties","\\setcounter{secnumdepth}{3} % Activer la numérotation des sections jusqu'au niveau des sous-sections"]},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}