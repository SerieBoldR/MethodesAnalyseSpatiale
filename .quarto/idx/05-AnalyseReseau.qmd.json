{"title":"Mesures d'accessibilité spatiale selon différents modes de transport","markdown":{"headingText":"Mesures d'accessibilité spatiale selon différents modes de transport","headingAttr":{"id":"sec-chap05","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nDans ce chapitre, nous voyons comment construire un réseau multimode (voiture, marche, vélo, transport en commun) pour calculer différentes mesures d'accessibilité dans R. Aussi, nous discutons de la notion d'accessibilité à un service, notamment des cinq dimensions identifiées par Penchansky et Thomas [-@penchansky1981concept], de l'accessibilité réelle versus l'accessibilité potentielle et de l'accessibilité spatiale versus l'accessibilité aspatiale [@luo2003measures].\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n\n::: bloc_package-body\n-   Pour importer et manipuler des fichiers géographiques :\n    -   `sf` pour importer et manipuler des données vectorielles.\n    -   `terra` pour importer et manipuler des données matricielles.\n-   Pour construire des cartes et des graphiques :\n    -   `tmap` est certainement le meilleur *package* pour la cartographie.\n    -   `ggplot2` pour construire des graphiques.\n-   Pour construire un réseau :\n    -   `osmextract` pour extraire des fichiers OpenStreetMap.\n    -   `gtfstools` pour valider la structure d'un fichier GTFS.\n    -   `R5R` pour calculer des trajets et des matrices origines-destinations selon différents modes de transport.\n-   Pour manipuler les données :\n    -   `dplyr` pour calculer des moyennes pondérées.\n:::\n:::\n\n## Notions relatives à l'analyse de réseau {#sec-051}\n\n### Définition d'un réseau {#sec-0511}\n\nUn réseau est un ensemble de lignes connectées par des nœuds -- voies ferrées, voies routières, canalisations d'eau ou de gaz, fleuves et affluents drainant une région, etc. -- reliant un territoire (@fig-fig1Reseau). Pour un réseau routier, l'information sémantique rattachée tant aux lignes (sens de circulation, vitesse autorisée, rues piétonnières, pistes cyclables, etc.) qu'aux nœuds (types d'intersection, autorisation de virage à gauche, etc.) est utilisée pour modéliser un réseau.\n\n![Réseau : un ensemble de lignes connectées par des nœuds](images/Chap05/Reseau.png){#fig-fig1Reseau width=\"15%\" fig-align=\"center\"}\n\n### Principaux problèmes résolus en analyse de réseau {#sec-0512}\n\nL'analyse de réseau permet de résoudre trois principaux problèmes (@fig-fig2PrincipauxPbs) :\n\n-   Trouver le trajet le plus court ou le plus rapide entre deux points, basé sur [l'algorithme de Dijkstra](https://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra) [-@dijkstra1959note].\n\n-   Trouver la route optimale comprenant plusieurs arrêts ([problème du voyageur de commerce](https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_voyageur_de_commerce#:~:text=En%20informatique%2C%20le%20probl%C3%A8me%20du,une%20et%20une%20seule%20fois.)).\n\n-   Définir des zones de desserte autour d'une origine, basé aussi sur l'algorithme de Dijkstra.\n\n![Trois principaux problèmes résolus en analyse de réseau](images/Chap05/PrincipauxProblemes.png){#fig-fig2PrincipauxPbs width=\"100%\" fig-align=\"center\"}\n\nÀ cela s'ajoutent quatre autres problèmes :\n\n-   Trouver les *k* services les plus proches à partir d'une origine (@fig-fig3AutresPrincipauxPbs, a).\n\n-   Construire une matrice de distance origines-destinations (@fig-fig3AutresPrincipauxPbs, b), dont l'intérêt principal est de permettre par la suite le calcul de n'importe quelle mesure d'accessibilité.\n\n-   Résoudre le [problème de tournées de véhicules](https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_tourn%C3%A9es_de_v%C3%A9hicules) dont l'objectif est d'optimiser les tournées d'une flotte de véhicules en fonction des ressources disponibles, de la localisation des clients, des lieux de dépôt de marchandises, etc.\n\n-   Réaliser un [modèle localisation-affectation](https://en.wikipedia.org/wiki/Location-allocation) dont l'objectif est d'optimiser la localisation d'un ou plusieurs nouveaux équipements en fonction de la demande, et ce, en minimisant la distance agrégée entre les points d'offre et de demande. Par exemple, une région ayant 15 hôpitaux desservant deux millions d'habitants souhaiterait ajouter trois autres établissements. En fonction de l'offre existante (hôpitaux pondérés par le nombre de lits), de la distribution spatiale de la population et de la localisation des sites potentiels des trois hôpitaux, il s'agit de choisir ceux qui minimisent la distance entre les points d'offre et de demande.\n\n![Autres problèmes résolus en analyse de réseau](images/Chap05/PrincipauxAutresProblemes.png){#fig-fig3AutresPrincipauxPbs width=\"80%\" fig-align=\"center\"}\n\nCes problèmes peuvent être résolus selon différents modes de transport, à savoir le chemin le plus rapide en véhicule motorisé, à pied, en vélo et en transport en commun (@fig-TypesDistancesTransport).\n\n![Chemin le plus rapide selon différents modes de transport](images/Chap05/TypesDistances.png){#fig-TypesDistancesTransport width=\"60%\" fig-align=\"center\"}\n\n### Analyse de réseau et entités polygonales {#sec-0513}\n\nVous avez compris que les problèmes présentés plus haut sont réalisés à partir d'entités spatiales ponctuelles. Pour estimer le trajet le plus court ou le plus rapide entre un point et un polygone (un parc urbain par exemple), il faut préalablement le convertir en point. Plusieurs solutions sont envisageables [@apparicio2006measuring] :\n\n-   Calculer le trajet entre le point et le centroïde du parc (@fig-ReseauPointPolygone, a). Le centroïde est alors rattaché au tronçon de rue le plus proche. Cette solution est peu précise : plus la superficie du polygone est grande, plus l'imprécision augmente.\n\n-   Si le parc a plusieurs entrées, il suffit de les positionner le long du périmètre et de calculer les trajets à partir de ces points.\n\n-   Si le parc n'a pas d'entrée, il convient de positionner des points le long du périmètre, espacés d'une distance prédéterminée (@fig-ReseauPointPolygone, b). Bien qu'elle soit longue à calculer, cette solution est bien plus précise. Par exemple, avec des points espacés de 20 mètres le long du périmètre du parc, l'erreur maximale est de 10 mètres.\n\n![Méthode pour déterminer le trajet le plus court entre une entité ponctuelle et une entité polygonale](images/Chap05/ReseauPointPolygone.png){#fig-ReseauPointPolygone width=\"90%\" fig-align=\"center\"}\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Modélisation d'un réseau dans un logiciel SIG (systèmes d'information géographique)**\n:::\n\n::: bloc_aller_loin-body\nIl est aussi possible de construire un réseau dans un logiciel SIG (QGIS et ArcGIS Pro par exemple). Pour une description détaillée de la construction d'un réseau selon différents modes de transport (voiture, marche, vélo et transport en commun) dans un SIG, consultez l'article d'Apparicio *et al.* [-@ApparicioGelbrevisited].\n:::\n:::\n\n## Construction d'un réseau avec R5R {#sec-052}\n\nPour construire un réseau pour différents modes de transport dans R, nous utilisons le *package* `R5R` [@packageR5R]. Il existe d'autres *packages*, notamment `opentripplanner` [@packageOpenTripPlanner] qui a été largement utilisé ces dernières années. Étant plus rapide, `R5R` s'impose actuellement comme la solution la plus efficace pour calculer des trajets à travers un réseau de rues selon différents modes de transport.\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Documentation du *package*`R5R`**\n:::\n\n::: bloc_notes-body\nNous vous conseillons vivement de lire la documentation de `R5R` sur [le site de CRAN](https://cran.r-project.org/web/packages/r5r/index.html), notamment les nombreuses vignettes présentant des exemples d'analyses avec du code R très bien documenté.\n:::\n:::\n\n### Extraction des données spatiales pour R5R {#sec-0521}\n\nPour construire un réseau multimode, `R5R` a besoin de trois fichiers qui doivent être localisés dans le même dossier (@fig-DonneesReseauR5R) :\n\n1.  un fichier *pbf* (*Protocolbuffer Binary Format*) pour les données d'OpenStreetMap.\n2.  un ou plusieurs fichiers *GTFS* (*General Transit Feed Specification*) pour les flux relatifs aux transports en commun.\n3.  un fichier *GeoTIFF* d'élévation.\n\nNotez que ce dernier fichier est optionnel. Toutefois, pour calculer des trajets à pied ou à vélo, il est préférable de tenir compte de la pente, surtout dans une ville comme Sherbrooke!\n\n![Trois types de données nécessaires pour modéliser un réseau dans R5R](images/Chap05/DonneesPourR5R.png){#fig-DonneesReseauR5R width=\"55%\" fig-align=\"center\"}\n\n```{r}\n#| echo: false\n#| message: false \n#| warning: false \n#| eval: true\n\n#' un petit bloc invisible pour indiquer la bonne version de la JDK à utiliser lorsque je JG compile le livre\nif(Sys.getenv('JAVA_HOME') == \"C:\\\\Program Files\\\\Java\\\\jdk-11\"){\n  Sys.setenv(JAVA_HOME='C:/Program Files/Java/jdk-21')\n}\n```\n\n\n#### Extraction d'un fichier OpenStreetMap {#sec-05212}\n\nPour récupérer un fichier OpenStreetMap (OSM, format *pbf*), nous utilisons deux fonctions du *package* `osmextract` [@osmextractpackage] :\n\n-   `oe_match` pour repérer le fichier OSM pour la région de l'Estrie.\n-   `oe_download` pour télécharger le fichier OSM pour la région de l'Estrie.\n\n```{r}\n#| echo: true\n#| message: false \n#| warning: false \n#| eval: false\n\nlibrary(osmextract)\n## Identification du fichier OSM (format pbf) pour l'Estrie\nEstrie = oe_match(place=\"Estrie\", provider = \"openstreetmap_fr\")\n## Téléchargement du fichier OSM (format pbf) pour l'Estrie\noe_download(\n  file_url = Estrie$url,\n  file_size = Estrie$file_size,\n  provider = \"openstreetmap_fr\",\n  download_directory = \"data/chap05/__TempOSM\")\n```\n\nLe fichier OSM téléchargé plus haut couvre la région de l'Estrie. À notre connaissance, il n'existe pas de solution pour découper un fichier *pbf* dans R. Par conséquent, nous récupérons les coordonnées minimales et maximales de l'enveloppe d'une zone tampon de 5000 mètres autour de la couche de la ville de Sherbrooke. Puis, pour découper le fichier *pbf*, nous utilisons l'outil [**osmconvert64-0.8.8p.exe**](https://wiki.openstreetmap.org/wiki/Osmconvert). Le code ci-dessous renvoie les quatre coordonnées de l'enveloppe.\n\n```{r}\n#| echo: true\n#| message: false \n#| warning: false \n\nlibrary(sf)\nlibrary(tmap)\n## Importation du polygone pour la ville de Sherbrooke avec sf\nSherbrooke <- st_read(dsn = \"data/chap05/AutresDonnees/Sherbrooke.shp\", quiet=TRUE)\n## Création d'une zone tampon de 5 km\nzone <- st_buffer(Sherbrooke, dist = 5000)\n## Changement de la projection en 4326\nzone <- st_transform(zone, 4326)\n## Création de l'enveloppe autour de la couche\nenveloppe = st_bbox(zone)\n## Visualisation des coordonnées minimales et maximales\ncat(paste0(\"Minimum longitude : \", round(enveloppe[1],4),\n           \"\\n Minimum latitude : \", round(enveloppe[2],4),\n           \"\\n Maximum longitude : \", round(enveloppe[3],4),\n           \"\\n Maximum latitude : \", round(enveloppe[4],4)\n    ))\n```\n\nL'application **Osmconvert** est disponible pour [Windows](https://wiki.openstreetmap.org/wiki/Osmconvert#Windows) et [Linux](https://wiki.openstreetmap.org/wiki/Osmconvert#Linux). Pour découper un fichier avec les coordonnées latitude/longitude minimales et maximales avec **Osmconvert**, nous écrivons une commande système et l'exécutons avec la fonction `system`. Pour utiliser le code ci-dessous, vous devez avoir préalablement téléchargé **Osmconvert** et connaitre son emplacement.\n\n```{r}\n#| echo: true\n#| message: false \n#| warning: false \n#| eval: false\n\n## Préparation des chemins\npath_to_osm_convert <- paste0(getwd(),'/data/chap05/__TempOSM/osmconvert64-0.8.8p.exe')\npath_to_big_osm <- paste0(getwd(),'/data/chap05/__TempOSM/openstreetmap_fr_estrie-latest.osm.pbf')\npath_to_small_osm <- paste0(getwd(),'/data/chap05/__TempOSM/openstreetmap_fr_estrie-latest.osm_01.pbf')\n## Écriture de la commande\ncommande <- paste0('\"',path_to_osm_convert, '\" \"',\n                   path_to_big_osm, '\" -b=',paste0(enveloppe[1:4], collapse = ','), \n                   ' -o=\"',path_to_small_osm,'\"')\n```\n\nUne fois que la commande est écrite, nous l'exécutons.\n\n```{r}\n#| echo: true\n#| message: false \n#| warning: false \n#| results: hide \n#| eval: false\n\nsystem(commande)\n```\n\nNotez qu'il est possible d'obtenir le même résultat avec l'application [**Osmosis**](https://wiki.openstreetmap.org/wiki/Osmosis). Il s'agit d'un outil rédigé en **Java** et qui dispose de fonctionnalités similaires à celles de **Osmconvert**. Puisqu'il est rédigé en **Java**, il peut être utilisé sur davantage de plateformes qu'**Osmconvert**.\n\n#### Construction d'un fichier *GeoTIFF* pour l'élévation {#sec-05213}\n\nPour créer un fichier *GeoTIFF* pour l'élévation, nous utilisons les modèles numériques de terrain (MNT) du [ministère des Ressources naturelles et des Forêts](https://www.donneesquebec.ca/recherche/dataset/modeles-numeriques-d-altitude-a-l-echelle-de-1-20-000).\n\n```{r}\n#| echo: true\n#| message: true \n#| eval: false \n\nlibrary(terra)\n## Couche polygonale sf pour la ville de Sherbrooke\n# Shapefile pour les régions du Québec au 1/20000\n# https://www.donneesquebec.ca/recherche/dataset/decoupages-administratifs/resource/b368d470-71d6-40a2-8457-e4419de2f9c0\nSherbrooke <- st_read(dsn = \"data/chap05/AutresDonnees/Sherbrooke.shp\", quiet=TRUE)\nSherbrooke <- st_buffer(Sherbrooke, dist = 5000)\n## Feuillets pour les MNT au 1/20000\n## Importation du shapefile des feuillets\n## (https://www.donneesquebec.ca/recherche/dataset/modeles-numeriques-d-altitude-a-l-echelle-de-1-20-000/resource/2df157af-74cf-4b53-af9d-1d3ccee0d6e1)\nFeuillets <- st_read(dsn = \"data/chap05/AutresDonnees/Index_MNT20k.shp\", quiet=TRUE)\n### Nous nous assurons que les deux couches ont la même projection, soit EPSG 4326\nSherbrooke <- st_transform(Sherbrooke, st_crs(Feuillets))\n### Sélection des feuillets qui intersectent le polygone de l'Estrie\nRequeteSpatiale <- st_intersects(Feuillets, Sherbrooke, sparse = FALSE)\nFeuillets$Intersect <-  RequeteSpatiale[, 1]\nFeuilletsSherbrooke <- subset(Feuillets,Intersect == TRUE)\n\n## Téléchargement des GRIDS\n### Création d'un dossier temporaire pour les MNT\ndir.create(paste0(\"data/chap05/AutresDonnees/MNT\"))\ngrids <- FeuilletsSherbrooke$GRID\ni = 0\nfor (e in grids) {\n  i = i+1\n  # Téléchargement\n  Fichier <- substr(e, 88, nchar(e))\n  Chemin <-  \"data/chap05/AutresDonnees/MNT\"\n  CheminFichier <- paste0(Chemin, \"/\", Fichier)\n  download.file(e, destfile = CheminFichier)\n  # Décompression du fichier zip\n  unzip(CheminFichier, exdir = Chemin)\n  # suppression du zip\n  unlink(CheminFichier)\n}\n\n## Importation des GRIDS avec le package Terra\nFichier1 <- substr(grids, 88, 98)\nFichier2 <- paste0(substr(tolower(Fichier1), 1, 7),\n                    substr(Fichier1, 9, 11))\nNomsFichiers <- paste0(\"data/chap05/AutresDonnees/MNT/\",\n                        Fichier1, \"/\",\n                        Fichier2)\nrlist <- list()\nfor(e in NomsFichiers) {\n print(e)\n rasterGrid <- terra::rast(e)\n rlist[[length(rlist)+1]] <- rasterGrid\n}\n## Création d'une mosaique avec les GRIDS\nrsrc <- terra::sprc(rlist)\nMosaicSherbrooke <- mosaic(rsrc)\nMosaicSherbrooke\n\n# Pour réduire la taille du fichier d’élévation, nous arrondissons les valeurs au mètre\nMosaicSherbrooke <- round(MosaicSherbrooke)\n\n## Exporter en GeoTIFF\nterra::writeRaster(MosaicSherbrooke, \n                  \"data/chap05/_DataReseau/Elevation.tif\",\n                  filetype = \"GTiff\", \n                  datatype = 'INT2U',\n                  overwrite = TRUE)\n\n## Suppression des GRIDS\ndossier <- \"data/chap05/AutresDonnees/MNT/\"\nf <- list.files(dossier, include.dirs = FALSE, full.names = TRUE, recursive = TRUE)\nfile.remove(f)\nd <- list.dirs(dossier)\nunlink(d, recursive = TRUE)\n```\n\nLe fichier d'élévation ainsi construit est présenté à la @fig-figMNT.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-figMNT\n#| fig-align: center\n#| fig-cap: \"Modèle numérique d'élévation au 1/20000 pour la région de Sherbrooke\"\n#| out-width: 65%\nMosaicSherbrooke <- terra::rast(\"data/chap05/_DataReseau/Elevation.tif\")\nterra::plot(MosaicSherbrooke)\n```\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n***Package* `elevatr` pour extraire des images d'élévation pour une région donnée**\n:::\n\n::: bloc_aller_loin-body\nPlus haut, nous avons utilisé des modèles numériques de terrain (MNT) du [ministère des Ressources naturelles et des Forêts](https://www.donneesquebec.ca/recherche/dataset/modeles-numeriques-d-altitude-a-l-echelle-de-1-20-000) pour construire un fichier *GeoTIFF* pour l'élévation pour la ville de Sherbrooke (Québec). Pour d'autres régions du monde, vous pouvez aussi utiliser le *package* `elevatr` [@hollister2017elevatr] pour extraire une image d'élévation à partir de l'[API OpenTopography](https://opentopography.org/developers/).\n\nPour plus d'information, consultez cette [vignette](https://cran.r-project.org/web/packages/elevatr/vignettes/introduction_to_elevatr.html),\n:::\n:::\n\n\n#### Extraction et validation d'un fichier GTFS {#sec-05214}\n\nLe fichier GTFS pour la Société de Transport de Sherbrooke est disponible à l'adresse suivante : <https://gtfs.sts.qc.ca:8443/gtfs/client/GTFS_clients.zip>. Pour le télécharger, nous utilisons la fonction `download.file`.\n\n```{r}\n#| echo: true\n#| message: true \n#| eval: false \nurl <- \"https://gtfs.sts.qc.ca:8443/gtfs/client/GTFS_clients.zip\"\ndestfile <- \"data/chap05/_DataReseau/GTFS_clients.zip\"\ndownload.file(url, destfile)\n```\n\nPour s'assurer du bon fonctionnement d'un GTFS dans `r5r`, il faut préalablement valider la structure du fichier. Dans un premier temps, vous pouvez valider la structure générale de votre GTFS en utilisant l'outil en ligne [gtfs-validator](https://gtfs-validator.mobilitydata.org/) proposé par l'organisation *MobilityData*. Dans un second temps, il convient de s'assurer que les types de lignes utilisés font partie des types standards définis par [Google](https://developers.google.com/transit/gtfs/reference?hl=fr#routestxt), soit avec l'un des numéros suivants : 0, 1, 2, 3, 4, 5, 6, 7, 11, 12. Si votre GTFS contient des lignes de transport en commun provenant par exemple des [types étendus](https://developers.google.com/transit/gtfs/reference/extended-route-types?hl=fr), `r5r` renverra une erreur.\n\nNous vous proposons ci-dessous une fonction qui remplace les types problématiques dans un GTFS. Le plus simple est de les remplacer par un type *bus* (3), ce qui n'affectera pas les trajets estimés.\n\n```{r}\n#| echo: true\n#| message: true \n\nlibrary(gtfstools)\n## Fonction\nclean_gtfs_types <- function(gtfs_file, replace_by = 3){\n  # Lecture du GTFS\n  seed <- gtfstools::read_gtfs(gtfs_file)\n  print(unique(seed$routes$route_type))\n  # Vérification des types de routes\n  seed$routes$route_type <- ifelse(\n    seed$routes$route_type %in% c(0:7,11,12),\n    seed$routes$route_type,\n    replace_by\n  )\n  # Réécriture du fichier GTFS avec la modification\n  gtfstools::write_gtfs(seed, gtfs_file)\n}\n## Appel de la fonction\ndestfile <- \"data/chap05/_DataReseau/GTFS_clients.zip\"\nclean_gtfs_types(destfile)\n```\n\nPour ce fichier, le seul type de ligne utilisé est le numéro 3, soit des lignes de bus.\n\n### Construction du réseau avec R5R {#sec-0522}\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**`R5R` et JDK Java et allocation de la mémoire**\n:::\n\n::: bloc_attention-body\nLe *package* `R5R` utilise la version 21 de la JDK de Java (*Java Development Kit*). Vous devez préalablement la [télécharger](https://adoptium.net/) et l'installer sur votre ordinateur. Les deux lignes de code ci-dessous permettent de vérifier si elle est bien installée sur votre ordinateur.\n\n```{r}\n#| echo: true\n#| message: true \n## Vérification que la JDK version 21 est bien installée\nrJava::.jinit()\nrJava::.jcall(\"java.lang.System\", \"S\", \"getProperty\", \"java.version\")\n```\n\nIl est fortement conseillé d'augmenter la mémoire allouée au processus JAVA, surtout si vous souhaitez calculer des matrices origines-destinations de grande taille. Par exemple, la commande `options(java.parameters = \"-Xmx2G\")` permet d'augmenter la mémoire disponible pour JAVA à deux gigaoctets. Si votre ordinateur ne manque pas de mémoire vive (16, 32 ou 64 gigaoctets), n'hésitez pas à augmenter ce paramètre (par exemple, `options(java.parameters = \"-Xmx8G\")`).\n\nSi vous avez plusieurs version de la jdk présentent sur votre ordinateur, vous pouvez aussi indiquer **en tout début de script, avant de charger le moindre package** laquelle utiliser avec l'option suivante: \n\n```{r}\n#| eval: false\n#| message: false \nSys.setenv(JAVA_HOME='C:/Program Files/Java/jdk-21')\n```\n\nNotez que vous devez bien sûr adapter le chemin vers votre propre installation de la jdk-21.\n\n:::\n:::\n\nNous utilisons la fonction `setup_r5` pour construire un réseau multimode à partir des trois fichiers :\n\n-   Le fichier OSM (`openstreetmap_fr_sherbrooke.pbf`).\n\n-   Le fichier GTFS pour la Société de Transport de Sherbrooke (`GTFS_clients.zip`).\n\n-   Le fichier d'élévation pour la région de Sherbrooke (`Elevation.tif`).\n\nNotez les paramètres suivants pour la fonction `setup_r5` :\n\n-   `data_path` pour définir le dossier dans lequel sont présents les trois fichiers.\n\n-   `elevation = \"TOBLER\"` pour utiliser la fonction d'impédance de Tobler pour la marche et le vélo qui prend en compte la pente.\n\n-   `overwrite = FALSE` pour ne pas écraser le réseau s'il est déjà construit. La construction d'un réseau peut être très longue dépendamment de la taille des trois fichiers (OSM, GTFS, élévation). Par conséquent, n'oubliez pas de spécifier cette option si votre réseau a déjà été construit.\n\n```{r}\n#| echo: true\n#| message: false \nlibrary(r5r)\n## Allocation de la mémoire pour Java\noptions(java.parameters = \"-Xmx2G\")\n## Construction du réseau R5R\nr5r_core <- setup_r5(data_path = \"data/chap05/_DataReseau/\",\n                     elevation = \"TOBLER\",\n                     verbose = FALSE, overwrite = FALSE)\n```\n\nLa fonction `setup_r5` a créé deux nouveaux fichiers (*network.dat* et *network_settings.json*) qui sont utilisés par le *package* `r5r` pour les analyses de réseau.\n\n```{r}\n#| echo: true\n#| message: true \n## Liste des fichiers dans le dossier \nlist.files(\"data/chap05/_DataReseau/\")\n```\n\n### Calcul d'itinéraires avec R5R selon le mode de transport {#sec-0523}\n\nPour calculer un trajet, nous utilisons la fonction `detailed_itineraries` dont les paramètres sont décrits dans l'encadré ci-dessous.\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Paramètres de la fonction `detailed_itineraries`**\n:::\n\n::: bloc_attention-body\n-   **`r5r_core`**: le réseau créé avec la fonction `setup_r5()` décrite plus haut.\n-   **`origins`**: un point `sf` projeté en WGS84 ou un `data.frame` comprenant les colonnes `id`, `lon` et `lat`.\n-   **`destinations`**: un point `sf` projeté en WGS84 ou un `data.frame` comprenant les colonnes `id`, `lon` et `lat`.\n-   **`mode`**: un vecteur de type caractères définissant les modes de transport dont les principaux sont :\n    -   `\"WALK\"` pour la marche.\n    -   `\"BICYCLE\"` pour le vélo.\n    -   `\"CAR\"` pour l'automobile.\n    -   `\"c(\"WALK\",TRANSIT\")` pour la marche et le transport en commun.\n-   **`departure_datetime`**: un objet `POSIXct` définissant la date et l'heure de départ à utiliser si vous souhaitez calculer un trajet en transport en commun.\n-   **`max_walk_time=inf`**: un nombre entier définissant le temps de marche maximal en minutes pour chaque segment du trajet. La valeur par défaut est sans limite (`Inf`).\n-   **`max_bike_time = Inf`**: un nombre entier définissant le temps maximal à vélo en minutes.\n-   **`max_car_time = Inf`**: un nombre entier définissant le temps maximal en automobile en minutes.\n-   **`max_trip_duration = 120`**: un nombre entier définissant le temps maximal du trajet qui est fixé à 120 minutes par défaut. Par conséquent, tout trajet d'une durée supérieure à ce seuil ne sera pas calculé.\n-   **`walk_speed = 3.6`**: une valeur numérique définissant la vitesse moyenne de marche qui est fixée par défaut à 3,6 km/h. Ce seuil est très conservateur et pourrait être augmenté à 4,5 km/h.\n-   **`bike_speed = 12`**: une valeur numérique définissant la vitesse moyenne à vélo qui est fixée par défaut à 12 km/h. Ce seuil est aussi très conservateur et pourrait être augmenté à 15 ou 16 km/h.\n-   **`max_lts = 2`**: un nombre entier de 1 à 4 qui indique le niveau de stress lié à la circulation que les cyclistes sont prêts à tolérer. Une valeur de 1 signifie que les cyclistes n'emprunteront que les rues les plus calmes, tandis qu'une valeur de 4 indique que les cyclistes peuvent emprunter n'importe quelle route.\n    -   `max_lts = 1`: tolérable pour les enfants.\n    -   `max_lts = 2`: tolérable pour la population adulte en général.\n    -   `max_lts = 3`: tolérable pour les cyclistes enthousiastes et confiants.\n    -   `max_lts = 4`: tolérable uniquement pour les cyclistes intrépides.\n-   **`drop_geometry = FALSE`**: si ce paramètre est fixé à TRUE, la géométrie du trajet ne sera pas incluse.\n:::\n:::\n\n#### Calcul d'itinéraires selon les modes de transport actif {#sec-05231}\n\nDans un premier temps, nous calculons des trajets à vélo entre les deux localisations suivantes :\n\n-   Le point `Pt.W` situé à l'intersection de la rue Wellington et de la Côte de l'Acadie (45,38947; -71,88393).\n\n-   Le point `Pt.D` situé à l'intersection des rues Darche et Dorval (45,38353; -71,89169).\n\n```{r}\n#| echo: true\n#| message: true \n## Création d'une couche sf avec les deux points\nPts <- data.frame(id = c(\"Rue Wellington S.\", \"Rue Darche\"),\n                         lat = c( 45.38947,  45.38353),\n                         lon = c(-71.88393, -71.89169)\n                         )\nPts <- st_as_sf(Pts, coords = c(\"lon\",\"lat\"), crs = 4326)\nPt.W <- Pts[1,]\nPt.D <- Pts[2,]\n```\n\nAvec la fonction `detailed_itineraries`, les durées sont estimées à respectivement six et huit minutes (@fig-TrajetsVelo). Bien que le chemin emprunté soit le même, cet écart s'explique par la Côte de l'Acadie, soit l'un des tronçons de rue les plus pentus de la ville de Sherbrooke.\n\n```{r}\n## Trajets en vélo\nvelo.1 <- detailed_itineraries(r5r_core = r5r_core,\n                               origins = Pt.W,\n                               destinations = Pt.D,\n                               mode = \"BICYCLE\", # Vélo\n                               bike_speed = 12,\n                               shortest_path = FALSE,\n                               drop_geometry = FALSE)\nvelo.2 <- detailed_itineraries(r5r_core = r5r_core,\n                               origins = Pt.D,\n                               destinations = Pt.W,\n                               mode = \"BICYCLE\", # Vélo\n                               bike_speed = 12,\n                               shortest_path = FALSE,\n                               drop_geometry = FALSE)\nvelo.1\nvelo.2\n```\n\nPour visualiser les trajets, nous utilisons le *package* `tmap` en mode `view`. Notez qu'un clic sur le trajet fait apparaître une fenêtre surgissante.\n\n```{r}\n#| echo: true\n#| message: true \n#| eval: false \nlibrary(tmap)\n# Cartographie des trajets avec tmap\ntmap_mode(\"view\")\nCarte1 <- tm_shape(velo.1)+\n  tm_lines(col=\"black\", lwd = 2, \n           popup.vars = c(\"mode\", \"from_id\", \"to_id\", \"segment_duration\", \"distance\"))+\n  tm_shape(Pt.W)+tm_dots(col=\"green\", size = .15)+\n  tm_shape(Pt.D)+tm_dots(col=\"red\", size = .15)\nCarte2 <- tm_shape(velo.2)+\n  tm_lines(col=\"black\", lwd = 2,\n           popup.vars = c(\"mode\", \"from_id\", \"to_id\", \"segment_duration\", \"distance\"))+\n  tm_shape(Pt.D)+tm_dots(col=\"green\", size = .15)+\n  tm_shape(Pt.W)+tm_dots(col=\"red\", size = .15)\ntmap_arrange(Carte1, Carte2, ncol = 2)\n```\n\n![Trajets à vélo entre les deux destinations](images/Chap05/TrajetsVelo.png){#fig-TrajetsVelo width=\"100%\" fig-align=\"center\"}\n\nDans un second temps, nous calculons les trajets à pied avec les deux mêmes localisations qui sont estimées à 16 et 21 minutes (@fig-TrajetsMarche).\n\n```{r}\n#| echo: false\n#| message: true \n#| eval: false \nmarche.1 <- detailed_itineraries(r5r_core = r5r_core,\n                                 origins = Pt.W,\n                                 destinations = Pt.D,\n                                 mode = \"WALK\", # Marche\n                                 walk_speed = 4.5,  # par défaut 3.6\n                                 shortest_path = FALSE,\n                                 drop_geometry = FALSE)\nmarche.2 <- detailed_itineraries(r5r_core = r5r_core,\n                                 origins = Pt.D,\n                                 destinations = Pt.W,\n                                 mode = \"WALK\", # Marche\n                                 walk_speed = 4.5,\n                                 shortest_path = FALSE,\n                                 drop_geometry = FALSE)\n# Cartographie des trajets avec tmap\nCarte3 <- tm_shape(marche.1)+\n  tm_lines(col=\"black\", lwd = 2,\n           popup.vars = c(\"mode\", \"from_id\", \"to_id\", \"segment_duration\", \"distance\"))+\n  tm_shape(Pt.W)+tm_dots(col=\"green\", size = .15)+\n  tm_shape(Pt.D)+tm_dots(col=\"red\", size = .15)\nCarte4 <- tm_shape(marche.2)+\n  tm_lines(col=\"black\", lwd = 2,\n           popup.vars = c(\"mode\", \"from_id\", \"to_id\", \"segment_duration\", \"distance\"))+\n  tm_shape(Pt.D)+tm_dots(col=\"green\", size = .15)+\n  tm_shape(Pt.W)+tm_dots(col=\"red\", size = .15)\ntmap_arrange(Carte3, Carte4, ncol = 2)\n```\n\n![Trajets à pied entre les deux destinations](images/Chap05/TrajetsMarche.png){#fig-TrajetsMarche width=\"100%\" fig-align=\"center\"}\n\n#### Calcul d'itinéraires en automobile {#sec-05232}\n\nNous calculons ici l'itinéraire entre le campus principal de l'[Université de Sherbrooke](https://www.usherbrooke.ca/) et une localisation (45,4220308; -71,881828). Nous fixons alors `mode = \"CAR\"` pour la fonction `detailed_itineraries`. Les trajets sont respectivement estimés à 21,7 et 18,8 minutes à destination et au départ du campus principal.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\nUDeS <- data.frame(id = \"Campus principal\", lon = -71.929526, lat = 45.378017)\nUDeS <- st_as_sf(UDeS, coords = c(\"lon\",\"lat\"), crs = 4326)\nPoint <- data.frame(id = \"Départ\", lon = -71.881828, lat = 45.4220308)\nPoint <- st_as_sf(Point, coords = c(\"lon\",\"lat\"), crs = 4326)\n\nAuto.Aller <- detailed_itineraries(r5r_core = r5r_core,\n                                 origins = Point,\n                                 destinations = UDeS,\n                                 mode = \"CAR\", # Automobile\n                                 shortest_path = FALSE,\n                                 drop_geometry = FALSE)\nAuto.Retour <- detailed_itineraries(r5r_core = r5r_core,\n                               origins = UDeS,\n                               destinations = Point,\n                               mode = \"CAR\", # Automobile\n                               shortest_path = FALSE,\n                               drop_geometry = FALSE)\nAuto.Aller\nAuto.Retour\n```\n\nBien entendu, les deux trajets sont différents en raison des sens de circulation (@fig-TrajetsAuto).\n\n```{r}\n#| echo: true\n#| message: true \n#| eval: false \n# Cartographie des trajets avec tmap\nCarte1 <- tm_shape(Auto.Aller)+\n  tm_lines(col=\"black\", lwd = 2,\n           popup.vars = c(\"mode\", \"from_id\", \"to_id\", \"segment_duration\", \"distance\"))+\n  tm_shape(Point)+tm_dots(col=\"green\", size = .15)+\n  tm_shape(UDeS)+tm_dots(col=\"red\", size = .15)\nCarte2 <- tm_shape(Auto.Retour)+\n  tm_lines(col=\"black\", lwd = 2,\n           popup.vars = c(\"mode\", \"from_id\", \"to_id\", \"segment_duration\", \"distance\"))+\n  tm_shape(Point)+tm_dots(col=\"red\", size = .15)+\n  tm_shape(UDeS)+tm_dots(col=\"green\", size = .15)\n# Figure avec les deux cartes\ntmap_arrange(Carte1, Carte2)\n```\n\n![Trajets en voiture entre les deux destinations](images/Chap05/TrajetsAuto.png){#fig-TrajetsAuto width=\"100%\" fig-align=\"center\"}\n\n#### Calcul d'itinéraires en transport en commun {#sec-05233}\n\nPour le calcul d'itinéraires en transport en commun, nous devons fixer une heure de départ et un temps de marche maximal pour chaque segment du trajet réalisé à pied, soit :\n\n-   du domicile à l'arrêt de bus le plus proche;\n-   entre deux arrêts de bus de lignes différentes;\n-   du dernier arrêt de bus à la destination finale.\n\nDans le code ci-dessous, nous fixons les heures de départ et d'arrivée à 8 h et à 18 h pour le 24 avril 2025 et un temps de marche maximal de 20 minutes.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n### Définition de la journée et de l'heure de départ\ndateheure.matin <- as.POSIXct(\"24-04-2025 08:00:00\",\n                               format = \"%d-%m-%Y %H:%M:%S\")\n\ndateheure.soir  <- as.POSIXct(\"24-04-2025 18:00:00\",\n                               format = \"%d-%m-%Y %H:%M:%S\")\n### Définition du temps de marche maximal\nminutes_marches_max <- 20\n```\n\nToujours avec la fonction `detailed_itineraries`, nous modifions les paramètres comme suit :\n\n-   `mode = c(\"WALK\", \"TRANSIT\")` pour le transport en commun.\n\n-   `walk_speed = 4.5` pour une vitesse moyenne à la marche de 4,5 km/h.\n\n-   `departure_datetime = dateheure.matin` pour un départ le 24 avril 2025 à 8 h.\n\n-   `departure_datetime = dateheure.soir` pour un départ le 24 avril 2025 à 18 h.\n\n-   `max_walk_time = minutes_marches_max` pour un temps maximal de marche de 20 minutes.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\nTC.Aller <- detailed_itineraries(r5r_core = r5r_core,\n                                   origins = Point,\n                                   destinations = UDeS,\n                                   mode = c(\"WALK\", \"TRANSIT\"),\n                                   max_walk_time = minutes_marches_max,\n                                   walk_speed = 4.5,\n                                   departure_datetime = dateheure.matin,\n                                   shortest_path = FALSE,\n                                   drop_geometry = FALSE)\n\nTC.Retour <- detailed_itineraries(r5r_core = r5r_core,\n                                    origins = UDeS,\n                                    destinations = Point,\n                                    mode = c(\"WALK\", \"TRANSIT\"),\n                                    max_walk_time = minutes_marches_max,\n                                    walk_speed = 4.5,\n                                    departure_datetime = dateheure.soir,\n                                    shortest_path = FALSE,\n                                    drop_geometry = FALSE)\n```\n\nPour l'option 1, la durée du trajet à 8 h vers l'Université de Sherbrooke est estimée à 52,8 minutes avec trois segments :\n\n-   Un premier segment de 8,6 minutes et 661 mètres à pied.\n\n-   Un second de 41,0 minutes et 10,862 km en autobus (ligne 8).\n\n-   Un troisième de 1,8 minutes et 127 mètres à pied.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n#TC.Aller\nsubset(TC.Aller, option == 1)\n```\n\nPour l'option 1, la durée du trajet à 18 h au départ de l'Université de Sherbrooke est estimée à 51,8 minutes avec trois segments :\n\n-   Un premier segment de 2,0 minutes et 150 mètres à pied.\n\n-   Un second de 33,0 minutes et 11,207 km en autobus (ligne 8).\n\n-   Un troisième de 9,5 minutes et 750 mètres à pied.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\nTC.Retour\n```\n\nLes deux trajets en transport en commun sont représentés à la @fig-TrajetsTC.\n\n```{r}\n#| echo: true\n#| message: false \n#| eval: false\ntmap_mode(\"view\")\nCarte1 <- tm_shape(subset(TC.Aller, option == 1))+\n            tm_lines(col=\"mode\", lwd = 3,\n                     popup.vars = c(\"mode\", \"from_id\", \"to_id\", \n                                    \"segment_duration\", \"distance\",\n                                    \"total_duration\", \"total_distance\"))+\n  tm_shape(Point)+tm_dots(col=\"green\", size = .15)+\n  tm_shape(UDeS)+tm_dots(col=\"red\", size = .15)+\n  tm_view(view.legend.position = c(\"left\", \"top\"))\n\nCarte2 <- tm_shape(subset(TC.Retour, option == 1))+\n              tm_lines(col=\"mode\", lwd = 3,\n                       popup.vars = c(\"mode\", \"from_id\", \"to_id\", \n                                      \"segment_duration\", \"distance\",\n                                      \"total_duration\", \"total_distance\"))+\n  tm_shape(Point)+tm_dots(col=\"red\", size = .15)+\n  tm_shape(UDeS)+tm_dots(col=\"green\", size = .15)+\n  tm_view(view.legend.position = c(\"left\", \"top\"))\n\ntmap_arrange(Carte1, Carte2, ncol = 2)\n```\n\n![Trajets en transport en commun entre les deux destinations](images/Chap05/TrajetsTC.png){#fig-TrajetsTC width=\"100%\" fig-align=\"center\"}\n\n### Délimitation d'isochrones avec R5R selon le mode de transport {#sec-0524}\n\nLe fonction `isochrone` du *package* `R5R` permet de délimiter des zones de desserte selon la distance-temps et différents modes de transport. Ses paramètres sont d'ailleurs les mêmes que ceux de la fonction `detailed_itineraries`, à l'exception de :\n\n-   Il n'y a pas de paramètre `destinations` puisque l'isochrone est uniquement délimité à partir de points d'origines (`origins`).\n\n-   Le paramètre `cutoffs = c(0, 15, 30)` permet de définir différentes isochrones en minutes.\n\n-   Le paramètre `sample_size` est utilisé pour tracer les isochrones. Variant de 0,2 à 1, sa valeur par défaut de 0,8 signifie que 80 % des nœuds du réseau de transport sont utilisés pour tracer l'isochrone. Plus cette valeur est proche de 1, plus l'isochrone est précise, mais plus sa vitesse de calcul est longue.\n\nDans l'exemple ci-dessous, nous calculons plusieurs isochrones à partir du campus principal de l'Université de Sherbrooke en fonction du mode transport (@fig-Isochrones) :\n\n1.  Trois isochrones de 10, 20 et 30 minutes à pied.\n\n2.  Trois isochrones de 10, 20 et 30 minutes en vélo.\n\n3.  Trois isochrones de 5, 10 et 20 minutes en automobile.\n\n4.  Deux isochrone de 20 et 40 minutes en transport en commun le 24 avril 2025 à 18 h avec un durée maximale de marche de 15 minutes.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: false\n#| warning: false\n## Point pour l'université de Sherbrooke\nUDeS <- data.frame(id = \"Campus principal\", lon = -71.929526, lat = 45.378017)\nUDeS <- st_as_sf(UDeS, coords = c(\"lon\",\"lat\"), crs = 4326)\ntmap_mode(\"view\")\ntmap_options(check.and.fix = TRUE)\n## Trois isochrones à pied de 10, 20 et 30 minutes\nIsochrome.marche <- isochrone(r5r_core,\n                      origins = UDeS,\n                      mode = \"WALK\",\n                      cutoffs = c(10, 20, 30),\n                      sample_size = .8,\n                      time_window = 120,\n                      progress = FALSE)\n\nCarte.Marche <- tm_shape(Isochrome.marche)+\n                    tm_fill(col=\"isochrone\", \n                            alpha = .4, \n                            breaks = c(0, 10, 20, 30),\n                            title =\"Marche\",\n                            legend.format = list(text.separator = \"à\"))+\n                    tm_shape(UDeS)+tm_dots(col=\"darkred\", size = .25)\n\n## Trois isochrones à vélo de 10, 20 et 30 minutes\nIsochrome.velo <- isochrone(r5r_core,\n                      origins = UDeS,\n                      mode = \"BICYCLE\",\n                      cutoffs = c(10, 20, 30),\n                      sample_size = .8,\n                      time_window = 120,\n                      progress = FALSE)\n\nCarto.Velo <- tm_shape(Isochrome.velo)+\n                    tm_fill(col=\"isochrone\", \n                            alpha = .4, \n                            breaks = c(0, 10, 20, 30),\n                            title =\"Vélo\",\n                            legend.format = list(text.separator = \"à\"))+\n                    tm_shape(UDeS)+tm_dots(col=\"darkred\", size = .25)\n\n## Trois isochrones en auto de 5, 10 et 20 minutes\nIsochrome.auto <- isochrone(r5r_core,\n                      origins = UDeS,\n                      mode = \"CAR\",\n                      cutoffs = c(5, 10, 20),\n                      sample_size = 1,\n                      time_window = 120,\n                      progress = FALSE)\n\nCarto.Auto <- tm_shape(Isochrome.auto)+\n                    tm_fill(col=\"isochrone\", \n                            alpha = .4, \n                            breaks = c(0, 5, 10, 20),\n                            title =\"Automobile\",\n                            legend.format = list(text.separator = \"à\"))+\n                    tm_shape(UDeS)+tm_dots(col=\"darkred\", size = .25)\n\n## Deux isochrones en transport en commun de 20, 40 et 60 minutes\ndateheure.soir  <- as.POSIXct(\"24-04-2025 08:00:00\",\n                              format = \"%d-%m-%Y %H:%M:%S\")\nIsochrome.tc <- isochrone(r5r_core,\n                      origins = UDeS,\n                      mode = c(\"WALK\", \"TRANSIT\"),\n                      max_walk_time = 15,\n                      departure_datetime = dateheure.soir,\n                      cutoffs = c(20, 40),\n                      sample_size = 1,\n                      time_window = 120,\n                      progress = FALSE)\n\nCarto.TC <- tm_shape(Isochrome.tc)+\n                    tm_fill(col=\"isochrone\", \n                            alpha = .4, \n                            breaks = c(0, 20, 40),\n                            title =\"Transport en commun\",\n                            legend.format = list(text.separator = \"à\"))+\n                    tm_shape(UDeS)+tm_dots(col=\"darkred\", size = .25)\n## Figure avec les quatre cartes\ntmap_arrange(Carte.Marche, Carto.Velo,\n             Carto.Auto, Carto.TC,\n             ncol = 2, nrow = 2)\n```\n\n![Isochrones selon les quatre modes de transport](images/Chap05/Isochrones.png){#fig-Isochrones width=\"100%\" fig-align=\"center\"}\n\n### Calcul de matrices OD selon différents modes de transport {#sec-0525}\n\nPour calculer des matrices origines-destinations selon différents modes de transport, nous utilisons la fonction `travel_time_matrix` dont les paramètres sont quasi les mêmes que la `detailed_itineraries` ([section @sec-0523]). Dans le code ci-dessous, nous importons 284 adresses tirées aléatoirement et les supermarchés présents sur le territoire de la ville de Sherbrooke.\n\n```{r}\n#| echo: true\n#| message: true \n## Importation des couches\nAdresses <- st_read(dsn = \"data/Chap05/AutresDonnees/Commerces.gpkg\",\n                        layer = \"AdressesAleatoires\", quiet = TRUE)\nsupermarches <- st_read(dsn = \"data/Chap05/AutresDonnees/Commerces.gpkg\",\n                        layer = \"supermarche\", quiet = TRUE)\n## Nombre de distances à calculer\nnO = nrow(Adresses)\nnD = nrow(supermarches)\nNOD = nO * nD\ncat(\"Origines (O) :\", nO, \"adresses\",\n    \"\\n Destinations (D) :\", nD, \"supermarchés\",\n    \"\\n Distances OD à calculer = \", NOD)\n## Origines et destinations\nOrigines <- Adresses\nOrigines$id <- as.character(Adresses$id)\nOrigines$lat <- st_coordinates(Adresses)[,2]\nOrigines$lon <- st_coordinates(Adresses)[,1]\nDestinations <- supermarches\nDestinations$id <- supermarches$osm_id\nDestinations$lat <- st_coordinates(supermarches)[,2]\nDestinations$lon <- st_coordinates(supermarches)[,1]\nnames(Destinations)[1] <- \"id\"\n```\n\nPar la suite, nous calculons les différentes matrices OD :\n\n-   **`matriceOD.Auto`** avec `mode = \"CAR\"`.\n\n-   **`matriceOD.Marche`** avec `mode = \"WALK\"`, `walk_speed = 4.5` et `max_trip_duration = 60`. La durée du trajet est limitée à 60 minutes avec une vitesse moyenne de 4,5 km/h.\n\n-   **`matriceOD.Velo`** avec `mode = \"BICYCLE\"`, `bike_speed = 15` et `max_trip_duration = 60`. La durée du trajet est limitée à 60 minutes avec une vitesse moyenne de 15 km/h.\n\n-   **`matriceOD.TC`** avec `mode = \"c(\"WALK\", \"TRANSIT\")\"`, `walk_speed = 4.5`, `max_walk_time = 30`, `max_trip_duration = 120` et `departure_datetime = dateheure.soir`. La durée du trajet est limitée à 60 minutes avec une vitesse moyenne de marche de 4,5 km/h et une durée maximale de 30 minutes pour chaque segment à la marche. L'heure de départ a été fixée comme suit : `dateheure.soir  <- as.POSIXct(\"04-05-2023 18:00:00\", format = \"%d-%m-%Y %H:%M:%S\")`.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Matrice OD en voiture\nt1 <-Sys.time()\nmatriceOD.Auto <- travel_time_matrix(r5r_core = r5r_core,\n                                     origins = Origines,\n                                     destinations = Destinations,\n                                     mode = \"CAR\")\nt2 <-Sys.time()\nduree.auto = as.numeric(difftime(t2, t1), units = \"secs\")\n## Matrice OD à la marche\nt1 <-Sys.time()\nmatriceOD.Marche <- travel_time_matrix(r5r_core = r5r_core,\n                                       origins = Origines,\n                                       destinations = Destinations,\n                                       mode = \"WALK\",\n                                       walk_speed = 4.5,  # valeur par défaut 3.6\n                                       max_trip_duration = 60, # 1 heure de marche maximum\n                                       max_walk_time = Inf)\nt2 <-Sys.time()\nduree.marche = as.numeric(difftime(t2, t1), units = \"secs\")\n## Matrice OD en vélo\nt1 <-Sys.time()\nmatriceOD.Velo <- travel_time_matrix(r5r_core = r5r_core,\n                                     origins = Origines,\n                                     destinations = Destinations,\n                                     mode = \"BICYCLE\",\n                                     bike_speed = 15,\n                                     max_trip_duration = 60,\n                                     max_bike_time = Inf)\nt2 <-Sys.time()\nduree.velo = as.numeric(difftime(t2, t1), units = \"secs\")\n## Matrice OD en transport en commun\ndateheure.soir  <- as.POSIXct(\"24-04-2025 08:00:00\",\n                              format = \"%d-%m-%Y %H:%M:%S\")\nt1 <-Sys.time()\nmatriceOD.TC <- travel_time_matrix(r5r_core = r5r_core,\n                                   origins = Origines,\n                                   destinations = Destinations,\n                                   mode = c(\"WALK\", \"TRANSIT\"),\n                                   walk_speed = 4.5,\n                                   max_walk_time = 30,\n                                   max_trip_duration = 120,\n                                   departure_datetime = dateheure.soir)\nt2 <-Sys.time()\nduree.tc = as.numeric(difftime(t2, t1), units = \"secs\")\n```\n\nLes temps de calcul des différentes matrices sont reportés ci-dessous.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\ncat(\"Temps de calcul des matrices :\", \n     \"\\n Voiture : \", round(duree.auto,2), \"secondes\",\n     \"\\n Marche : \", round(duree.marche,2), \"secondes\",\n     \"\\n Vélo : \", round(duree.velo,2), \"secondes\",\n     \"\\n Transport en commun : \", round(duree.tc,2), \"secondes\")\n```\n\nUne fois les matrices obtenues, nous les enregistrons dans un fichier `Rdata`.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\nsave(matriceOD.Auto, matriceOD.Marche, \n     matriceOD.Velo, matriceOD.TC,\n     file=\"data/chap05/Resultats/MatricesOD.Rdata\")\n```\n\nÀ partir de ces matrices, nous extrayons la valeur minimale pour chacune des adresses pour les quatre modes de transport. Puis, nous opérons une jointure attributaire avec la couche des adresses aléatoires avec la fonction `merge`.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Création d'un vecteur pour la distance au supermarché le plus proche \nSupermarchePlusProche.Auto <- aggregate(travel_time_p50 ~ from_id, matriceOD.Auto, min)\nSupermarchePlusProche.Pied <- aggregate(travel_time_p50 ~ from_id, matriceOD.Marche, min)\nSupermarchePlusProche.Velo <- aggregate(travel_time_p50 ~ from_id, matriceOD.Velo, min)\nSupermarchePlusProche.tc   <- aggregate(travel_time_p50 ~ from_id, matriceOD.TC, min)\n## Changement des noms des champs\nnames(SupermarchePlusProche.Auto) <- c(\"id\", \"SupPlusProcheAuto\")\nnames(SupermarchePlusProche.Pied) <- c(\"id\", \"SupPlusProchePied\")\nnames(SupermarchePlusProche.Velo) <- c(\"id\", \"SupPlusProcheVelo\")\nnames(SupermarchePlusProche.tc)   <- c(\"id\", \"SupPlusProcheTC\")\n## Jointure avec la couche des adresses\nAdresses <- merge(Adresses, SupermarchePlusProche.Auto, by =\"id\", all.x=TRUE)\nAdresses <- merge(Adresses, SupermarchePlusProche.Pied, by =\"id\", all.x=TRUE)\nAdresses <- merge(Adresses, SupermarchePlusProche.Velo, by =\"id\", all.x=TRUE)\nAdresses <- merge(Adresses, SupermarchePlusProche.tc, by =\"id\", all.x=TRUE)\n```\n\nFinalement, nous utilisons le *package* `tmap` pour cartographier les résultats et réaliser une figure avec la fonction `tmap_arrange`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CartoAdressesSupPlusProche\n#| fig-align: center\n#| fig-cap: Supermarché le plus proche en minutes selon le mode de transport\n#| out-width: 100%\n\n## Importation des arrondissements de la ville de Sherbrooke\narrondissements <- st_read(dsn = \"data/Chap05/AutresDonnees/Arrondissements.shp\", \n                           quiet=TRUE)\n## Construction des cartes\ntmap_mode(\"plot\")\nmax.auto <- max(Adresses$SupPlusProcheAuto,na.rm=TRUE)\nCarte1 <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(Adresses)+\n            tm_dots(col=\"SupPlusProcheAuto\", \n                    border.lwd = 1,\n                    style = \"fixed\",\n                    breaks = c(0,5,10,max.auto),\n                    palette=\"YlOrRd\",\n                    size = .2, \n\t\t\t\t\tlegend.format = list(text.separator = \"à\"),\n                    title=\"Voiture\")+\n          tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_layout(legend.format = list(text.separator = \"à\"),\n                    frame = FALSE, legend.outside = TRUE)\n\nmax.pied <- max(Adresses$SupPlusProchePied,na.rm=TRUE)\nCarte2 <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(Adresses)+\n            tm_dots(col=\"SupPlusProchePied\", \n                    border.lwd = 1,\n                    style = \"fixed\",\n                    breaks = c(0,5,10,15,20,30,45, max.pied),\n                    palette=\"YlOrRd\",\n                    size = .2, \n                    title=\"Marche\",\n                    textNA = \"Plus de 60\")+\n          tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_layout(legend.format = list(text.separator = \"à\"),\n                    frame = FALSE, legend.outside = TRUE)\n\nmax.velo <- max(Adresses$SupPlusProcheVelo,na.rm=TRUE)\nCarte3 <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(Adresses)+\n            tm_dots(col=\"SupPlusProcheVelo\", \n                    border.lwd = 1,\n                    style = \"fixed\",\n                    breaks = c(0,5,10,20,30,45,max.velo),\n                    palette=\"YlOrRd\",\n                    size = .2, \n                    title=\"Vélo\",\n                    textNA = \"Plus de 60\")+\n          tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_layout(legend.format = list(text.separator = \"à\"),\n                    frame = FALSE, legend.outside = TRUE)\n\nmax.tc <- max(Adresses$SupPlusProcheTC,na.rm=TRUE)\nCarte4 <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(Adresses)+\n            tm_dots(col=\"SupPlusProcheTC\", \n                    border.lwd = 1,\n                    style = \"fixed\",\n                    breaks = c(0,10,15,20,25,max.tc),\n                    palette=\"YlOrRd\",\n                    size = .2, \n                    title=\"Bus\",\n                    textNA = \"Plus de 60\")+\n          tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_layout(legend.format = list(text.separator = \"à\"),\n                    frame = FALSE, legend.outside = TRUE)\n\n## Figure avec les quatre cartes\ntmap_arrange(Carte1, Carte2, Carte3, Carte4)\n```\n\n## Mesures d'accessibilité {#sec-053}\n\n### Notion d'accessibilité {#sec-0531}\n\nDans un article fondateur intitulé *The concept of access: definition and relationship to consumer satisfaction*, Roy Penchansky et William Thomas [-@penchansky1981concept] ont identifié cinq dimensions fondamentales au concept d'accessibilité aux services de santé :\n\n1.  **L'accessibilité spatiale** (*accessibility*) renvoie à la proximité géographique du service par rapport à la population.\n\n2.  **La disponibilité** (*availability*) renvoie à la quantité et aux types de services offerts selon les besoins des individus.\n\n3.  **L'organisation** (*accommodation*) renvoie au fonctionnement du service (horaires, délais d'attente, prises de rendez-vous, etc.).\n\n4.  **L'accessibilité financière** (*affordability*) renvoie aux coûts du service qui peuvent constituer une barrière financière pour les personnes défavorisées.\n\n5.  **L'accessibilité socioculturelle** (*acceptability*) renvoie à l'acceptation et à l'adaptation des services aux différences sociales, culturelles ou linguistiques des personnes.\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Les cinq dimensions de l'accessibilité et le type de service analysé**\n:::\n\n::: bloc_objectif-body\nL'importance accordée à chacune des cinq dimensions identifiées par Roy Penchansky et William Thomas [-@penchansky1981concept] varie en fonction du type de service à l'étude. Prenons l'exemple des parcs urbains :\n\n1.  L'**accessibilité spatiale**, soit la proximité géographique est sans aucun doute une dimension très importante.\n\n2.  La **disponibilité** (*availability*) renvoie à différents équipements (aires de jeu pour enfants, terrains de sports, etc.) présents dans le parc.\n\n3.  La dimension de l'**organisation** (*accommodation*) risque d'être moins importante puisque les heures d'ouverture et les modalités de réservation de certains types de terrain de sport (comme un terrain de tennis) ne varient habituellement pas d'un parc à l'autre au sein d'une même ville.\n\n4.  La dimension de l'**accessibilité financière** (*affordability*) risque aussi d'être moins importante puisque l'accès au parc et à ses équipements est gratuit, à l'exception de certains terrains de sport très spécialisés.\n\n5.  L'**accessibilité socioculturelle** (*acceptability*) peut être une dimension très importante et renvoie à l'acceptation des différences sociales, générationnelles et ethnoculturelles des personnes utilisatrices des parcs.\n:::\n:::\n\nPlus récemment, la notion d'accessibilité à un service a été définie selon deux dimensions, soit **réelle (ou révélée)** ou **potentielle** et **spatiale** ou **aspatiale** [@guagliardo2004spatial; @luo2003measures; @khan1992integrated] :\n\n1.  L'accessibilité réelle renvoie à l'utilisation effective des services tandis que l'accessibilité potentielle renvoie à leur utilisation probable.\n\n2.  L'accessibilité spatiale renvoie à l'importance de la séparation spatiale entre l'offre et la demande de services en tant que barrière ou facilitateur, et l'accessibilité aspatiale (dimensions financière, socioculturelle, organisationnelle) se concentre sur les barrières ou facilitateurs non géographiques [@luo2003measures; @ngui2011optimizing].\n\nPar conséquent, la notion d'accessibilité aux services de santé englobe quatre catégories principales : **l'accessibilité spatiale réelle**, **l'accessibilité aspatiale réelle**, **l'accessibilité spatiale potentielle** et **l'accessibilité aspatiale potentielle** [@khan1992integrated]. Par exemple, si nous questionnons un groupe de personnes sur la localisation des parcs qu'elles fréquentent habituellement, nous pourrions dresser un portrait sur leur accessibilité spatiale réelle aux parcs. Par contre, si nous calculons le nombre d'hectares de parcs présents dans un rayon de 20 minutes de marche autour de leur domicile, nous pourrions évaluer leur accessibilité spatiale potentielle aux parcs.\n\n### Accessibilité spatiale potentielle {#sec-0532}\n\nDans le cadre de cette section, nous abordons l'accessibilité spatiale potentielle qui suppose de paramétrer quatre éléments : l'unité spatiale de référence, la méthode d'agrégation, la ou les mesures d'accessibilité et le type de distance [@ApparicioGelbrevisited].\n\n#### Unité spatiale de référence {#sec-05321}\n\nL'entité spatiale de référence correspond aux entités spatiales pour lesquelles l'accessibilité sera évaluée et cartographiée qui pourrait être :\n\n-   Les centroïdes des bâtiments résidentiels d'une ville donnée.\n\n-   Des entités polygonales représentant des zones résidentielles comme des [aires de diffusion](https://www150.statcan.gc.ca/n1/pub/92-195-x/2011001/geo/da-ad/def-fra.htm) (comprenant de 400 à 700 habitants) ou des [secteurs de recensement](https://www150.statcan.gc.ca/n1/pub/92-195-x/2011001/geo/ct-sr/ct-sr-fra.htm) (de 2500 à 8000 habitants).\n\nL'aire de diffusion et surtout le secteur de recensement sont souvent choisis puisqu'une panoplie de variables socioéconomiques, sociodémographiques et relatives au logement sont rattachées à ces entités spatiales pour les différents recensements de Statistique Canada. La sélection de ces entités spatiales (aire de diffusion ou secteur de recensement) permet alors d'évaluer les relations entre les mesures d'accessibilité et les variables socioéconomiques ou sociodémographiques. Néanmoins, cela nécessite de recourir à méthodes d'agrégation afin de limiter les erreurs dans la mesure de l'accessibilité spatiale potentielle [@ApparicioGelbrevisited; @hewko2002measuring].\n\n#### Méthodes d'agrégation {#sec-05322}\n\nDans un article méthodologique sur la comparaison des approches pour évaluer l'accessibilité spatiale potentielle, Apparicio *et al.* [-@ApparicioGelbrevisited] ont répertorié quatre principales méthodes d'agrégation pour évaluer une mesure d'accessibilité pour les secteurs de recensement. Ces approches, de la moins à la plus précise, sont les suivantes :\n\n-   La première approche consiste à calculer la distance entre le centroïde du secteur de recensement et le service (@fig-MethodesAgregations, a). Plus la taille du secteur de recensement est grande, plus l'erreur d'agrégation (l'imprécision de la mesure d'accessibilité) risque d'être importante puisqu'elle ne tient pas compte de la distribution spatiale de la population à l'intérieur du secteur de recensement. Autrement dit, cette approche revient à supposer que toute la population réside en son centroïde.\n\n-   La seconde approche consiste à calculer la distance entre les services et les centroïdes d'entités spatiales entièrement incluses dans les secteurs de recensement, puis à calculer la moyenne de ces distances pondérée par la population totale de chaque entité spatiale. Cette approche est réalisée avec les aires de diffusion et les îlots inclus dans les secteurs de recensement (@fig-MethodesAgregations, b et c). Bien entendu, les résultats sont plus précis avec les îlots de diffusion que les aires de diffusion puisqu'ils sont de taille plus réduite.\n\n-   La troisième approche consiste à ajuster la localisation des centroïdes des îlots en ne retenant que la partie résidentielle avec une carte d'occupation du sol (@fig-MethodesAgregations, d).\n\n-   Finalement, la quatrième approche consiste à utiliser le rôle d'évaluation foncière. Nous calculons alors les distances entre chaque unité d'évaluation foncière et les services, puis la moyenne pondérée de ces distances par le nombre de logements. Cette approche est sans aucun doute la plus précise, mais elle est bien plus chronophage. En effet, à la @fig-MethodesAgregations, nous avons respectivement 4 secteurs de recensement (a), 23 aires de diffusion (b), 69 îlots (c et d) et 3497 unités d'évaluation foncière (e).\n\n![Méthodes d'agrégation et erreurs potentielles](images/Chap05/MethodesAgregation.png){#fig-MethodesAgregations width=\"90%\" fig-align=\"center\"}\n\n#### Mesures d'accessibilité {#sec-05323}\n\nDifférentes mesures renvoyant à différentes conceptualisations de l'accessibilité peuvent être utilisées pour évaluer l'accessibilité spatiale potentielle; les principales sont reportées au @tbl-ConceptualisationAccessibilite. Pour une description détaillée de ces mesures et de leurs formules, consultez l'article d'Apparicio *et al.* [-@ApparicioGelbrevisited].\n\n```{r}\n#| label: tbl-ConceptualisationAccessibilite\n#| tbl-cap: Conceptualisation et mesures de l'accessibilité spatiale potentielle aux services\n#| echo: false\n#| message: false\n#| warning: false\n\nc1 <- c(\"Proximité immédiate\",\n        \"Offre de services dans l'environnement immédiat\",\n        \"Coût moyen pour atteindre tous les services\",\n        \"Coût moyen pour atteindre toutes les *n* destinations\",\n        \"Accessibilité en fonction de l'offre et la demande\")\nc2 <- c(\"Distance entre l'origine et le service le plus proche\",\n        \"Nombre de services présents à moins de *n* mètres ou minutes\",\n        \"Distance moyenne entre une origine et tous les services\",\n        \"Distance moyenne entre une origine et *n* services\",\n        \"Modèles gravitaires et méthodes *two-step floating catchment area* (2SFCA)\")\n\ntableau <- data.frame(A = c1, B = c2)\n\nknitr::kable(tableau, \n            format.args = list(decimal.mark = ',', big.mark = \" \"),\n\t\t\tcol.names = c(\"Conceptualisation\", \"Mesures d'accessibilité\"),\n            caption = \"Conceptualisation et mesures de l'accessibilité spatiale potentielle aux services\",\n            align= c(\"l\", \"l\"),\n\t\t\tformat = \"markdown\")\n```\n\nSource : Apparicio *et al.* [-@ApparicioGelbrevisited].\n\nPour poser un diagnostic d'accessibilité spatiale potentielle à un service pour un territoire donné, plusieurs chercheuses et chercheurs recommandent d'utiliser plusieurs mesures d'accessibilité.\n\nPar exemple, dans une étude sur les déserts alimentaires à Montréal, Apparicio *et al.* [-@apparicio2007case] utilisent trois mesures d'accessibilité : la distance au supermarché le plus proche (proximité immédiate), le nombre de supermarchés dans un rayon de 1000 mètres (offre dans l'environnement immédiat) et la distance moyenne aux trois supermarchés d'enseignes différentes (diversité en termes d'offre et de prix) à travers le réseau de rues.\n\nDans une autre étude portant sur l'accessibilité spatiale potentielle aux parcs urbains à Montréal, Jepson *et al.* [-@jepson2022environmental] utilisent deux mesures d'accessibilité : la distance au parc le plus proche (proximité immédiate) et la mesure E2FCA (congestion potentielle en fonction de l'offre et la demande) calculées pour les aires de diffusion de la Communauté métropolitaine de Montréal (@fig-ESFSCAParcs). Concernant la proximité immédiate, le niveau d'accessibilité est bien élevé sur l'île de Montréal et inversement, plus faible à Laval et dans la Rive-Nord et la Rive-Sud (@fig-ESFSCAParcs, a). En effet, la quasi-totalité des aires de diffusion de l'île de Montréal a un parc à moins de 200 mètres de marche. Concernant la congestion potentielle des parcs, le portrait est tout autre : le niveau de congestion potentielle est faible dans les zones suburbaines (Laval et les deux Rives) tandis qu'il est élevé dans les quartiers centraux de l'île de Montréal (@fig-ESFSCAParcs, b). Autrement dit, les habitants des quartiers centraux de la ville de Montréal vivent plus près d'un parc, mais ce dernier est potentiellement plus congestionné. Or, une surutilisation des parcs peut entraîner une dégradation accélérée des équipements (aires de jeu, terrains de sports, etc.), voire décourager certaines personnes à visiter un parc durant les périodes plus achalandées.\n\n![Deux mesures d'accessibilité spatiale potentielle aux parcs, aires de diffusion de la Communauté métropolitaine de Montréal, 2016](images/Chap05/2SFCAParcs.png){#fig-ESFSCAParcs width=\"110%\" fig-align=\"center\"}\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Le 2SFCA et ses fonctions de pondération**\n:::\n\n::: bloc_aller_loin-body\nLes mesures appartenant à la famille des *Two Step Floating Catchement Area* (TSFCA) permettent d'évaluer l'accessibilité à des services en tenant comptant à la fois de l'offre (taille du service, par exemple le nombre de lits dans un hôpital) et de la demande (population résidant à la proximité des services). \n\nTel le nom l'indique, le calcul des mesures du TSFCA comprend deux étapes. Si nous reprenons l'exemple des parcs, la première étape consiste à calculer un ratio $R_j$ pour chaque parc, indiquant le nombre d'hectares de parcs pour 1000 personnes résidant dans un rayon de *n* mètres ou minutes du parc :\n\n\n$$\nR_{j} = \\frac{S_j}{\\sum_{j \\in \\{ d_{ij} \\leq d_0\\} }{P_i \\times W(d_{ij}) }}\n$$ {#eq-TSFCARj}\n\navec :\n\n-   $j$, un parc.\n-   $S_j$ la capacité du parc $j$ (ici, la superficie en hectares).\n-   $i$, une entité géographique (ici, une aire de diffusion).\n-   $d_{ij}$, la distance entre l'entité géographique $i$ et le parc $j$.\n-   $d_0$, le seuil de distance maximale (par exemple un kilomètre ou trente minutes).\n-   $P_i$, la population totale résidant dans $i$. Cette population est habituellement exprimée en milliers d'habitants, soit $P_i/1000$.\n-   $W$, une fonction de pondération permettant de contrôler le fait qu'un parc plus éloigné est moins attractif et contribue moins à la valeur finale de la mesure d'accessibilité.\n\nEn résumé, $R_j$ est le ratio entre la superficie du parc et la population ayant accès au parc dans un rayon *n* mètres ou minutes ($d_0$).\n\nLa deuxième étape consiste à calculer la somme pour chaque aire de diffusion $i$ de la disponibilité des parcs à proximité.\n\n$$\n A_{i} = \\sum^{m}_{j=1}{R_j \\times W(d_{ji}) }\n$$ {#eq-TSFCAAi}\n\nNous obtenons au final $A_i$, soit pour chaque aire de diffusion le nombre total d'hectares de parcs disponible pour 1000 habitants.\n\nNotez que la fonction $W$ joue un rôle très important dans la formulation du 2SFCA. Elle peut prendre plusieurs formes, la plus simple étant une fonction binaire donnant un poids de 1 aux parcs situés en-dessous d'une certaine distance. Par exemple, la fonction R ci-dessous donne un poids de 1 à des parcs situés à moins de 500 mètres et 0 au-delà.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\nw_binaire <- function(d){ifelse(d <= 500, 1, 0)}\n```\n\nLe problème de cette formulation est qu'elle implique que l'accessibilité au parc est la même que l'on habite à 25 ou 500 mètres du parc. Il a donc été proposé d'améliorer la méthode en ajoutant une fonction de pondération par palier qui accorde un poids différent selon des seuils de distances prédéfinis. Les fonctions R ci-dessous font ainsi varier le poids dans trois catégories de distance selon une pondération appelée *slow decay* et *fast decay* [@luo2009enhanced] et des paliers de 150, 300 et 500 mètres.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\nw_slow_decay <- function(d){\n  w <- case_when(\n    d <= 150 ~ 1,\n    d > 150 & d <= 300 ~ 0.68,\n    d > 300 & d <= 500 ~ 0.22,\n    d > 500 ~ 0\n  )\n  return(w)\n}\n\nw_fast_decay <- function(d){\n  w <- case_when(\n    d <= 150 ~ 1,\n    d > 150 & d <= 300 ~ 0.42,\n    d > 300 & d <= 500 ~ 0.09,\n    d > 500 ~ 0\n  )\n  return(w)\n}\n```\n\nFinalement, il a aussi été proposé d'utiliser des fonctions de pondération continues et décroissantes. Les fonctions R ci-dessous illustrent une fonction incluant un effet de palier tel que proposé par McGrail [-@mcgrail2012spatial] et une fonction logistique décroissante.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n# palier à 125 mètres, maximum à 500 mètres\nW_cont_palier <- function(x){\n  w <- ifelse(x < 125, 1,((500 - x) / (500 - 125))**1.5)\n  w[x  > 500] <- 0\n  return(w)\n}\n\nlogit_fun <- function(x,a,b){\n  (1 + exp(-(a*pi)/(b*sqrt(3)))) / (1 + exp(((x-a)*pi)/(b*sqrt(3))))\n}\nw_logit1 <- function(x){logit_fun(x, 250, 80)}\nw_logit2 <- function(x){logit_fun(x, 250, 40)}\n```\n\nConcernant la fonction logistique, elle comporte deux paramètre, $\\alpha$ et $\\beta$. Le premier paramètre permet de contrôler la distance à laquelle la pondération atteindra la valeur de 0,5. Le second contrôle la vitesse de décroissance de la courbe. La figure ci-dessous illustre les poids obtenus selon chacune de ces fonctions de pondération.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\nlibrary(dplyr, quietly = TRUE)\nlibrary(tidyr, quietly = TRUE)\nlibrary(ggplot2, quietly = TRUE)\n\n\nd <- 1:600\ndf <- data.frame(\n  distance = d,\n  binaire = w_binaire(d),\n  slow_decay = w_slow_decay(d),\n  fast_decay = w_fast_decay(d),\n  palier = W_cont_palier(d),\n  logistique1 = w_logit1(d),\n  logistique2 = w_logit2(d)\n)\npond_cols <- names(df)[names(df) != 'distance']\n\ndf2 <- df %>% pivot_longer(cols = all_of(pond_cols))\n\nggplot(df2) + \n  geom_line(aes(x = distance, y = value, color = name, group = name)) + \n  labs(x = 'distance (m)', \n       y = 'pondération',\n       color = 'fonction'\n       ) + \n  theme_minimal()\n```\n\nLe choix d'une fonction de pondération doit avant tout reposer sur des considérations théoriques et représenter correctement la décroissance de l'attractivité d'un service en fonction de la distance d'éloignement. Idéalement, ces fonctions devraient être ajustées en fonction de données sur les habitudes de déplacement des individus.\n:::\n:::\n\n\n\n#### Types de distance {#sec-05324}\n\nTel que décrit à la [section @sec-0512], les mesures d'accessibilité peuvent être calculées en fonction de trajets les plus rapides selon différents modes de transport, soit en automobile, à pied, en vélo et en transport en commun (@fig-TypesDistancesTransport).\n\n## Mesures d'accessibilité spatiale potentielle dans R {#sec-054}\n\n### Accessibilité spatiale potentielle aux supermarchés {#sec-0541}\n\nDans ce premier exemple applicatif dans R, nous élaborons un diagnostic de l'accessibilité spatiale potentielle aux supermarchés dans la ville de Sherbrooke avec les quatre paramètres suivants :\n\n1.  **Unité spatiale de référence** : aires de diffusion (AD) de 2021 de la ville de Sherbrooke.\n\n2.  **Méthode d'agrégation** : calcul des moyennes pondérées par le nombre de logements des [immeubles du rôle d'évaluation foncière](https://www.donneesquebec.ca/recherche/dataset/roles-d-evaluation-fonciere-du-quebec/resource/62c46738-6c05-4971-b598-d114db4e32cb) compris dans les AD.\n\n3.  **Trois mesures d'accessibilité** : le supermarché le plus proche (en minutes), le nombre de supermarchés à 30 minutes et moins, la distance moyenne aux trois supermarchés les plus proches.\n\n4.  **Type de distance** : chemin le plus rapide à la marche.\n\n**Étape 1.** Importation des trois couches géographiques.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Unités d'évaluation foncière\nRole <- st_read(dsn = \"data/chap05/AutresDonnees/Role2022Sherb.gdb\",\n                layer = \"rol_unite_Sherbrooke\", quiet = TRUE)\n## Aires de diffusion\nAD <- st_read(dsn = \"data/chap05/AutresDonnees/Commerces.gpkg\",\n                        layer = \"AD_Sherbrooke\", quiet=TRUE)\n## Supermarchés\nSupermarches <- st_read(dsn = \"data/chap05/AutresDonnees/Commerces.gpkg\",\n                        layer = \"supermarche\", quiet=TRUE)\n## Changement de projection\nSupermarches <- st_transform(Supermarches, crs = 4326)\nRole <- st_transform(Role, crs = 4326)\nAD <- st_transform(AD, crs = 4326)\n```\n\n**Étape 2.** Réalisation d'une jointure spatiale pour attribuer à chaque unité d'évaluation l'identifiant de l'aire de diffusion (champ `ADIDU`) dans laquelle elle est comprise.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Jointure spatiale entre le Role et les AD\nRole <- st_join(Role, AD[,\"ADIDU\"], join = st_intersects)\nRole <- subset(Role, is.na(ADIDU)==FALSE)\n## Nombre de distances à calculer\nnO = nrow(Role)\nnD = nrow(Supermarches)\nNOD = nO * nD\ncat(\"Origines (O) :\", nO, \"îlots\",\n    \"\\n Destinations (D) :\", nD, \"supermarchés\",\n    \"\\n Distances OD = \", NOD)\n```\n\n**Étape 3.** Création des points d'origine et de destination.\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Rattacher les points aux tronçons de rue**\n:::\n\n::: bloc_attention-body\nPuisque nous utilisons le trajet le plus court à pied, les points d'origine et de destination doivent être rattachés à des tronçons de rues qui ne sont pas des autoroutes ou tout autre tronçon interdit à la marche. Pour ce faire, le *package* `R5R` dispose d'une fonction très intéressante :\n\n`find_snap(r5r_core, points, mode = \"WALK\")`.\n\nSans le recours à cette fonction, un point d'origine ou de destination risque d'être rattaché à un tronçon autoroutier, faisant en sorte que le trajet ne pourra être calculé à la marche.\n:::\n:::\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Origines\nOrigines <- Role\nOrigines$lat <- st_coordinates(Origines)[,2]\nOrigines$lon <- st_coordinates(Origines)[,1]\nOrigines$id <- Origines$mat18\nOrigines <- find_snap(r5r_core, Origines, mode = \"WALK\")\nOrigines$lat <- Origines$snap_lat\nOrigines$lon <- Origines$snap_lon\nOrigines <- Origines[, c(\"point_id\", \"lat\", \"lon\", \"distance\")]\nnames(Origines) <- c(\"id\", \"lat\", \"lon\", \"distance\")\n## Destinations\nDestinations <- Supermarches\nDestinations$lat <- st_coordinates(Destinations)[,2]\nDestinations$lon <- st_coordinates(Destinations)[,1]\nnames(Destinations)[1] <- \"id\"\nDestinations <- find_snap(r5r_core, Destinations, mode = \"WALK\")\nDestinations$lat <- Destinations$snap_lat\nDestinations$lon <- Destinations$snap_lon\nDestinations <- Destinations[, c(\"point_id\", \"lat\", \"lon\", \"distance\")]\nnames(Destinations) <- c(\"id\", \"lat\", \"lon\", \"distance\")\n```\n\n**Étape 4.** Construction de la matrice origines-destinations avec la fonction `travel_time_matrix` et sauvegarde dans un fichier `Rdata`.\n\n```{r}\n#| echo: true\n#| message: true \n#| eval: false \n## Matrice OD à la marche\nt1 <-Sys.time()\nmatriceOD.Marche <- travel_time_matrix(r5r_core = r5r_core,\n                                       origins = Origines,\n                                       destinations = Destinations,\n                                       mode = \"WALK\",\n                                       walk_speed = 4.5,  # valeur par défaut 3.6\n                                       max_trip_duration = 240,\n                                       max_walk_time = Inf)\nt2 <-Sys.time()\nduree.marche = as.numeric(difftime(t2, t1), units = \"mins\")\ncat(\"Temps de calcul :\", round(duree.marche,2), \"minutes\")\n## Enregistrement des résultats dans un fichier Rdata\nsave(duree.marche, matriceOD.Marche,\n     file=\"data/chap05/Resultats/MatricesMarcheRoleSupermarche.Rdata\")\n```\n\n**Étape 5.** Calcul des trois mesures d'accessibilité pour les unités d'évaluation.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Chargement du fichier Rdata\nload(\"data/chap05/Resultats/MatricesMarcheRoleSupermarche.Rdata\")\ncat(\"Temps de calcul pour la matrice :\", round(duree.marche,2), \"minutes\")\n\n## Supermarché le plus proche\nSupermarche.PlusProche <- matriceOD.Marche %>% \n  group_by(from_id) %>% \n  summarise(\n    plus_proche = min(travel_time_p50))\n\n## Nombre de supermarchés à moins de 30 minutes\nSupermarche.N30mins <- matriceOD.Marche %>% \n  filter(travel_time_p50 <= 30) %>% \n  group_by(from_id) %>% \n  summarise(\n    nb_30_min = n())\n\n# Distance moyenne aux trois supermarchés les plus proches\nSupermarche.3 <- matriceOD.Marche %>% \n  group_by(from_id) %>% \n  mutate(dist_rank = order(order(travel_time_p50, decreasing=FALSE))) %>%\n  filter(dist_rank <= 3) %>%\n  summarise(nb = n(),\n            sum_dist = sum(travel_time_p50))\n\n# Notez ici que nous pouvons avoir des origines pour lesquelles\n# n'avons pas trois supermarchés à moins de 240 minutes.\n# Pour ces quelques cas, nous ajoutons des temps de 240 minutes pour les \n# origines avec des supermarchés manquants.\nSupermarche.3$sum_dist <- Supermarche.3$sum_dist + 240 * (3 - Supermarche.3$nb)\nSupermarche.3$mean_n3 <- Supermarche.3$sum_dist / 3\nSupermarche.3$nb <- NULL\nSupermarche.3$sum_dist <- NULL\n\n# Nous pouvons à présent fusionner nos différent dataframes avec les \n# indicateurs d'accessibilité\nRole <- Role %>% \n  left_join(Supermarche.PlusProche, by = c('mat18' = 'from_id')) %>%\n  left_join(Supermarche.N30mins, by = c('mat18' = 'from_id')) %>%\n  left_join(Supermarche.3, by = c('mat18' = 'from_id')) %>%\n  rename(\n      SupPlusProcheMin = 'plus_proche',\n      SupN30min = 'nb_30_min',\n      Moy3Sup = 'mean_n3'\n  )\n\n# Certaines observations n'ont pas de supermarchés à 30 minutes\n# Nous mettons alors les valeurs à 0\nRole$SupN30min[is.na(Role$SupN30min)] <- 0\n```\n\n**Étape 6.** Calcul des moyennes pondérées par le nombre de logements (champ `Logements`) pour les aires de diffusion avec le *package* `dplyr`.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\nlibrary(dplyr)\n## Création d'un DataFrame temporaire sans la géométrie\nRole.Temp <- st_drop_geometry(Role)\n## Moyennes pondérées pour les trois indicateurs d'accessibilité\nMesureAcc <- Role.Temp %>%\n                group_by(ADIDU) %>%\n                summarize(\n                  SupPlusProcheMin = weighted.mean(SupPlusProcheMin, Logements),\n                  SupN30min = weighted.mean(SupN30min, Logements),\n                  Moy3Sup = weighted.mean(Moy3Sup, Logements)\n                )\n\n## Fusion avec la couche des AD\nAD <- left_join(AD, MesureAcc, by=\"ADIDU\")\n```\n\n**Étape 7.** Cartographie des résultats avec le *package* `tmap`.\n\nTout d'abord, nous analysons les statistiques univariées pour repérer les valeurs minimales et maximales pour les trois mesures d'accessibilité avec la fonction `summary`.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\nTroisMesures <- c(\"SupPlusProcheMin\",\"SupN30min\",\"Moy3Sup\")\nsummary(AD[, TroisMesures])\n```\n\nUne fois les valeurs maximales et minimales analysées, réalisons les cartes (@fig-CartoSuperm).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CartoSuperm\n#| fig-align: center\n#| fig-cap: Accessibilité spatiale potentielle à pied aux supermarchés (en minutes), aires de diffusion de la ville de Sherbrooke, 2021\n#| out-width: 100%\n\n## Importation des arrondissements de la ville de Sherbrooke\narrondissements <- st_read(dsn = \"data/Chap05/AutresDonnees/Arrondissements.shp\", \n                           quiet=TRUE)\n## Construction des cartes\ntmap_mode(\"plot\")\n# Carte pour les supermarchés\nCarte0 <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(Supermarches)+\n              tm_dots(col=\"red\", size=0.25)+\n          tm_layout(frame = FALSE, legend.outside = TRUE, \n\t\t\t\t\tlegend.format = list(text.separator = \"à\"),\n                    title = \"Supermarché\",\n                    title.size = 1)\n# Carte pour le supermarché le plus proche\nmax.acc1 <- max(AD$SupPlusProcheMin,na.rm=TRUE)\nCarte1 <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(AD)+\n            tm_fill(col=\"SupPlusProcheMin\", \n                    border.lwd = 1,\n                    style = \"fixed\",\n                    breaks = c(0,10,20,30,40,60,max.acc1),\n                    palette=\"-YlOrRd\",\n                    size = .2, \n \t\t\t\t\t          legend.format = list(text.separator = \"à\"),\n                    textNA = \"Sans données\",\n \t\t\t\t\t          title=\"Plus proche\")+\n          tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_layout(frame = FALSE, legend.outside = TRUE)\n# Carte pour le nombre de supermarchés à 30 minutes ou moins\nmax.acc2 <- max(AD$SupN30min,na.rm=TRUE)\nCarte2 <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(AD)+\n            tm_fill(col=\"SupN30min\", \n                    border.lwd = 1,\n                    style = \"fixed\",\n                    breaks = c(0,1,2,3,4,5,max.acc2),\n                    palette=\"YlOrRd\",\n                    size = .2, \n\t\t\t\t\t          legend.format = list(text.separator = \"à\"),\n          \t\t\t\t\ttextNA = \"Sans données\",\n                    title=\"Sup. à 30 min\")+\n          tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_layout(frame = FALSE, legend.outside = TRUE)\n# Carte pour la distance moyenne aux trois supermarchés les plus proches\nmax.acc3 <- max(AD$Moy3Sup,na.rm=TRUE)\nCarte3 <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(AD)+\n            tm_fill(col=\"Moy3Sup\", \n                    border.lwd = 1,\n                    style = \"fixed\",\n                    breaks = c(5,10,20,30,40,60,max.acc3),\n                    palette=\"-YlOrRd\",\n                    size = .2, \n          \t\t\t\t\tlegend.format = list(text.separator = \"à\"),\n          \t\t\t\t\ttextNA = \"Sans données\",\n                    title=\"Moy. 3 plus proches\")+\n          tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_layout(frame = FALSE, legend.outside = TRUE)\n## Figure avec les quatre cartes\ntmap_arrange(Carte0, Carte1, Carte2, Carte3)\n```\n\n### Accessibilité spatiale potentielle aux patinoires extérieures {#sec-0542}\n\nDans ce second exemple applicatif dans R, nous élaborons un diagnostic de l'accessibilité spatiale potentielle aux patinoires extérieures dans la ville de Sherbrooke avec les quatre paramètres suivants :\n\n1.  **Unité spatiale de référence** : aires de diffusion (AD) de 2021 de la ville de Sherbrooke.\n\n2.  **Méthode d'agrégation** : calcul des moyennes pondérées par la population totale des îlots compris dans les AD.\n\n3.  **Deux mesures d'accessibilité** : patinoire la plus proche (en minutes); E2SFCA (*Enhanced two-step floating catchment area*), soit le nombre de patinoires pour 1000 habitants dans un rayon de 30 minutes de marche.\n\n4.  **Type de distance** : chemin le plus rapide à la marche.\n\n**Étape 1.** Importation des trois couches géographiques.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Unités d'évaluation foncière\nPatinoires <- st_read(dsn = \"data/chap05/AutresDonnees/Patinoires.shp\",\n                      quiet = TRUE)\n## Aires de diffusion\nAD <- st_read(dsn = \"data/chap05/AutresDonnees/Commerces.gpkg\",\n              layer = \"AD_Sherbrooke\", quiet=TRUE)\n## Ilots de recensements\nIlots <- st_read(dsn = \"data/chap05/AutresDonnees/Commerces.gpkg\",\n                 layer = \"Ilots\", quiet=TRUE)\n## Changement de projection\nPatinoires <- st_transform(Patinoires, crs = 4326)\nAD <- st_transform(AD, crs = 4326)\nIlots <- st_transform(Ilots, crs = 4326)\n```\n\n**Étape 2.** Réalisation d'une jointure spatiale pour attribuer à chaque îlot l'identifiant de l'aire de diffusion (champ `ADIDU`) dans laquelle il est compris.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Jointure spatiale entre le Rôle et les AD\nIlots <- st_join(st_centroid(Ilots), AD[,\"ADIDU\"], join = st_intersects)\nIlots <- Ilots[,c(\"id\",\"pop2021\",\"ADIDU\")]\n```\n\n**Étape 3.** Création des points d'origine et de destination.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Origines\nOrigines <- Ilots\nOrigines$lat <- st_coordinates(Origines)[,2]\nOrigines$lon <- st_coordinates(Origines)[,1]\nOrigines <- find_snap(r5r_core, Origines, mode = \"WALK\")\nOrigines$lat <- Origines$snap_lat\nOrigines$lon <- Origines$snap_lon\nOrigines <- Origines[, c(\"point_id\", \"lat\", \"lon\", \"distance\")]\nnames(Origines) <- c(\"id\", \"lat\", \"lon\", \"distance\")\n## Destinations\nDestinations <- Patinoires\nDestinations$lat <- st_coordinates(Destinations)[,2]\nDestinations$lon <- st_coordinates(Destinations)[,1]\nDestinations$id <- as.character(1:nrow(Destinations))\nDestinations <- find_snap(r5r_core, Destinations, mode = \"WALK\")\nDestinations$lat <- Destinations$snap_lat\nDestinations$lon <- Destinations$snap_lon\nDestinations <- Destinations[, c(\"point_id\", \"lat\", \"lon\", \"distance\")]\nnames(Destinations) <- c(\"id\", \"lat\", \"lon\", \"distance\")\n```\n\n**Étape 4.** Construction de la matrice origines-destinations avec la fonction `travel_time_matrix` et sauvegarde dans un fichier `Rdata`.\n\n```{r}\n#| echo: true\n#| message: true \n#| eval: false \n## Matrice OD à la marche\nt1 <-Sys.time()\nmatriceODPatinoire.Marche <- travel_time_matrix(r5r_core = r5r_core,\n                                                origins = Origines,\n                                                destinations = Destinations,\n                                                mode = \"WALK\",\n                                                walk_speed = 4.5,\n                                                max_trip_duration = 240,\n                                                max_walk_time = Inf)\nt2 <-Sys.time()\nduree.marche = as.numeric(difftime(t2, t1), units = \"mins\")\ncat(\"Temps de calcul :\", round(duree.marche,2), \"minutes\")\n## Enregistrement des résultats dans un fichier Rdata\nsave(duree.marche, matriceODPatinoire.Marche,\n     file=\"data/chap05/Resultats/matriceODPatinoire.Rdata\")\n```\n\n**Étape 5.** Calcul des deux mesures d'accessibilité pour les îlots.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n## Chargement du fichier Rdata\nload(\"data/chap05/Resultats/matriceODPatinoire.Rdata\")\ncat(\"Temps de calcul pour la matrice :\", round(duree.marche,2), \"minutes\")\n```\n\nLe code ci-dessous permet de calculer la distance à la patinoire la plus proche pour les aires de diffusion.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Patinoire la plus proche\nPatinoire.PlusProche <- matriceODPatinoire.Marche %>% \n  group_by(from_id) %>%\n  summarise(PatinoirePlusProche = min(travel_time_p50))\n## Fusion avec la couche des îlots\nIlots <- left_join(Ilots, Patinoire.PlusProche, by=c(\"id\" = 'from_id'))\n```\n\nPuis, nous calculons la version de la méthode du E2SFCA avec une fonction de gradient continue [@mcgrail2009measuring].\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\nsource(\"code_complementaire/E2SFCA.R\")\n## Ajout des champs de population dans la matrice\nTempIlots <- st_drop_geometry(Ilots)\nmatriceODPatinoire <- merge(matriceODPatinoire.Marche, \n                   TempIlots[,c(\"id\",\"pop2021\")],\n                   by.x = \"from_id\", by.y=\"id\")\nmatriceODPatinoire$Wd <- 1\nnames(matriceODPatinoire) <- c(\"from_id\", \"to_id\", \"Marche\", \"Wo\", \"Wd\")\nhead(matriceODPatinoire, n=2)\n# Utilisation de la pondération de gradient continu du E2SFCA\nWfun <- function(x){\n  w <- ifelse(x < 5, 1,((30 - x) / (30 - 5))**1.5)\n  w[x  > 30] <- 0\n  return(w)\n}\n# Calcul du résultat en milliers d'habitants\nmatriceODPatinoire$Wo <- matriceODPatinoire$Wo / 1000\nMesureE2SFCA <- GTSFCA(dist_mat = matriceODPatinoire,\n                        Wfun = Wfun,\n                        IDorigine = \"from_id\",\n                        IDdestination = \"to_id\",\n                        CoutDistance = \"Marche\",\n                        Wo = \"Wo\",\n                        Wd = \"Wd\",\n                        ChampSortie = \"E2SFCA_G\")\n\nMesureE2SFCA$E2SFCA_G[is.na(MesureE2SFCA$E2SFCA_G)] <- 0\nIlots <- merge(Ilots, MesureE2SFCA, by.x =\"id\", by=\"from_id\", all.x = TRUE)\nIlots$E2SFCA_G[is.na(Ilots$E2SFCA_G)] <- 0\n```\n\n**Étape 6.** Calcul des moyennes pondérées par la population des îlots (champ `pop2021`) pour les aires de diffusion avec le *package* `dplyr`.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n## Création d'un DataFrame temporaire sans la géométrie\nIlots.Temp <- st_drop_geometry(Ilots)\n## Moyenne pondérées pour la patinoire la plus proche\nMesureAcc1 <- Ilots.Temp %>%\n                group_by(ADIDU) %>%\n                summarize(PatinoirePlusProche = weighted.mean(PatinoirePlusProche, pop2021))\n## Moyenne non pondérée pour le E2SFCA, car la population est déjà prise en compte\nMesureAcc2 <- aggregate(E2SFCA_G ~ ADIDU, Ilots.Temp, FUN = mean)\n## Fusion avec la couche des îlots\nAD <- merge(AD, MesureAcc1, by=\"ADIDU\")\nAD <- merge(AD, MesureAcc2, by=\"ADIDU\")\n```\n\n**Étape 7.** Cartographie des résultats avec le *package* `tmap`.\n\nTout d'abord, nous analysons les statistiques univariées pour repérer les valeurs minimales et maximales pour les trois mesures d'accessibilité.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\nDeuxMesures <- c(\"PatinoirePlusProche\",\"E2SFCA_G\")\nsummary(AD[, DeuxMesures])\n```\n\nUne fois avoir pris connaissance des valeurs maximales et minimales, nous pouvons réaliser les cartes (@fig-CartoPatinoires).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CartoPatinoires\n#| fig-align: center\n#| fig-cap: Accessibilité spatiale potentielle à pied aux patinoires extérieures, aires de diffusion de la ville de Sherbrooke, 2021\n#| out-width: 100%\n\n## Importation des arrondissements de la ville de Sherbrooke\narrondissements <- st_read(dsn = \"data/Chap05/AutresDonnees/Arrondissements.shp\", \n                           quiet=TRUE)\n## Construction des cartes\ntmap_mode(\"plot\")\n# Carte pour les patinoires\nCarte0p <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(Patinoires)+\n              tm_dots(col=\"red\", size=0.25)+\n          tm_layout(frame = FALSE, legend.outside = TRUE, \n                    title = \"Patinoire extérieure\",\n                    title.size = 1)\n# Carte pour la patinoire la plus proche\nmax.acc1 <- max(AD$PatinoirePlusProche,na.rm=TRUE)\nCarte1p <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(AD)+\n            tm_fill(col=\"PatinoirePlusProche\", \n                    border.lwd = 1,\n                    style = \"fixed\",\n                    breaks = c(0,10,20,30,40,60,max.acc1),\n                    palette=\"-YlOrRd\",\n                    size = .2, \n                    legend.format = list(text.separator = \"à\"),\n                    textNA = \"Sans données\",\n                    title=\"Plus proche (min)\")+\n          tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_layout(frame = FALSE, legend.outside = TRUE)\n# Carte pour le 2ESFCA\nAD2 <- subset(AD, E2SFCA_G !=0)\nmin.acc2 <- min(AD2$E2SFCA_G,na.rm=TRUE)\nmax.acc2 <- max(AD2$E2SFCA_G,na.rm=TRUE)\nCarte2p <- tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_shape(AD)+tm_fill(col=\"gray\")+\n          tm_shape(AD2)+\n            tm_fill(col=\"E2SFCA_G\", \n                    border.lwd = 1,\n                    style = \"fixed\",\n                    breaks = c(min.acc2,0.25,0.50,0.75,1,max.acc2),\n                    palette=\"YlOrRd\",\n                    size = .2, \n                    legend.format = list(text.separator = \"à\"),\n                    title=\"Patinoire pour 1000 hab.\")+\n          tm_shape(arrondissements)+tm_borders(lwd = 2)+\n          tm_layout(frame = FALSE, legend.outside = TRUE)\n## Figure avec les trois cartes\ntmap_arrange(Carte0p, Carte1p, Carte2p,\n             nrow=2, ncol=2)\n```\n\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Libération de la mémoire allouée à JAVA**\n:::\n\n::: bloc_attention-body\nUne fois les calculs avec `R5R` terminés, il convient de détruire l'objet `r5r_core` et d'arrêter le processus JAVA avec les deux lignes de code ci-dessous.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false \n#| eval: false\nr5r::stop_r5(r5r_core)\nrJava::.jgc(R.gc = TRUE)\n```\n:::\n:::\n## Quiz de révision du chapitre {#sec-055}\n\n```{r}\n#| label: quizChapitre05\n#| echo: false \n#| eval: true \n#| message: false \n#| warning: false \n#| results: asis\n\nsource(\"code_complementaire/QuizzFunctions.R\")\nChap05Quiz <- quizz(\"quiz/Chap05.yml\", \"Chap05\")\nrender_quizz(Chap05Quiz)\n```\n\n## Exercices de révision {#sec-056}\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 1.** Calcul de trajets selon différents modes de transport\n:::\n\n::: bloc_exercice-body\nComplétez le code ci-dessous pour réaliser les étapes suivantes :\n\n1.  Construisez un réseau R5R pour la région de Laval avec un fichier OMS (pbf), un fichier d'élévation et un fichier GTFS.\n\n2.  Créez deux points : l'un pour la station de métro Morency (-73.7199, 45.5585) l'autre pour une adresse fictive (-73.7183, 45.5861).\n\n3.  Calculez les trajets en automobile, à vélo, à pied, et en transport en commun de l'adresse vers la station de métro et l'inverse avec (10 points) :\n\n    -   Une vitesse de 15 km/h pour le vélo.\n\n    -   Une vitesse de 4,5 km/h pour la marche.\n\n    -   Un trajet aller le 12-02-2024 à 8h de l'adresse vers la station de métro.\n\n    -   Un trajet retour le 12-02-2024 à 18h de la station de métro vers l'adresse.\n\n4.  Réalisez deux figures :\n\n    -   Une figure avec quatre cartes des trajets aller (marche, vélo, auto, transport en commun).\n\n    -   Une figure avec quatre cartes des trajets retour (marche, vélo, auto, transport en commun).\n\n5.  Arrêtez java.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false \n#| eval: false\nlibrary(sf)\nlibrary(tmap)\nlibrary(r5r)\n\nsetwd(\"data/chap05/Laval\")\nrJava::.jinit()\noptions(java.parameters = \"-Xmx2G\")\n\n# 1. Construction du réseau\ndossierdata <- paste0(getwd(),\"/_DataReseau\")\nlist.files(dossierdata)\nr5r_core <- setup_r5(à compléter)\n\n# 2. Création de deux points\nPts <- data.frame(id = c(\"Station Morency\", \"Adresse 1\"),\n                  lon = c(à compléter),\n                  lat = c(à compléter))\nPts <- st_as_sf(Pts, coords = c(\"lon\",\"lat\"), crs = 4326)\nStationMorency <- Pts[1,]\nAdresse1 <- Pts[2,]\n\n## 2.1. Trajets en automobile\nAuto.1 <- detailed_itineraries(r5r_core = r5r_core,\n                                   origins = Adresse1,\n                                   destinations = StationMorency,\n                                   mode = \"CAR\",\n                                   shortest_path = FALSE,\n                                   drop_geometry = FALSE)\nAuto.2 <- detailed_itineraries(r5r_core = r5r_core,\n                               origins = StationMorency,\n                               destinations = Adresse1,\n                               mode = \"CAR\",\n                               shortest_path = FALSE,\n                               drop_geometry = FALSE)\n## 2.2. Trajets en vélo\nvelo.1 <- detailed_itineraries(à compléter)\nvelo.2 <- detailed_itineraries(à compléter)\n## 2.3. Trajets à pied\nmarche.1 <- detailed_itineraries(à compléter)\nmarche.2 <- detailed_itineraries(à compléter)\n\n## 2.4. Trajets en transport en commun\ndateheure.matin <- as.POSIXct(\"12-02-2024 08:00:00\",\n                              format = \"%d-%m-%Y %H:%M:%S\")\ndateheure.soir  <- as.POSIXct(\"12-02-2024 18:00:00\",\n                              format = \"%d-%m-%Y %H:%M:%S\")\n### Définir le temps de marche maximal\nminutes_marches_max <- 20\nTC.1 <- detailed_itineraries(à compléter)\nTC.2 <- detailed_itineraries(à compléter)\n\n\n# 4. Cartographie\n  # - Map1.Aller : Marche (de la résidence à la station de métro)\n  # - Map2.Aller : Vélo (de la résidence à la station de métro)\n  # - Map3.Aller : Auto (de la résidence à la station de métro)\n  # - Map4.Aller : Transport en commun (de la résidence à la station de métro)\ntmap_mode(view)\nMap1.Aller <- tm_shape(marche.1)+tm_lines(col=\"mode\", lwd = 3,\n                                      popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                     \"segment_duration\", \"distance\",\n                                                     \"total_duration\", \"total_distance\"))+\n              tm_shape(Adresse1)+tm_dots(col=\"green\", size = .15)+\n              tm_shape(StationMorency)+tm_dots(col=\"red\", size = .15)\n\nMap2.Aller <- à compléter\nMap3.Aller <- à compléter\nMap4.Aller <- à compléter\n\ntmap_arrange(Map1.Aller, Map2.Aller, Map3.Aller, Map4.Aller, ncol = 2, nrow = 2)\n\n## Réaliser une figure avec quatre figures pour les trajets retour :\n  # - Map1.Retour : Marche (de la station de métro à la résidence)\n  # - Map2.Retour : Vélo (de la station de métro à la résidence)\n  # - Map3.Retour : Auto (de la station de métro à la résidence)\n  # - Map4.Retour : Transport en commun (de la station de métro à la résidence)\n\nMap1.Retour <- tm_shape(marche.2)+tm_lines(col=\"mode\", lwd = 3,\n                                          popup.vars = c(\"mode\", \"from_id\", \"to_id\",\n                                                         \"segment_duration\", \"distance\",\n                                                         \"total_duration\", \"total_distance\"))+\n  tm_shape(Adresse1)+tm_dots(col=\"red\", size = .15)+\n  tm_shape(StationMorency)+tm_dots(col=\"green\", size = .15)\n\nMap2.Retour <- à compléter\nMap3.Retour <- à compléter\nMap4.Retour <- à compléter\n\ntmap_arrange(Map1.Retour, Map2.Retour, Map3.Retour, Map4.Retour, ncol = 2, nrow = 2)\n\n# 5.  Arrêt de java\nr5r::stop_r5(r5r_core)\nrJava::.jgc(R.gc = TRUE)\n```\n\nCorrection à la [section @sec-12051].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 2.** Calcul d'isochrones\n:::\n\n::: bloc_exercice-body\nComplétez le code ci-dessous pour réaliser les étapes suivantes :\n\n1.  Calculez des isochrones à pied de 5, 10 et 15 minutes.\n\n2.  Calculez des isochrones à vélo de 5, 10 et 15 minutes.\n\n3.  Cartographiez les résultats.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false \n#| eval: false\nlibrary(sf)\nlibrary(tmap)\nlibrary(r5r)\n\n## Construction du réseau\nsetwd(\"data/chap05/Laval\")\nrJava::.jinit()\noptions(java.parameters = \"-Xmx2G\")\ndossierdata <- paste0(getwd(),\"/_DataReseau\")\nlist.files(dossierdata)\nr5r_core <- setup_r5(data_path = dossierdata,\n                     elevation = \"TOBLER\",\n                     verbose = FALSE, overwrite = FALSE)\n\n## Point pour la Station Morency\nStationMorency <- data.frame(id = \"Station Morency\",\n                             lon = -73.7199,\n                             lat = 45.5585,  45.5861)\nStationMorency <- st_as_sf(StationMorency, \n                           coords = c(\"lon\",\"lat\"), crs = 4326)\n\n# 1. Calcul d'isochrones à pied de 5, 10 et 15 minutes\nIso.Marche <- isochrone(à compléter)\n# 1.2. Isochrone à vélo de 5, 10 et 15 minutes\nIso.Velo <- isochrone(à compléter)\n\n# 3. Cartographie les résultats\ntmap_mode(\"view\")\ntmap_options(check.and.fix = TRUE)\nCarte.Marche <- tm_shape(à compléter)+\n                    tm_fill(à compléter)+\n                tm_shape(StationMorency)+tm_dots(col=\"darkred\", size = .25)\n\nCarte.Velo <- tm_shape(à compléter)+\n                    tm_fill(à compléter)+\n                tm_shape(StationMorency)+tm_dots(col=\"darkred\", size = .25)\n\ntmap_arrange(Carte.Marche, Carte.Velo, ncol = 2)\n\n# 4. Arrêt de java\nr5r::stop_r5(r5r_core)\nrJava::.jgc(R.gc = TRUE)\n```\n\nCorrection à la [section @sec-12052].\n:::\n:::\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["css/quizlib.min.css"],"output-file":"05-AnalyseReseau.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.6.42","license":"CC BY-SA","crossref":{"lof-title":"Liste des figures","lot-title":"Listes des tableaux","fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleRefs.csl","colorlinks":true,"theme":{"light":["cosmo","css/r4ds.scss"]},"fontsize":"11pt","mainfont":"Helvetica Neue,Helvetica,Arial,sans-serif","monofont":"SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":100,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"pdflatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","filters":["lua/callout_custom_pdf.lua"],"output-file":"Méthodes_analyses_spatiales.pdf","toc":true,"toc-depth":4,"include-in-header":["tex-hacks/color-tables.tex","tex-hacks/code-font.tex","tex-hacks/fix-unicode-chars.tex","tex-hacks/image-on-title-page.tex","tex-hacks/callout.tex"]},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"block-headings":true,"license":"CC BY-SA","lang":"fr","crossref":{"lof-title":"Liste des figures","lot-title":"Listes des tableaux","fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleRefs.csl","documentclass":"scrbook","papersize":"letter","classoption":["open=any","twoside=false","french"],"hyperrefoptions":["pdfpagemode=UseOutlines","pdfdisplaydoctitle=true","pdfpagelayout=SinglePage","pdfstartpage=1"],"geometry":["top=20mm","left=15mm","right=15mm","heightrounded"],"fontfamily":"libertinus","fontfamilyoptions":["p"],"lof":true,"lot":true,"code-block-border-left":false,"fontsize":"11pt","urlcolor":"Green4","citecolor":"violet","linkcolor":"violet","colorlinks":true,"header-includes":["\\usepackage{xparse}","\\renewcommand{\\thepart}{} % Enlever numérotation des parties","\\setcounter{secnumdepth}{3} % Activer la numérotation des sections jusqu'au niveau des sous-sections"]},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}