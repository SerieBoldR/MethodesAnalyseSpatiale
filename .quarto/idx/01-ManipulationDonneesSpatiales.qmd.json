{"title":"Manipulation des données spatiales dans R","markdown":{"headingText":"Manipulation des données spatiales dans R","headingAttr":{"id":"sec-chap01","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nDans ce chapitre, nous décrivons comment importer, manipuler et cartographier des données spatiales dans R. Pour une description plus détaillée du langage de programmation R -- objets et expression, opérateurs, structures de données (vecteurs, matrices, *arrays*, *DataFrame*), importation et manipulation de données --, lisez le chapitre intitulé [*Prise en main avec R*](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html) [@RBoldAir].\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n\n::: bloc_package-body\n-   Pour importer et manipuler des fichiers géographiques :\n    -   `sf` pour importer et manipuler des données vectorielles.\n    -   `rmapshaper` pour simplifier des géométries en conservant la topologie.\n    -   `terra` pour importer et manipuler des données *raster*.\n    -   `gpx` pour importer des coordonnées GPS au format *GPS eXchange Format*.\n    -   `foot` pour créer des enveloppes orientées sur les géométries.\n    -   `concaveman` pour créer des enveloppes concaves.\n-   Pour cartographier des données :\n    -   `ggplot2` est un *package* pour construire des graphiques qui peut être aussi utilisé pour visualiser des données spatiales.\n    -   `tmap` pour construire des cartes thématiques.\n    -   `RColorBrewer` pour construire une palette de couleur.\n    -   `ggpurb` pour combiner des graphiques et des cartes.\n-   Pour importer des tables attributaires :\n    -   `foreign` pour importer des fichiers *dBase*.\n    -   `xlsx` pour importer des fichiers Excel.\n:::\n:::\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Pas de panique!**\n:::\n\n::: bloc_attention-body\nCe document comprend de nombreuses notions sur l'importation, la manipulation et la cartographie de données spatiales dans R, soit des opérations que vous avez l'habitude de réaliser dans ArcGIS Pro ou QGIS.\n\nPrenez le temps de lire ce premier chapitre à tête reposée et assurez-vous de bien comprendre chaque notion avant de passer à la suivante. L'objectif n'est pas de maîtriser parfaitement la syntaxe R pour toutes les opérations dès la première semaine!\n\nVous allez manipuler de nombreuses données spatiales avec R au fil de la lecture du livre. Par conséquent, n'hésitez pas à revenir sur ce chapitre lorsque nécessaire; considérez-le comme un aide-mémoire.\n:::\n:::\n\n## Importation de données géographiques {#sec-011}\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n\n**Quels *packages* choisir pour importer et manipuler des données spatiales?**\n:::\n\n::: bloc_notes-body\nPour les données vectorielles, il existe deux principaux *packages* (équivalent d'une librairie dans Python) : `sp` [@PackageSP1; @PackageSP2] et `sf` [@PackageSF]. Puisque le *package* `sp` est progressivement délaissé par R, il est donc fortement conseillé d'utiliser `sf`.\n\nPour les données *raster*, il est possible d'utiliser les *packages* `raster` [@PackageRaster] et `terra` [@PackageTerra], dont le dernier, plus récent, semblerait plus rapide.\n\nCette transition de `sp` à `sf` et de `raster` à `terra` est assez récente et encore en cours durant l'écriture de ce livre. Il existe encore de nombreux *packages* basés sur `sp` et `raster`. Il est donc possible que vous ayez à les utiliser, car leur transition n'est peut-être pas encore effectuée. Notez que la façon dont ces anciens *packages* intègrent les données vectorielles et matricielles dans R est très différente de celle des nouveaux *packages*. À titre d'exemple, la fonction `sp::readOGR` lit un fichier *shapefile*, tout comme la fonction `sf::st_read`, mais la première produit un objet de type `SpatialDataFrame`, alors que la seconde produit un `tbl_df`. Dans le premier cas, les géométries et les données sont stockées dans deux éléments séparés, alors que dans le second cas, le `tbl_df` est un `data.frame` avec une colonne contenant les géométries.\n\nPour les personnes intéressées aux motivations ayant conduit à cette transition, consultez cet excellent [article de blog](https://r-spatial.org/r/2022/04/12/evolution.html). Il existe deux raisons principales : le mainteneur des *packages* `rgdal` et `rgeos` servant de fondation à `raster` et `sp` a pris sa retraite. À cela s'ajoutent le côté « vieille école » de ces *packages* (ayant plus de 20 ans!) et l'apparition de *packages* plus modernes. Il s'agit d'un bon exemple de ce qui peut arriver dans une communauté *open source* et des évolutions constantes de l'environnement R.\n\nEn résumé, privilégiez l'utilisation de `sf` et de `terra.`\n\nIl convient d'installer les deux *packages*. Notez que l'installation d'un *package* requiert une connexion Internet, car R accède au répertoire de *packages* *CRAN* pour télécharger le *package* et l'installer sur votre ordinateur. Cette opération est réalisée avec la fonction `install.packages(\"nom du package\").` Notez qu'une fois que le *package* est installé, il est enregistré localement sur votre ordinateur et y reste à moins de le désinstaller avec la fonction `remove.packages(\"nom du package\").`\n\nAutrement dit, il n'est pas nécessaire de les installer à chaque ouverture de R! Pour utiliser les fonctions d'un *package*, vous devez préalablement le charger avec la fonction `library(\"Nom du package\")` (équivalent à la fonction `import` de Python).\n\nPour plus d'informations sur l'installation et le chargement de *packages*, consultez la [section suivante](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html#sec-0123) [@RBoldAir].\n:::\n:::\n\n### Importation de données vectorielles {#sec-0111}\n\nLa fonction `st_read` de `sf` permet d'importer une multitude de formats de données géographiques, comme des fichiers *shapefile* (`shp`), *GeoPackage* (`GPKG`), *GeoJSON* (`geojson`), *sqlite* (`sqlite`), *geodatabase d'ESRI* (`FileGDB`), *Geoconcept* (`gxt`), *Keyhole Markup Language* (`kml`), *Geography Markup Language* (`gml`), etc.\n\n#### Importation d'un fichier *shapefile* {#sec-01111}\n\nLe code R ci-dessous permet d'importer des couches géographiques au format *shapefile*. Notez que la fonction `list.files(pattern = \".shp\")` renvoie préalablement la liste des couches *shapefile* présentes dans le dossier de travail.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n\n## Chargement des packages\nlibrary(\"sf\")\nlibrary(\"terra\")\nlibrary(\"tmap\")\nlibrary(\"ggplot2\")\nlibrary(\"ggpubr\")\nlibrary(\"foreign\")\nlibrary(\"xlsx\")\nlibrary(\"rmapshaper\")\nlibrary(\"RColorBrewer\")\n## Obtention d'une liste des shapefiles dans le dossier de travail\nlist.files(path = \"data/chap01/shp\", pattern = \".shp\")\n## Importation des shapefiles avec sf\nArrondissements <- st_read(\"data/chap01/shp/Arrondissements.shp\", quiet=TRUE)\nInstallationSport <- st_read(\"data/chap01/shp/Installations_sportives_et_recreatives.shp\", quiet=TRUE)\nPistesCyclables <- st_read(\"data/chap01/shp/Pistes_cyclables.shp\", quiet=TRUE)\nRues <- st_read(\"data/chap01/shp/Segments_de_rue.shp\", quiet=TRUE)\n```\n\nRegardons à présent la structure des couches importées. Pour ce faire, nous utilisons la fonction `head(nom du DataFrame, n=2)`; notez que le paramètre `n` permet de spécifier le nombre des premiers enregistrements à afficher. Les informations suivantes sont ainsi disponibles :\n\n-   `6 fields` : six champs attributaires (`TYPE`, `DETAIL`, `NOM`, `SURFACE`, `ECLAIRAGE`, `OBJECTID`).\n\n-   `Geometry type POINT` : le type de géométrie est **point**.\n\n-   `Bounding box:  xmin: -8009681 ymin: 5686891 xmax: -8001939 ymax: 5696536` : les quatre coordonnées définissant l'enveloppe de la couche.\n\n-   `Projected CRS: WGS 84 / Pseudo-Mercator` : la projection cartographique. Ici, une projection cartographique utilisée par Google Maps et OpenStreetMap.\n\n-   La géométrie est enregistrée dans le champ `geometry`. Pour le premier enregistrement, nous avons la valeur `POINT (-8001939 5686891)`, soit un point avec les coordonnées géographiques (x,y) entre parenthèses.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\nhead(InstallationSport, n=2)   # Visualisation des deux premiers enregistrements\nnames(InstallationSport)       # Noms de champs (colonnes)\nView(InstallationSport)        # Afficher l'ensemble de la table attributaire\n```\n\nExplorons les types de géométries et la projection des autres couches avec le code ci-dessous. En résumé, les types de géométries sont :\n\n-   Des géométries simples\n\n    -   `point` : un seul point.\n\n    -   `linestring` : une séquence de deux points et plus formant une ligne.\n\n    -   `polygon` : un seul polygone formé par une séquence de points pouvant contenir un ou plusieurs polygones intérieurs formant des trous.\n\n-   Des géométries multiples\n\n    -   `multipoint` : plusieurs points pour une même observation.\n\n    -   `multilinestring` : plusieurs lignes pour une même observation.\n\n    -   `multipolygon` : plusieurs polygones pour une même observation.\n\n-   Une collection de géométries (`Geometrycollection`) qui peut contenir différents types de géométries décrites ci-dessus pour une même observation.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\nhead(PistesCyclables, n=2)\nhead(Rues, n=2)\nhead(Arrondissements, n=2)\n```\n\nVisualisons quelques couches importées avec `ggplot()`.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n## Arrondissements et rues\nggplot()+ geom_sf(data = Arrondissements, lwd = .8)+\n  geom_sf(data = Rues, aes(colour = TYPESEGMEN))\n## Arrondissements, pistes cyclables et installations sportives\nggplot()+ geom_sf(data = Arrondissements, lwd = .8)+\n  geom_sf(data = PistesCyclables, aes(colour = NOM), lwd = .5)+\n  geom_sf(data = InstallationSport)\n```\n\n#### Importation d'une couche dans un *GeoPackage* {#sec-01112}\n\nPour importer une couche stockée dans un *GeoPackage* (GPKG), vous devez spécifier le fichier et la couche avec respectivement les paramètres `dsn` et `layer` de la fonction `st_read`. Le code ci-dessous permet d'importer les secteurs de recensement de la région métropolitaine de recensement de Sherbrooke pour l'année 2021. Notez que la fonction `st_layers(dsn)` permet d'obtenir la liste des couches contenues dans le fichier GPKG, avec le type de géométrie, les nombre d'entités spatiales et de champs, et la projection cartographique pour chacune d'elles.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n## Nom du fichier GPKG\nfichierGPKG <- \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\"\n## Liste des couches dans le GPKG\nst_layers(dsn=fichierGPKG, do_count = TRUE)\n## Importation d'une couche\nSR.RMRSherb <- st_read(dsn = fichierGPKG, \n                       layer = \"SherbSR\", quiet=TRUE)\n## Affichage des deux premiers enregistrements\nhead(SR.RMRSherb, n=2)\n## Visualisation rapide des secteurs avec ggplot\nggplot()+ geom_sf(data = SR.RMRSherb, lwd = .5)\n```\n\n#### Importation d'une couche dans une *geodatabase* d'ESRI {#sec-01113}\n\nLa logique est la même qu'avec un *GeoPackage*, nous spécifions le chemin de la *geodatabase* et la couche avec les paramètres `dsn` et `layer`.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\nAffectDuTerritoire <- st_read(dsn = \"data/chap01/geodatabase/Sherbrooke.gdb\", \n                              layer = \"AffectationsDuTerritoire\", quiet=TRUE)\n## Visualisation des affectations du sol avec ggplot\nggplot()+ geom_sf(data = AffectDuTerritoire, aes(fill = TYPE), lwd = .2)\n```\n\n#### Importation de données GPS {#sec-01114}\n\nEn géomatique appliquée, il est fréquent de collecter des données sur le terrain avec un appareil GPS. Les données ainsi collectées peuvent être enregistrées dans différents formats de données dépendamment de l'appareil GPS utilisé : *GPS eXchange Format* (GPX), *Garmin's Flexible and Interoperable Data Transfer* (FIT), *Training Center XML* (TCX), etc.\n\n##### Importation de coordonnées GPS longitude/latitude au format *csv* {#sec-011142}\n\nUne personne ayant collecté des données sur le terrain pourrait aussi vous les transmettre dans un fichier *csv* (fichier texte délimité par des virgules). Il convient d'importer le fichier de coordonnées GPS dans R dans un *DataFrame* (avec la fonction `read.csv`). Une fois importé, nous constatons qu'il comprend trois champs :\n\n-   `id` : un champ identifiant avec des valeurs uniques.\n\n-   `lon` : longitude.\n\n-   `lat` : latitude.\n\nLes points sont projetés en longitude/latitude (WGS84 long/lat, EPSG : 4326).\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n## Importation du fichier csv\nPointsGPS <- read.csv(\"data/chap01/gps/pointsGPS.csv\")\nhead(PointsGPS)\n```\n\nPour convertir le *DataFrame* en un objet `sf`, nous utilisons la fonction `st_as_sf` en spécifiant les champs pour les coordonnées et la projection cartographique.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n## Importation du fichier csv\nPointsGPS <- st_as_sf(PointsGPS, coords = c(\"lon\",\"lat\"), crs = 4326)\n```\n\nLes points ainsi créés sont localisés dans la ville de Sherbrooke.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| eval: false\n## Affichage des points avec le package tmap\nlibrary(\"tmap\")\ntmap_mode(\"view\") ## Mode actif de tmap\ntm_shape(PointsGPS)+\n  tm_dots(size = 0.05, shape = 21, col = \"red\")\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| eval: true\nlibrary(knitr)\n\nif(is_latex_output()) {\n  knitr::include_graphics(\"images/Chap01/gps.jpg\")\n}else{\n  library(\"tmap\")\n  tmap_mode(\"view\") ## Mode actif de tmap\n  tm_shape(PointsGPS)+\n  tm_dots(size = 0.05, shape = 21, col = \"red\")\n}\n```\n\n\n\n##### Importation de coordonnées GPS au format *GPX* {#sec-011141}\n\nLe format [GPX](https://fr.wikipedia.org/wiki/GPX_(format_de_fichier)) est certainement le format de stockage et d'échange de coordonnées GPS le plus utilisé. Les informations géographiques (x,y) et temporelles (date et heure) sont respectivement enregistrées en degrés longitude/latitude (projection WSG) (WGS84, EPSG : 4326) et en temps universel coordonné (UTC, format ISO 8601).\n\nPour importer un fichier GPX, nous utilisons le *package* `gpx`. S'il n'est pas installé sur votre ordinateur, lancez la commande `install.packages(\"gpx\")` dans la console de R; n'oubliez pas de le charger avec `library(\"gpx\")`! Ensuite, importez le fichier GPX avec la fonction `read_gpx`, enregistrez la trace GPS dans un *DataFrame* et convertissez-la en objet `sf`.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\nlibrary(\"gpx\")\n## Importation du fichier GPX\nTraceGPS <- read_gpx(\"data/chap01/gps/TraceGPS.gpx\")\n## Cette trace GPS comprend trois listes : routes, tracks et waypoints\n## Les points sont stockés dans tracks\nnames(TraceGPS)\n## Pour visualiser les données, il suffit de lancer la ligne\n## ci-dessous (mise en commentaire car le résultat est un peu long...)\n# head(TraceGPS)\nTraceGPS <- TraceGPS$tracks$`ID1_PA_2021-12-03_TRAJET01.gpx`\n## Conversion du DataFrame en objet sf\nTraceGPS <- st_as_sf(TraceGPS, coords = c(\"Longitude\",\"Latitude\"), crs = 4326)\n## Visualisation des premiers enregistrements\nhead(TraceGPS, n=2)\n```\n\nLa trace GPS correspond à un trajet réalisé à vélo à Abidjan (Côte d'Ivoire) le 3 décembre 2021. Cette trace a été obtenue avec une montre Garmin et comprend un point chaque seconde.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| eval: false\ntmap_mode(\"view\")\ntm_basemap(leaflet::providers$OpenStreetMap)+\ntm_shape(TraceGPS)+\n  tm_dots(size = 0.001, shape = 21, col = \"red\")\n```\n\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| eval: true\nlibrary(knitr)\n\nif(is_latex_output()) {\n  knitr::include_graphics(\"images/Chap01/gps_abidjan.jpg\")\n}else{\n  library(\"tmap\")\n  tmap_mode(\"view\")\n  tm_basemap(leaflet::providers$OpenStreetMap)+\n  tm_shape(TraceGPS)+\n  tm_dots(size = 0.001, shape = 21, col = \"red\")\n}\n```\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**La structure de la classe `sf`**\n:::\n\n::: bloc_aller_loin-body\nLa classe `sf` est composée de trois éléments (@fig-ClasseSf) :\n\n-   L'objet **`simple feature geometry (sfg)`** est la géométrie d'une observation. Tel que vu plus haut, elle est une géométrie simple (`point`, `linestring`, `polygon`), multiple (`multipoint`, `multilinestring`, `multipolygon`) ou une collection de géométries différentes (`Geometrycollection`). Pour définir chacune de ces géométries, nous utilisons les méthodes `st_point()`, `st_linestring()`, `st_polygon()`, `st_multipoint()`, `st_multilinestring()`, `st_multipolygon()` et `Geometrycollection()`.\n\n-   L'objet **`simple feature column (sfc)`** est simplement une liste de `simple feature geometry (sfg)`. Elle représente la colonne `geometry` d'une couche vectorielle `sf`.\n\n-   L'objet **`data.frame`** correspond à la table attributaire.\n\nUne **`simple feature`** correspond ainsi à une observation (ligne) d'un objet `sf`, soit une entité spatiale comprenant l'information sémantique (attributs) et l'information spatiale (géométrie).\n\n![Structure de la classe `sf`](images/Chap01/ClassSFFinal.png){#fig-ClasseSf width=\"90%\" fig-align=\"center\"}\n\nVoyons un exemple concret : créons une couche `sf` comprenant les trois entités spatiales décrites dans la @fig-ClasseSf.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n## Création des géométries : simple feature geometry (sfg)\npoint1 = st_point(c(-8001939, 5686891))\npoint2 = st_point(c(-8009681, 5696536))\npoint3 = st_point(c(-7998695, 5689743))\n## Création d'une liste de géométries : simple feature geometry (sfc)\n## avec la projection cartographique EPSG 3857\npoints_sfc = st_sfc(point1, point2, point3, crs = 3857)\n## Création de la table attributaire : objet data.frame\ntable_attr = data.frame(TYPE = c(\"Aréna\", \"Aréna\",\"Aréna\"),\n                       NOM = c(\"Aréna Eugène-Lalonde\", \n                               \"Aréna Philippe-Bergeron\",\n                               \"Centre Julien-Ducharme\"),\n                       OBJECTID = c(1, 2, 3))\n## Création de l'objet sf\nArena_sf = st_sf(table_attr, geometry = points_sfc)\n## Le résultat est bien identique à celui de la figure ci-dessus\nhead(Arena_sf)\n```\n:::\n:::\n\n### Importation de données *raster* {#sec-0112}\n\nLa fonction `terra::rast` permet d'importer des images de différents formats (GeoTiff, ESRI, ENVI, ERDAS, BIN, GRID, etc.). Nous importons ci-dessous cinq feuillets de [modèles numériques d'altitude (MNA) à l'échelle du 1/20000](https://www.donneesquebec.ca/recherche/dataset/modeles-numeriques-d-altitude-a-l-echelle-de-1-20-000) couvrant la ville de Sherbrooke. La @fig-MNA présente l'un d'entre eux.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-MNA\n#| fig-align: center\n#| fig-cap: \"Modèle numérique d'élévation au 1/20000 (feuillet f21e05_101)\"\n#| out-width: 65%\n## Liste des fichiers GeoTIFF dans le dossier\nlist.files(path=\"data/chap01/raster\", pattern = \".tif\")\n## Importation des fichiers\nf21e05_101 <- terra::rast(\"data/chap01/raster/f21e05_101.tif\")\nf21e05_201 <- terra::rast(\"data/chap01/raster/f21e05_201.tif\")\nf31h08_102 <- terra::rast(\"data/chap01/raster/f31h08_102.tif\")\nf31h08_202 <- terra::rast(\"data/chap01/raster/f31h08_202.tif\")\nf21e12_101 <- terra::rast(\"data/chap01/raster/f21e12_101.tif\")\n## Visualisation des informations sur l'image f21e05_101\nf21e05_101\n# Visualisation de l'image\nterra::plot(f21e05_101, \n     main=\"Modèle numérique d'altitude à l’échelle de 1/20 000 (f21e05_101)\")\n```\n\n## Manipulation de données vectorielles {#sec-012}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n***Package*** `sf` **et opérations géométriques**\n:::\n\n::: bloc_objectif-body\nLe *package* `sf` est une librairie extrêmement complète permettant de réaliser une multitude d'opérations géométriques sur des couches vectorielles comme dans un système d'information géographique (SIG). Notre objectif n'est pas de toutes les décrire, mais d'aborder les principales. Au fil de vos projets avec `sf`, vous apprendrez d'autres fonctions. Pour ce faire, n'hésitez pas à consulter :\n\n-   Une belle [*Cheatsheet*](https://github.com/rstudio/cheatsheets/blob/main/sf.pdf) sur `sf`. Allez y jeter un œil, cela vaut la peine!\n\n-   Sur le [site CRAN](https://cran.r-project.org/web/packages/sf/index.html) de `sf`, vous trouverez plusieurs vignettes explicatives (exemples de code documentés).\n\n-   La [documentation complète en PDF](https://cran.r-project.org/web/packages/sf/sf.pdf).\n\nLa syntaxe `methods(class = 'sfc')` renvoie la liste des méthodes implémentées dans le *package* `sf`. Pour accéder à l'aide en ligne de l'une d'entre elles, écrivez simplement `?Nom de la fonction` (ex. : `?st_buffer`).\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\nmethods(class = 'sfc')\n```\n:::\n:::\n\n### Fonctions relatives à la projection cartographique {#sec-0121}\n\nLes trois principales fonctions relatives à la projection cartographique des couches vectorielles sont :\n\n-   `st_crs(x)` pour connaître la projection géographique d'un objet `sf`.\n\n-   `st_transform(x, cr)` pour modifier la projection cartographique.\n\n-   `st_is_longlat(x)` pour vérifier si les coordonnées sont en degrés longitude/latitude.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n## Importation d'un shapefile pour la province de Québec\nProvinceQc <- st_read(\"data/chap01/shp/Quebec.shp\", quiet = TRUE)\n## La projection est EPSG:3347 - NAD83 / Statistics Canada Lambert,\n## soit la projection conique conforme de Lambert\nst_crs(ProvinceQc)\n## Reprojection de la couche en WGS84 long/lat (EPSG:4326)\nProvinceQc.4326 <- st_transform(ProvinceQc, crs = 4326)\n## longitude/latitude?\nst_is_longlat(ProvinceQc)\nst_is_longlat(ProvinceQc.4326)\n```\n\nLa @fig-Projections démontre bien que les deux couches sont projetées différemment.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| label: fig-Projections\n#| fig-cap: \"Deux projections cartographiques\"\n#| out-width: 75%\n#| fig-align: center\n\nMap1 <- ggplot()+geom_sf(data = ProvinceQc)+coord_sf(crs = st_crs(ProvinceQc))+\n        labs(subtitle = \"Conique conforme de Lambert (EPSG : 3347)\")\n\nMap2 <- ggplot()+geom_sf(data = ProvinceQc.4326)+coord_sf(crs = st_crs(ProvinceQc.4326))+\n        labs(subtitle = \"WGS84 long/lat (EPSG : 4326)\")\n\ncomp_plot <- ggarrange(Map1, Map2, ncol = 2, nrow = 1)\nannotate_figure(comp_plot,\n                top = text_grob(\"Province de Québec\",\n                                face = \"bold\", size = 12, just = \"center\")\n                )\n```\n\n### Fonctions d'opérations géométriques sur une couche {#sec-0122}\n\nIl existe une quinzaine de fonctions d'opérations géométriques sur une couche dans le *package* `sf` dont le résultat renvoie de nouvelles géométries ([voir la documentation suivante](https://r-spatial.github.io/sf/reference/geos_unary.html)). Nous décrivons ici uniquement celles qui nous semblent les plus utilisées :\n\n-   `st_bbox(x)` renvoie les coordonnées minimales et maximales des géométries d'un objet `sf`. Pour créer l'enveloppe d'un objet `sf`, il suffit donc d'écrire `st_as_sfc(st_bbox(x))`.\n\n-   `st_boundary(x)` renvoie les limites (contours) des géométries d'un objet `sf`.\n\n-   `st_convex_hull(x)` crée l'enveloppe convexe des géométries d'un objet `sf`.\n\n-   `st_combine(x)` regroupe les géométries d'un objet `sf` en une seule géométrie, sans les réunir ni résoudre les limites internes.\n\n-   `st_union(x)` fusionne les géométries d'un objet `sf` en une seule géométrie.\n\n-   `st_buffer(x, dist, endCapStyle = c(\"ROUND\", \"FLAT\", \"SQUARE\"), joinStyle = c(\"ROUND\", \"MITRE\", \"BEVEL\"))` crée des zones tampons d'une distance définie avec le paramètre `dist`. Cette fonction s'applique à des points, à des lignes et à des polygones.\n\n-   `st_centroid(x)` crée des points au centre de chaque géométrie d'un objet `sf`. Elle s'applique donc à des lignes et à des polygones.\n\n-   `st_point_on_surface(x)` crée un point au centre de chaque polygone d'un objet `sf` .\n\n-   `st_simplify(x, dTolerance)` simplifie les contours de géométries (lignes ou polygones) avec une tolérance exprimée en mètres (paramètre `dTolerance`) d'un objet `sf` .\n\n-   `st_voronoi(x, bOnlyEdges = TRUE)` crée des polygones de Thiessen, appelés aussi polygones de Voronoï pour des points. Attention, le paramètre `bOnlyEdges = TRUE` renvoie des lignes tandis que `bOnlyEdges = FALSE` renvoie des polygones.\n\n#### Enveloppe et union d'une couche {#sec-01221}\n\nLe code ci-dessous crée une enveloppe (en bleu) et un polygone fusionné (en rouge) pour les arrondissements de la ville de Sherbrooke (@fig-EnveloppeUnion). La couche résultante de l'opération `st_as_sfc(st_bbox(x))` est ainsi l'équivalent des outils `Emprise` de QGIS et `Minimum Bounding Geometry (Geometry Type = Envelope)` d'ArcGIS Pro.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Enveloppe sur les arrondissements de la ville de Sherbrooke\nArrond.Enveloppe <- st_as_sfc(st_bbox(Arrondissements))\n## Fusionne les géométries en une seule en résolvant les limites internes\nArrond.Union <- st_union(Arrondissements)\n```\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| label: fig-EnveloppeUnion\n#| fig-cap: \"Enveloppe sur une couche\"\n#| fig-align: center\n#| out-width: 65%\n\ntmap_mode(\"plot\")\ntm_shape(Arrond.Enveloppe) + tm_borders(col = \"blue\", lwd=2)+\n  tm_shape(Arrond.Union) + tm_borders(col = \"red\", lwd=2)+\n  tm_layout(frame = FALSE)+\n  tm_scale_bar(c(0,5,10))\n```\n\n#### Enveloppe orientée {#sec-01222}\n\nLa fonction `st_bbox` de `sf` produit des rectangles englobant des géométries qui sont orientées nord-sud. Il est possible de générer des rectangles orientés autour de géométries pour minimiser leur emprise et ainsi mieux représenter l'orientation de la géométrie initiale. Il n'existe pas de fonction dans `sf` pour le faire, mais le *package* `foot` offre une implémentation facile d'utilisation. Notez que `foot` n'est pas déposé sur CRAN et doit être téléchargé depuis *Github* avec la ligne de code ci-dessous.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| eval: false\ndevtools::install_github(\"wpgp/foot\", build_vignettes = FALSE)\n```\n\nLa couche résultante de l'opération `fs_mbr(x, returnShape = TRUE)` (@fig-EnveloppeOrientee, b) est ainsi l'équivalent des outils `Emprise orientée minimale (OMBB)` de QGIS et `Minimum Bounding Geometry (Geometry Type = Rectangle by area)` d'ArcGIS Pro.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n\n# devtools::install_github(\"wpgp/foot\", build_vignettes = TRUE) \nlibrary(foot, quietly = TRUE)\n## Rectangles (enveloppes) orientés \nrectangles_oriented <- fs_mbr(Arrondissements, returnShape = TRUE)\nrectangles_oriented <- st_as_sf(rectangles_oriented,\n                                crs = st_crs(Arrondissements))\nrectangles_oriented$NOM <- Arrondissements$NOM\n## Rectangles non orientés (nord-sud)\nst_bbox_by_feature = function(x) {\n  x = st_geometry(x)\n  f <- function(y) st_as_sfc(st_bbox(y))\n  do.call(\"c\", lapply(x, f))\n}\nrectangles <- st_as_sf(st_bbox_by_feature(Arrondissements),\n                       crs = st_crs(Arrondissements))\nrectangles$NOM <- Arrondissements$NOM\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| label: fig-EnveloppeOrientee\n#| fig-cap: \"Enveloppes classiques et orientées\"\n#| fig-align: center\n#| out-width: 65%\n\n## Cartographie\nCarte1 <- tm_shape(st_cast(rectangles,\"LINESTRING\")) +\n            tm_lines(col = \"NOM\", lwd = 4) + \n            tm_shape(Arrondissements) + \n            tm_borders('black') + \n            tm_layout(legend.show = FALSE, frame = FALSE, \n                      title = \"a. Enveloppes nord-sud\",\n                      title.size = 1.2)\nCarte2 <- tm_shape(st_cast(rectangles_oriented,\"LINESTRING\")) + \n            tm_lines(col = \"NOM\", lwd = 4) + \n            tm_shape(Arrondissements) + \n            tm_borders('black') + \n            tm_layout(legend.show = FALSE, frame = FALSE,\n                      title = \"b. Enveloppes orientées\",\n                      title.size = 1.2)\ntmap_arrange(Carte1, Carte2, nrow = 1, ncol = 2)\n```\n\n#### Centroïdes et centre de surface {#sec-01223}\n\nLe code ci-dessous extrait les centres géométriques, c'est-à-dire les centroïdes (en bleu) et les points à l'intérieur des polygones (en rouge) pour les arrondissements de la ville de Sherbrooke (@fig-CentroidesPointsInterieur). Ces deux opérations correspondent aux outils `centroïdes` et `Point dans la surface` de QGIS et `Feature to Point (avec l'option Inside)` d'ArcGIS Pro.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Centroïdes et points dans les polygones sur les arrondissements\nArrond.centroide <- st_centroid(Arrondissements)\nArrond.pointpoly <- st_point_on_surface(Arrondissements)\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| label: fig-CentroidesPointsInterieur\n#| fig-cap: \"Centroïdes et points à l'intérieur des polygones\"\n#| fig-align: center\n#| out-width: 65%\ntm_shape(Arrondissements) + tm_borders(col = \"black\", lwd=2)+\ntm_shape(Arrond.centroide) + tm_dots(size=0.3,col=\"blue\")+\ntm_shape(Arrond.pointpoly) + tm_dots(size=0.3,col=\"red\")+\ntm_layout(frame = FALSE)\n```\n\n#### Zone tampon (*buffer*) {#sec-01224}\n\nUne simple ligne de code permet de créer des zones tampons (équivalent des outils `Analyse vectorielle/Tampon` dans QGIS et `Buffer` dans ArcGIS Pro). Une fois les zones créées, utilisez la fonction `st_union` pour fusionner les tampons en un polygone (@fig-ZoneTampon).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Zones tampons de 1000 mètres autour des installations sportives et récréatives\nInstSports.buffer <- st_buffer(InstallationSport, dist = 1000)\n## Si vous souhaitez fusionner les zones tampons, utilisez la fonction st_union\nInstSports.bufferUnion <- st_union(InstSports.buffer)\n## Zones tampons de 500 mètres autour des lignes\nPistesCyclables.buffer <- st_buffer(PistesCyclables, dist = 500)\nPistesCyclables.bufferUnion <- st_union(PistesCyclables.buffer)\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| label: fig-ZoneTampon\n#| fig-cap: \"Zones tampons\"\n#| fig-align: center\n#| out-width: 65%\n\ntmap_mode(\"plot\")\nM1 <- tm_shape(InstSports.buffer) + tm_borders(col = \"black\", lwd=1) + tm_fill(col=\"azure2\")+\n      tm_shape(InstallationSport) + tm_dots(size=0.05,col=\"red\")+\n  tm_layout(frame = FALSE)\n        \nM2 <- tm_shape(InstSports.bufferUnion) + tm_borders(col = \"black\", lwd=1)+tm_fill(col=\"azure2\")+\n      tm_shape(InstallationSport) + tm_dots(size=0.05,col=\"red\")+\n  tm_layout(frame = FALSE)\n\nM3 <- tm_shape(PistesCyclables.buffer) + tm_borders(col = \"black\", lwd=1) + tm_fill(col=\"azure2\")+\n      tm_shape(PistesCyclables) + tm_lines(lwd=1,col=\"red\")+\n  tm_layout(frame = FALSE)\n        \nM4 <- tm_shape(PistesCyclables.bufferUnion) + tm_borders(col = \"black\", lwd=1)+tm_fill(col=\"azure2\")+\n      tm_shape(PistesCyclables) + tm_lines(lwd=1,col=\"red\")+\n  tm_layout(frame = FALSE)\n\ntmap_arrange(M1, M2, M3, M4, ncol = 2, nrow =2)\n```\n\nNotez que pour des polygones, il est possible de créer des polygones intérieurs comme suit : `st_buffer(x, dist = - Valeur)`. Par exemple, le code ci-dessous crée des polygones de 200 mètres autour et à l'intérieur du parc du Mont-Bellevue de la ville de Sherbrooke (@fig-ZoneTampon2).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Importation de la couche des aires aménagées de la ville de Sherbrooke\nAiresAmenag <- st_read(dsn = \"data/chap01/geodatabase/Sherbrooke.gdb\",\n                       layer = \"AiresAmenagees\", quiet = TRUE)\n## Sélection du parc du Mont-Bellevue\nMontBellevue <- subset(AiresAmenag, NOM == \"Parc du Mont-Bellevue\")\n## Création d'une zone tampon autour du parc\nMontBellevue.ZTA500 <- st_buffer(MontBellevue, dist = 200)\n## Création d'une zone tampon à l'intérieur du parc\nMontBellevue.ZTI500 <- st_buffer(MontBellevue, dist = -200)\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| label: fig-ZoneTampon2\n#| fig-cap: \"Zone tampon intérieure et zone tampon extérieure\"\n#| fig-align: center\n#| out-width: 65%\n\n## Visualisation avec tmap\ntmap_mode(\"plot\")\ntm_shape(MontBellevue.ZTA500) +tm_borders(col = \"red\", lwd=1)+\ntm_shape(MontBellevue) + tm_borders(col = \"black\", lwd=1) + tm_fill(col=\"azure2\")+\ntm_shape(MontBellevue.ZTI500) +tm_borders(col = \"blue\", lwd=1)+\ntm_layout(frame = FALSE)\n```\n\n#### Simplification de géométries {#sec-01225}\n\nLa simplification ou généralisation d'une couche de lignes ou de polygones permet de supprimer des sommets tout en gardant le même nombre de géométries dans la couche résultante. Cette opération peut être réalisée dans QGIS avec l'outil `simplifier` et dans ArcGIS Pro avec l'outil `Generalize`. Deux raisons principales peuvent motiver le recours à cette opération :\n\n-   La réduction de la taille du fichier, surtout si la couche est utilisée pour de la cartographie interactive sur Internet avec des formats vectoriels comme le SVG (*Scalable Vector Graphics*), le KML ou le GeoJSON.\n\n-   L'utilisation de la couche à une plus petite échelle cartographique nécessitant la suppression de détails.\n\nLe code suivant permet de simplifier les contours des arrondissements de la ville de Sherbrooke avec des tolérances de 250, 500, 1000 et 2000 mètres. Plus la valeur de la tolérance est élevée, plus les contours sont simplifiés (@fig-Simplification). Notez que l'algorithme de Douglas-Peucker [@douglas1973algorithms] a été implémenté dans la fonction `st_simplify`. Bien qu'intéressant, cet algorithme ne conserve pas les frontières entre les polygones.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Simplification des contours avec différentes distances de tolérance\nArrond.simplify250m <- st_simplify(Arrondissements, \n                                   preserveTopology = TRUE, \n                                   dTolerance = 250)\nArrond.simplify500m <- st_simplify(Arrondissements, \n                                   preserveTopology = TRUE, \n                                   dTolerance = 500)\nArrond.simplify1000m <- st_simplify(Arrondissements, \n                                    preserveTopology = TRUE, \n                                    dTolerance = 1000)\nArrond.simplify2000m <- st_simplify(Arrondissements, \n                                    preserveTopology = TRUE, \n                                    dTolerance = 2000)\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| label: fig-Simplification\n#| fig-cap: \"Simplification des contours de géométries\"\n#| fig-align: center\n#| out-width: 65%\n\ntmap_mode(\"plot\")\nM1 <- tm_shape(Arrond.simplify250m)+tm_borders(col = \"blue\", lwd=2)+tm_layout(frame = FALSE)\nM2 <- tm_shape(Arrond.simplify500m)+tm_borders(col = \"red\",  lwd=2)+tm_layout(frame = FALSE)\nM3 <- tm_shape(Arrond.simplify1000m)+tm_borders(col = \"green\", lwd=2)+tm_layout(frame = FALSE)\nM4 <- tm_shape(Arrond.simplify2000m)+tm_borders(col = \"purple1\",  lwd=2)+tm_layout(frame = FALSE)\ntmap_arrange(M1, M2, M3, M4, ncol = 2, nrow =2)\n```\n\nPour remédier au problème des frontières non conservées, utilisez l'algorithme de Visvalingam et Whyatt [-@visvalingam1993line] avec la fonction `ms_simplify` du *package* `rmapshaper` (@fig-SimplificationVisvalingam), tel qu'illustré dans le code ci-dessous. À titre de rappel, pour l'installer et le charger sur votre ordinateur, tapez dans la console : `install.packages(\"rmapshaper\")` et `library(\"rmapshaper\")`. Le paramètre `keep` permet de définir la proportion de points à retenir : plus sa valeur est faible, plus la simplification est importante.\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| label: fig-SimplificationVisvalingam\n#| fig-cap: \"Simplification des contours avec l'algorithme de Visvalingam–Whyatt\"\n#| fig-align: center\n#| out-width: 65%\n\n## Algorithme de Visvalingam–Whyatt\nArrond.simplifyV.005 <- rmapshaper::ms_simplify(Arrondissements,\n                          keep = .005, # proportion des points à retenir (entre 0 et 1)\n                          method = \"vis\",  # Algorithme Visvalingam \n                          keep_shapes = TRUE)\ntm_shape(Arrond.simplifyV.005)+tm_borders(col=\"red\")+\n  tm_layout(frame = FALSE)\n```\n\n#### Enveloppe convexe (*convex hull*) {#sec-01226}\n\nLe code ci-dessous permet de créer l'enveloppe convexe pour des points (@fig-ConvexHull). Notez que cette fonction peut également s'appliquer à des lignes et à des polygones. Elle correspond aux outils `Enveloppe convexe` de QGIS et `Feature to Point (avec l'option Convex hull)` d'ArcGIS Pro.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Enveloppe convexe autour des points GPS\nPointsGPS.Convexhull <- st_convex_hull(st_union(PointsGPS))\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| label: fig-ConvexHull\n#| fig-cap: \"Enveloppe convexe autour de points\"\n#| fig-align: center\n#| out-width: 65%\nggplot()+geom_sf(data = PointsGPS.Convexhull)+geom_sf(data = PointsGPS)\n```\n\n#### Enveloppe concave (*concave hull*) {#sec-01227}\n\nUne extension possible du polygone convexe est le polygone concave qui a une superficie plus réduite. Il n'existe pas de fonction dans `sf` qui l'implémente. Il faut donc installer un *package* supplémentaire, soit `concaveman`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\nlibrary(concaveman)\n## Convex hull autour des points GPS\nPointsGPS.Concavhull <- concaveman(PointsGPS)\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| label: fig-ConcaveHull\n#| fig-cap: \"Enveloppe concave autour de points\"\n#| fig-align: center\n#| out-width: 65%\nggplot()+geom_sf(data = PointsGPS.Concavhull)+geom_sf(data = PointsGPS)\n```\n\nNotez que comparativement au polygone convexe (@fig-ConcaveHull), le polygone concave peut auvoir plus d'une solution possible ([lire l'article suivant](https://portailsig.org/content/sur-la-creation-des-enveloppes-concaves-concave-hull-et-les-divers-moyens-d-y-parvenir-forme.html)). Plus spécifiquement, il faut choisir son degré de concavité. Dans la fonction `concaveman::concaveman`, le paramètre `concavity` prend une valeur numérique, qui, si elle tend vers l'infini, produit un polygone convexe (@fig-ConcaveHull2).\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| label: fig-ConcaveHull2\n#| fig-cap: \"Enveloppe concave autour de points\"\n#| fig-align: center\n#| out-width: 80%\n\nlibrary(ggpubr)\n# test avec plusieurs valeur de concavité\nconcav_values <- c(1,1.5,3,8)\nplots <- lapply(concav_values, function(i){\n  Concavhull <- concaveman(PointsGPS, concavity = i)\n  this_plot <- ggplot()+\n    geom_sf(data = Concavhull)+\n    geom_sf(data = PointsGPS)+\n    labs(subtitle = paste0(\"Concavité : \",i))+\n      theme(axis.text.x = element_blank(),\n            axis.text.y = element_blank(),\n            axis.ticks = element_blank())\n  return(this_plot)\n})\nggarrange(plotlist = plots)\n```\n\nDans QGIS, il existe plusieurs *plugins* permettant de générer des enveloppes concaves, ainsi qu'une fonction installée de base avec GRASS (`v.concave.hull`).\n\n### Fonctions d'opérations géométriques entre deux couches {#sec-01213}\n\nLes opérations entre deux couches sont bien connues et largement utilisées dans les SIG. Bien entendu, plusieurs fonctions de ce type sont disponibles dans `sf` et renvoient une nouvelle couche géographique `sf` :\n\n-   `st_intersection(x, y)` génère l'intersection entre les géométries de deux couches. À ne pas confondre avec la fonction `st_intersects(x, y)` qui permet de construire une requête spatiale.\n\n-   `st_union(x, y)` génère l'union entre les géométries de deux couches.\n\n-   `st_difference(x, y)` crée une géométrie à partir de `x` qui n'est pas en intersection avec `y.`\n\n-   `st_sym_difference(x, y)` crée une géométrie représentant les portions des géométries `x` et `y` qui ne s'intersectent pas.\n\n-   `st_crop(x, y, xmin, ymin, xmax, ymax)` extrait les géométries de `x` comprises dans un rectangle.\n\nEn guise de comparaison, toutes ces fonctions sont disponibles dans la boîte à outils de traitement de QGIS (dans le groupe `recouvrement de vecteur`) et les outils de la catégorie `Overlay du Geoprocessing` d'ArcGIS Pro. Le code ci-dessous illustre comment réaliser des intersections et des unions entre deux couches polygonales.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Importation des deux couches\npolysX <- st_read(\"data/chap01/shp/PolyX.shp\", quiet = TRUE)\npolysY <- st_read(\"data/chap01/shp/PolyY.shp\", quiet = TRUE)\n## Intersection des deux couches\n## Les géométries récupèrent les attributs des deux couches\nInter.XY <- st_intersection(polysX, polysY)\nhead(Inter.XY)\n## Intersection entre deux couches préalablement fusionnées : \n## Le résutat est une seule géométrie\nInter.XYUnion <- st_intersection(st_union(polysX), st_union(polysY))\n## Union des deux couches\nUnion.XY <- st_union(st_union(polysX), st_union(polysY))\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| eval: true\nZone <- st_buffer(st_union(st_union(polysX), st_union(polysY)), 20)\ntmap_mode(\"plot\")\nMapZone <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\ntm_shape(polysX)+tm_polygons(col = \"red\", alpha = .5, \n                            border.col =\"black\", lwd = 1)+\n                tm_text(text = \"X_id\", size = 1)+\ntm_shape(polysY)+tm_polygons(col = \"yellow\", alpha = .5, \n                            border.col =\"black\", lwd = 1)+\n                  tm_text(text = \"Y_id\", size = .8, col=\"black\")+\ntm_layout(main.title = \"Polygones X (rouge) et Y (jaune)\", main.title.size = .8)\n\nInter.XY$id <- 1:nrow(Inter.XY)     \nMapInter <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\ntm_shape(Inter.XY)+tm_polygons(col = \"tomato3\", alpha = .5, \n                            border.col =\"black\", lwd = 1)+\n                           tm_text(text = \"id\", size = .8)+\n  tm_layout(main.title = \"st_intersection(polysX, polysY)\",\n            main.title.size = .8)\nInter.XY$id <- NULL\n\nMapInterU <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\ntm_shape(Inter.XYUnion)+tm_polygons(col = \"tomato4\", alpha = .5, \n                            border.col =\"black\", lwd = 1)+\n  tm_layout(main.title = \"st_intersection(st_union(polysX), st_union(polysY))\",\n            main.title.size = .8)\n\nMapUnion <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\ntm_shape(Union.XY)+tm_polygons(col = \"tomato4\", alpha = .5, \n                            border.col =\"black\", lwd = 1)+\n  tm_layout(main.title = \"st_union(st_union(polysX), st_union(polysY))\",\n            main.title.size = .8)\n\ntmap_arrange(MapZone, MapInter, MapInterU, MapUnion, ncol=2, nrow=2)\n```\n\nLa fonction `st_intersection` peut aussi être utilisée comme la méthode `clip` dans un SIG (ArcGIS Pro ou QGIS). En guise d'exemple, dans le code ci-dessous, nous extrayons les points GPS localisés sur le territoire de la ville de Sherbrooke (@fig-Clip).\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| label: fig-Clip\n#| fig-cap: \"Fonction `st_intersection()` équivalente à la méthode clip dans un SIG\"\n#| fig-align: center\n#| out-width: 85%\n\n# Nous nous assurons que les deux couches ont la même projection\nPointsGPS <- st_transform(PointsGPS, st_crs(Arrond.Union))\n# Extraction des points\nPointsGPS.Sherb <- st_intersection(PointsGPS, Arrond.Union)\n# Visualisation avant et après\nCarte1 <- ggplot()+geom_sf(data = Arrond.Union)+geom_sf(data = PointsGPS)+\n          labs(subtitle = \"Avant l'intersection\")+\n          theme(axis.text.x = element_blank(),\n                axis.text.y = element_blank(),\n                axis.ticks = element_blank())\nCarte2 <- ggplot()+geom_sf(data = Arrond.Union)+geom_sf(data = PointsGPS.Sherb)+\n          labs(subtitle = \"Après l'intersection\")+\n          theme(axis.text.x = element_blank(),\n                axis.text.y = element_blank(),\n                axis.ticks = element_blank())\nggarrange(Carte1, Carte2, ncol = 2, nrow = 1)\n```\n\nQuelques lignes de code suffisent pour générer les différences de superposition entre les géométries de couches géographiques (@fig-Clip2).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Différences entre deux couches\nDiff.XY <- st_difference(st_union(polysX), st_union(polysY))\nDiff.YX <- st_difference(st_union(polysY), st_union(polysX))\nDiff.symXY <- st_sym_difference(st_union(polysY), st_union(polysX))\n```\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| label: fig-Clip2\n#| fig-cap: \"Différences de superposition entre des géométries de différentes couches\"\n#| fig-align: center\n#| out-width: 75%\n\ntmap_mode(\"plot\")\nMapInterU <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\ntm_shape(Inter.XYUnion)+tm_polygons(col = \"tomato4\", alpha = .5, \n                            border.col =\"black\", lwd = 1)\n\nMapDiffXY <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\n             tm_shape(Diff.XY)+\n             tm_polygons(col = \"red\", alpha = .5,border.col =\"black\", lwd = 1)+\n             tm_layout(main.title = \"st_difference(st_union(polysX), st_union(polysY))\", \n                       main.title.size = .8)\n\nMapDiffYX <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\n             tm_shape(Diff.YX)+\n             tm_polygons(col = \"yellow\", alpha = .5,border.col =\"black\", lwd = 1)+\n             tm_layout(main.title = \"st_difference(st_union(polysY), st_union(polysX))\", \n                       main.title.size = .8)\n\nMapSymDiffYX <- tm_shape(Zone)+tm_fill(col = NA, alpha = 0, border.col = NA, lwd = 0)+\n             tm_shape(Diff.symXY)+\n             tm_polygons(col = \"green\", alpha = .5,border.col =\"black\", lwd = 1)+\n             tm_layout(main.title = \"st_sym_difference(st_union(polysY), st_union(polysX))\",\n                       main.title.size = .8)\n\ntmap_arrange(MapZone, MapDiffXY, MapDiffYX, MapSymDiffYX, ncol=2, nrow=2)\n```\n\n### Fonctions de mesures géométriques et de récupération des coordonnées géographiques {#sec-0124}\n\nLes principales fonctions de mesures géométriques et de coordonnées géographiques sont :\n\n-   `st_area(x)` calcule la superficie des polygones ou des multipolygones d'une couche `sf` .\n\n-   `st_length(x)` calcule la longueur des lignes ou des polylignes d'une couche `sf` .\n\n-   `st_distance(x, y)` calcule la distance 2D entre deux objets `sf`, exprimée dans le système de coordonnées de référence.\n\n-   `st_coordinates(x)` renvoie les coordonnées géographiques de géométries.\n\nCi-dessous, nous affichons les superficies des quatre arrondissements, puis nous enregistrons les superficies en m^2^ et en km^2^ dans deux nouveaux champs dénommés `SupM2` et `SupKm2.`\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Superficie des polygones des arrondissements\nst_area(Arrondissements)\n## Ajout de champs de superficie dans la table attributaire\nArrondissements$SupM2 <- as.numeric(st_area(st_transform(Arrondissements, crs = 2949)))\nArrondissements$SupKm2 <- as.numeric(st_area(st_transform(Arrondissements, crs = 2949)))/1000000\nhead(Arrondissements, n=2)\n```\n\nDe manière très semblable, calculons la longueur de géométries étant des lignes ou des multilignes.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Longueurs en mètres\nPistesCyclables$longMetre <- as.numeric(st_length(st_transform(PistesCyclables, crs = 2949)))\nPistesCyclables$longKm <- as.numeric(st_length(st_transform(PistesCyclables, crs = 2949)))/10000\nhead(PistesCyclables, n=2)\n```\n\nPour calculer la longueur d'un périmètre, il faut préalablement récupérer son contour avec la méthode `st_boundary`, puis calculer la longueur avec `st_length`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Conversion des polygones en lignes\nArrond.Contour <- st_boundary(Arrondissements)\n## Calcul de la longueur et enregistrement dans deux nouveaux champs\nArrondissements$PerimetreMetre <- as.numeric(st_length(Arrond.Contour))\nArrondissements$PerimetreKm <- as.numeric(st_length(Arrond.Contour)) / 1000\nhead(Arrondissements)\n```\n\nCalculons désormais la distance 2D (euclidienne) entre les centres des arrondissements. Nous utilisons donc la fonction `st_distance(x)`, puisque nous avons une seule couche (`x = Arrond.pointpoly`).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Longueurs en mètres\nst_distance(Arrond.pointpoly)\n```\n\nAdmettons que nous souhaitons calculer la distance entre les centres des quatre arrondissements et l'hôtel de ville de Sherbrooke dont les coordonnées en degrés (WGS84, EPSG : 4326) sont les suivantes : -71.89306, 45.40417. Nous utilisons alors la fonction `st_distance(x, y)` dans laquelle les paramètres `x` et `y` sont les arrondissements et l'hôtel de ville. Quelques lignes de code suffisent à créer une couche pour l'hôtel de ville, à calculer les distances et à les stocker dans un nouveau champ attributaire de la couche arrondissement.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Création d'un objet sf pour l'hôtel de ville\nHotelVille <- data.frame(ID = 1,\n                         Nom = \"Hôtel de ville\",\n                         lon = -71.89306,\n                         lat = 45.40417)\nHotelVille <- st_as_sf(HotelVille, coords = c(\"lon\",\"lat\"), crs = 4326)\nhead(HotelVille)\n## Nous nous assurons que les deux couches ont la même projection\nHotelVille <- st_transform(HotelVille, st_crs(Arrond.pointpoly))\n## Calcul des distances\nArrondissements$DistHVMetre <- as.numeric(st_distance(Arrond.pointpoly,HotelVille))\nArrondissements$DistHVKm <- as.numeric(st_distance(Arrond.pointpoly,\n                                                   HotelVille)) / 1000\nhead(Arrondissements)\n```\n\nIl est fréquent de vouloir enregistrer les coordonnées géographiques dans des champs attributaires. Dans le code ci-dessous, nous créons deux champs (`x` et `y`) dans lesquels nous enregistrons les coordonnées géographiques des points au centre de la surface de chaque arrondissement. Pour ce faire, nous utilisons la méthode `st_coordinates` .\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Coordonnées des centres de la surface des polygones\nxy <- st_coordinates(st_point_on_surface(Arrondissements))\nhead(xy)\n## Enregistrement dans la couche Arrondissements. Notez que :\n## xy[,1] signale de récupérer toutes les valeurs de la première colonne, soit X\n## xy[,2] signale de récupérer toutes les valeurs de la deuxième colonne, soit Y\nArrondissements$X <- xy[,1] \nArrondissements$Y <- xy[,2]\n```\n\n### Jointures spatiales {#sec-0125}\n\nEn géomatique, il est fréquent de réaliser des jointures spatiales, soit une opération qui consiste à joindre les attributs d'une couche géographique à une autre à partir d'une relation spatiale. Prenons deux exemples construits avec les installations sportives et récréatives (couche `InstallationSport`) et les arrondissements de la ville de Sherbrooke (`Arrondissements`).\n\nPremièrement, pour les installations sportives et récréatives (couche `InstallationSport`), nous souhaitons ajouter dans la table attributaire les champs `NUMERO` et `NOM` issus de la couche des arrondissements de la ville de Sherbrooke (`Arrondissements`). Grâce à ces deux champs, nous pouvons connaître dans quel arrondissement chaque installation sportive est située.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Jointure spatiale avec le paramètre st_intersects\nInstallS.join <- st_join(InstallationSport, Arrondissements, join = st_intersects)\n## Visualisation des deux premiers enregistrements\nhead(InstallS.join, n=2)\n## Suppression des champs utiles\nInstallS.join[c(\"SupM2\", \"SupKm2\", \"PerimetreMetre\", \n                       \"PerimetreKm\", \"DistHVMetre\",  \"DistHVKm\")] <- list(NULL)\n## Modification des noms de champs : NOM.x et NOM.y\nnames(InstallS.join)[names(InstallS.join) == \"NOM.x\"] <- \"NomInstallation\"\nnames(InstallS.join)[names(InstallS.join) == \"NOM.y\"] <- \"NomArrondissement\"\nhead(InstallS.join, n=2)\n```\n\nDeuxièmement, une autre jointure classique consiste à dénombrer les points compris dans des polygones, soit une opération SIG communément appelée *POINT-IN-POLYGON*.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Sélection des points dans les polygones des arrondissements\n## Notez que la relation spatiale pour la jointure est st_contains\n## Nous aurions pu aussi utiliser st_intersects\nArrondissements$NbInstall = lengths(st_contains(Arrondissements, InstallationSport))\nhead(Arrondissements$NbInstall)\n```\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Autres relations spatiales à appliquer lors de la jointure spatiale**\n:::\n\n::: bloc_aller_loin-body\nAvec le paramètre `join` de la méthode `st_join`, il est possible de spécifier la jointure spatiale avec différentes méthodes : `st_contains_properly`, `st_contains`, `st_covered_by`, `st_covers`, `st_crosses`, `st_disjoint`, `st_equals_exact`, `st_equals`, `st_is_within_distance`, `st_nearest_feature`,`st_overlaps`, `st_touches` et `st_within`.\n\nN'hésitez pas à consulter la documentation de la fonction en tapant`?st_join` dans la console R.\n:::\n:::\n\n### Requêtes spatiales {#sec-0126}\n\nDans un logiciel SIG, la sélection d'entités spatiales par localisation est une opération courante, équivalente à *Select By Location* dans ArcGis Pro ou *Sélection par localisation* dans QGIS.\n\nLe *package* `sf` permet de réaliser des requêtes spatiales avec notamment les méthodes suivantes :\n\n-   `st_contains(x, y)` renvoie les géométries de `x` qui contiennent celles de `y`. Cette fonction est donc l'inverse de `st_within`.\n\n-   `st_disjoint(x, y)` renvoie les géométries de `x` qui ne partagent aucune portion de celles de `y`. Cette fonction est donc l'inverse de `st_intersects(x, y)`.\n\n-   `st_equals(x, y)` renvoie les géométries de `x` qui sont identiques à celles de `y`.\n\n-   `st_intersects(x, y)` renvoie les géométries de `x` qui partagent au moins une partie de celles de `y`. Elle est donc l'inverse de `st_disjoints(x, y)`.\n\n-   `st_nearest_feature(x, y)` renvoie, pour chaque géométrie `x`, la géométrie de `y` qui est la plus proche.\n\n-   `st_overlaps(x, y)` cette fonction est très semblable à `st_intersects(x, y)`. Toutefois, les types de géométries de `x` et de `y` doivent être identiques, c'est-à-dire deux couches de lignes ou de couches de polygones. Aussi, une géométrie ne peut pas contenir complètement l'autre comme avec `st_within(x, y)` et `st_contains(x, y)`.\n\n-   `st_touches(x, y)` renvoie les géométries de `x` qui sont tangentes à celles de `x` sans qu'elles se chevauchent. Par exemple, deux arrondissements peuvent se toucher, c'est-à-dire qu'ils partagent une frontière commune sans que l'un chevauche l'autre.\n\n-   `st_within(x, y)` renvoie les géométries de `x` qui sont comprises intégralement dans celles de `y`. Cette fonction est donc l'inverse de `st_contains(x, y)`.\n\n-   `st_within_distance(x, y, dist =)` renvoie les géométries de `x` qui sont situées à une certaine distance euclidienne de celles de `y`.\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Modification de l'affichage du résultat de la requête spatiale : le paramètre** `sparse`\n:::\n\n::: bloc_astuce-body\nPar défaut, le résultat d'une requête spatiale renvoie une liste d'indices pour les géométries `x` et `y`. Il est aussi possible de renvoyer la matrice complète entre `x` et `y`, avec les valeurs `TRUE` quand la relation spatiale est vérifiée et `FALSE` pour une situation inverse.\n\nPrenons deux exemples pour illustrer le tout.\n\nLa figure ci-dessous représente les quatre arrondissements de la ville de Sherbrooke. Notez que les numéros correspondent aux indices des géométries.\n\n```{r}\n#| echo: false \n#| message: false \n#| warning: false\n#| out-width: 50%\nhead(st_drop_geometry(Arrondissements[c(\"NUMERO\",\"NOM\")]))\ntmap_mode(\"plot\")\ntm_shape(Arrondissements) + tm_borders(col = \"black\", lwd=1) + tm_fill(col=\"lightgreen\")+\n                    tm_text(text = \"NUMERO\", size = 1.5, col=\"black\")\n```\n\nAppliquons une requête spatiale entre les arrondissements avec `st_intersects` et `sparse = TRUE`. Pour chaque arrondissement, nous obtenons une liste des arrondissements qui l'intersectent.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\nst_intersects(Arrondissements, Arrondissements, sparse = TRUE)\n```\n\nAvec `sparse = FALSE`, nous obtenons une matrice complète de dimension 4 X 4 arrondissements. Nous constatons que l'arrondissement `1` intersecte lui-même (évidemment!) et les arrondissements `2` et `4`, mais il n'intersecte pas le `3`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\nst_intersects(Arrondissements, Arrondissements, sparse = FALSE)\n```\n:::\n:::\n\nConstruisons des requêtes plus complexes comprenant deux couches.\n\nPremièrement, écrivons une requête spatiale pour sélectionner les segments des pistes cyclables qui intersectent le parc du Mont-Bellevue. Pour ce faire, nous utilisons la fonction `st_intersects` avec l'argument `sparse = FALSE` et enregistrons le résultat dans un nouveau champ dénommé `ParcMB.intersect` qui prendra les valeurs `TRUE` ou `FALSE`.\n\n```{r}\n#| echo: false \n#| message: false \n#| warning: false\n#| out-width: 75%\ntmap_mode(\"plot\")\ntm_shape(MontBellevue) + tm_fill(col=\"lightgreen\")+ tm_borders(col = \"black\", lwd=2)+\n  tm_text(text = \"NOM\", size = 1, col=\"black\")+\ntm_shape(PistesCyclables)+tm_lines(col=\"red\", lwd=1)\n```\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Intersection\nRequeteSpatiale <- st_intersects(PistesCyclables, MontBellevue, sparse = FALSE)\nhead(RequeteSpatiale)\n## Création d'un nouveau champ\nPistesCyclables$ParcMB.intersect <- RequeteSpatiale[, 1]\nhead(PistesCyclables)\n## Nous constatons qu'un seul segment intersecte le parc\ntable(PistesCyclables$ParcMB.intersect)\n## Création d'une nouvelle couche pour la sélection\nPistesCyclables.Selection <- PistesCyclables[PistesCyclables$ParcMB.intersect== TRUE, ]\n## Visualisation\ntm_shape(MontBellevue) + tm_fill(col=\"lightgreen\")+ tm_borders(col = \"black\", lwd=2)+\ntm_shape(PistesCyclables.Selection)+tm_lines(col=\"red\", lwd=1)\n```\n\nCréons une deuxième requête spatiale pour sélectionner les points GPS situés à moins de cinq kilomètres de l'hôtel de ville de Sherbrooke avec la méthode `st_is_within_distance`.\n\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| eval: false\ntmap_mode(\"view\")\ntm_shape(PointsGPS) + tm_dots(col=\"green\", size = .05) +\ntm_shape(HotelVille)+tm_dots(col=\"black\", size = .25)\n```\n\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| eval: true\nlibrary(knitr)\n\nif(is_latex_output()) {\n  knitr::include_graphics(\"images/Chap01/points5kmhoteldeville.jpg\")\n}else{\n    tmap_mode(\"view\")\n    tm_shape(PointsGPS) + tm_dots(col=\"green\", size = .05) +\n    tm_shape(HotelVille)+tm_dots(col=\"black\", size = .25)\n}\n```\n\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| eval: false\n## Requête spatiale\nRequeteSpatiale <- st_is_within_distance(PointsGPS, HotelVille, \n                                         5000, sparse = FALSE)\n## Ajout d'un champ pour la requête\nPointsGPS$HotelVille2km <- RequeteSpatiale[, 1]\n## Nous constatons que 17 points GPS sont à moins de 5 km\ntable(PointsGPS$HotelVille2km)\n## Création d'une nouvelle couche pour la sélection\nPointsGPS.selection <- PointsGPS[PointsGPS$HotelVille2km == TRUE, ]\n## Visualisation\ntm_shape(PointsGPS.selection) + tm_dots(col=\"red\", size = .05)+\ntm_shape(HotelVille)+tm_dots(col=\"black\", size = .25)\n```\n\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| eval: true\nlibrary(knitr)\n\nif(is_latex_output()) {\n  knitr::include_graphics(\"images/Chap01/points5kmhoteldeville_b.jpg\")\n}else{\n    ## Requête spatiale\n    RequeteSpatiale <- st_is_within_distance(PointsGPS, HotelVille, \n                                             5000, sparse = FALSE)\n    ## Ajout d'un champ pour la requête\n    PointsGPS$HotelVille2km <- RequeteSpatiale[, 1]\n    ## Nous constatons que 17 points GPS sont à moins de 5 km\n    table(PointsGPS$HotelVille2km)\n    ## Création d'une nouvelle couche pour la sélection\n    PointsGPS.selection <- PointsGPS[PointsGPS$HotelVille2km == TRUE, ]\n    ## Visualisation\n    tm_shape(PointsGPS.selection) + tm_dots(col=\"red\", size = .05)+\n    tm_shape(HotelVille)+tm_dots(col=\"black\", size = .25)\n}\n```\n\n\n\nFinalement, avec la méthode `st_within`, nous constatons que seuls deux points GPS sont situés dans le parc du Mont-Bellevue.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Requête spatiale\nRequeteSpatiale <- st_within(st_transform(PointsGPS, st_crs(MontBellevue)),\n                             MontBellevue, sparse = FALSE)\ntable(RequeteSpatiale[,1])\n```\n\n### Manipulation des données attributaires {#sec-0127}\n\nDans cette section, nous verrons comment importer une table attributaire, puis la joindre à une couche géographique, ajouter et calculer de nouveaux champs et réaliser des requêtes attributaires.\n\n#### Importation d'une table attributaire {#sec-01271}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Joindre les attributs d'une table externe à une couche vectorielle `sf`**\n:::\n\n::: bloc_objectif-body\nDans un SIG, joindre une table à une couche géographique vectorielle est une opération courante. Par exemple, il est fréquent de joindre des données socioéconomiques issues d'un recensement à une couche géographique (divisions de recensement, subdivisions de recensement, secteurs de recensement, aires de diffusion, etc.).\n\nPour ce faire, vous devez importer les données dans un *DataFrame* de R. Ces données peuvent être stockées dans différents formats de fichiers (texte délimité par des virgules (extension *csv*), *dBase* (*dbf*), Excel (*xlsx*)) ou dans des fichiers provenant de logiciels statistiques commerciaux comme Stata, SAS et SPSS (*dta*, *sas7bdat*, *sav*).\n\nDans cette section, nous voyons seulement l'importation de fichiers texte délimités par des virgules, de fichiers Excel et *dBase*. Concernant ce dernier type de fichier, notez que la table attributaire d'une couche Esri Shapefile est stockée dans un fichier *dBase*! Il peut être intéressant d'importer la table sans les géométries.\n\nPour une description détaillée de l'importation d'autres fichiers (entre autres Stata, SAS et SPSS), consultez la section intitulée [*Manipulation d'un DataFrame*](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html#sec-0142) [@RBoldAir].\n:::\n:::\n\nDans le code ci-dessous, nous voyons comment importer trois types de fichiers :\n\n-   `read.csv(file)` pour importer un fichier délimité par des virgules. Cette fonction est de base avec R, ce qui signifie qu'elle ne nécessite pas l'installation d'un *package*.\n\n-   `read.dbf(file)` pour importer un fichier *dBase*. Cette fonction est rattachée au *package* `foreign` que vous devez installer si ce n'est pas déjà fait (commande `install.packages(\"foreign\")`) et le charger (commande `library(\"foreign\")`).\n\n-   `read.xlsx(file)` pour importer un fichier Excel. Cette fonction est rattachée au *package* `xlsx` que vous devez installer si ce n'est pas déjà fait (commande `install.packages(\"xlsx\")`) et le charger (commande `library(\"xlsx\")`).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\nlibrary(\"xlsx\")      # package pour importer des fichiers Excel\nlibrary(\"foreign\")   # package pour importer des fichiers dBase\n## Importation du fichier csv\nt1 <- Sys.time()\ndfCSV <- read.csv(file = \"data/chap01/tables/SRQC2021.csv\",\n                    header = TRUE,\n                    dec = \".\",    # séparateur de décimales qui peut être remplacé par ,\n                    sep = \",\"     # séparateur des champs qui peut être remplacé par ;\n                    )\nt2 <- Sys.time()\ncat(\"temps de traitement (CSV) : \", \n    as.numeric(difftime(t2,t1,units=\"secs\")),\n    \" secondes\")\n\n## Importation d'un fichier Excel avec le nom de fichier et de la feuille Excel\n## sheetIndex = 1 signale l'importation de la première feuille Excel\nt1 <- Sys.time()\ndfExcel <- read.xlsx(file = \"data/chap01/tables/ADSRQC2021.xlsx\",\n                      sheetIndex = 2)\nt2 <- Sys.time()\ncat(\"temps de traitement (Excel) : \", \n    as.numeric(difftime(t2,t1,units=\"secs\")),\n    \" secondes\")\n\n## Importation du fichier dBase\nt1 <- Sys.time()\ndfDbf <- read.dbf(file = \"data/chap01/tables/ADQC2021.dbf\")\nt2 <- Sys.time()\ncat(\"temps de traitement (dBase) : \", \n    as.numeric(difftime(t2,t1,units=\"secs\")),\n    \" secondes\")\n```\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Exportation du fichier Excel dans un fichier texte**\n:::\n\n::: bloc_astuce-body\nLe temps nécessaire pour importer un fichier Excel est bien plus long que pour des fichiers texte et *dBase*! Par conséquent, si vous travaillez avec Excel, il est vivement conseillé de l'exporter vers un fichier texte (dans Excel, `Fichier/Enregistrer sous/type de fichier CSV`).\n:::\n:::\n\nQuelques lignes suffisent pour explorer la structure des données importées avec les fonctions `nrow`, `ncol`, `colnames` (respectivement le nombre de lignes, le nombre de colonnes et les noms des colonnes du `dataframe`).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Nombre de lignes et de colonnes\nnrow(dfCSV)\nncol(dfCSV)\ncat(\"le DataFrame dfCSV a\", nrow(dfCSV), \"lignes (observations)\",\n    'et', ncol(dfCSV), \"colonnes\\n\")\n## Noms des champs\ncolnames(dfCSV)\n## Affichage des deux premières observations\nhead(dfCSV, n=2)\n```\n\n#### Jointure attributaire avec la couche géographique `sf` {#sec-01272}\n\nLes données importées dans la table attributive proviennent du recensement de Statistique Canada de 2021 et sont ancrées au niveau des secteurs de recensement (SR) des régions métropolitaines de recensement (RMR) et des agglomérations de recensement (AR) du Québec. Pour les SR de la RMR de Sherbrooke, les données de la couche géométrique sont importées à partir d'un fichier shapefile. Aussi, nous constatons que les deux sources de données ont un champ commun `SRIDU`, soit l'identifiant unique des SR, mais que l'information y est présentée différemment :\n\n-   Dans la couche géographique `SR.RMRSherb` (objet *sf*), nous avons une observation avec la valeur `4470001.01`, soit un champ avec dix caractères.\n\n-   Dans la table attributaire `dfCSV` (*DataFrame*), nous avons une observation avec la valeur `4470001.01 (SR), Drummondville (RMR) (4470001.01) (00000)`.\n\nPar conséquent, avant d'appliquer une jointure, nous modifions le champ `SRIDU` de ce *DataFrame* afin qu'il ait aussi dix caractères avec la ligne de code suivante : `dfCSV$SRIDU <- substr(dfCSV$SRIDU, 1, 10)`. De la sorte, nous récupérons uniquement les dix premiers caractères.\n\nFinalement, la jointure est réalisée avec la fonction `merge` avec laquelle nous spécifions le résultat de la jointure (`SR.RMRSherbDonnees`), la couche géographique (`SR.RMRSherb`), la table attributaire (`dfCSV`) et le champ commun aux deux avec l'option (`by =\"SRIDU\"`) :\n\n`SR.RMRSherbDonnees <- merge(SR.RMRSherb, dfCSV, by = \"SRIDU\").`\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Importation des SR de la RMR de Sherbrooke\nSR.RMRSherb <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                       layer = \"SherbSR\", quiet=TRUE)\n## Visualisation des premiers enregistrements\nhead(as.data.frame(SR.RMRSherb), n=2)\nhead(dfCSV, n=2)\n## Modification du champ SRIDU du DataFrame dfCSV\ndfCSV$SRIDU <- substr(dfCSV$SRIDU, 1, 10)\n## Jointure attributaire avec la fonction merge\nSR.RMRSherbDonnees <- merge(SR.RMRSherb, \n                           dfCSV, \n                           by = \"SRIDU\")\n```\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Jointure avec deux champs ayant des noms différents**\n:::\n\n::: bloc_astuce-body\nEn résumé, une jointure attributaire s'écrit :\n\n`NouvelObjetSf <- merge(X, Y, by = \"Nom du champ commun pour la jointure\")`\n\navec `X` et `Y` étant respectivement l'objet `sf` (couche géographique) et la table attributaire à joindre. Si les champs pour la jointure ont des noms différents, il est possible d'écrire :\n\n`NouvelObjetSf <- merge(X, Y, by.x = \"Champ X pour la jointure\", by.y = \"Champ Y pour la jointure\")`\n\nCe type de jointure conserve uniquement les observations qui sont communes à la couche géographique et à la table attributaire. Concrètement, si une couche comprend 100 entités spatiales et la table attributaire uniquement 80 observations, la couche résultante (`NouvelObjetSf`) aura uniquement 80 entités spatiales (bien entendu, quand les valeurs concordent...).\n\nLorsque vous souhaitez quand même conserver toutes les entités spatiales de la couche géographique de départ, écrivez :\n\n`NouvelObjetSf <- merge(X, Y, by = \"Nom du champ commun pour la jointure\", all.x = TRUE)`\n\nDans la nouvelle couche `Sf`, les entités spatiales de `X` qui n'ont pas été appariées avec les observations de la table attributaire `Y` auront des valeurs nulles (`NA`) pour les champs de `X` ajoutés au `NouvelObjetSf`.\n\nPour obtenir plus d'informations sur les différentes variantes d'une jointure, tapez `?merge` dans la console.\n:::\n:::\n\n#### Ajout et calcul de champs {#sec-01273}\n\nDans la [section @sec-0124], nous avons vu comment ajouter des champs relatifs à la géométrie (aire, longueur, distance, coordonnées de centroïdes). Dans un SIG, il est courant de calculer de nouveaux champs à partir de champs existants dans la table attributaire (par exemple, avec les outils *Calculatrice de champ* dans QGIS ou *Calculate Field* dans ArcGIS Pro).\n\nCe type de traitement est aussi très simple à réaliser dans R. Pour ce faire, nous utilisons des [opérateurs mathématiques, relationnels et logiques](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html#sec-0135) comme dans n'importe quel logiciel de SIG. En guise d'exemple, nous calculons ci-dessous les pourcentages d'enfants de moins de 15 ans et de locataires. Ces pourcentages sont arrondis à deux décimales avec la fonction `round`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Création et cacul de nouveau champs\nSR.RMRSherbDonnees$PctPop0_14 <- round(SR.RMRSherbDonnees$Pop0_14 / \n                                     SR.RMRSherbDonnees$PopTotAge * 100, 2)\n\nSR.RMRSherbDonnees$PctLocataire <- round(SR.RMRSherbDonnees$Locataire / \n                                     SR.RMRSherbDonnees$TotalMenag2 * 100, 2)\n```\n\n#### Requêtes attributaires {#sec-01274}\n\nDans un SIG, il est fréquent de réaliser une requête attributaire pour explorer les données (par exemple, avec les outils *Select By Attributes* dans ArcGIS Pro et *Sélection avec expression* dans QGIS) et exporter le résultat de la requête dans une nouvelle couche (*Export Features* dans ArcGIS Pro et *Sauvegarder les entités sélectionnées sous...*).\n\nDans le code ci-dessous, vous trouverez plusieurs exemples de requêtes attributaires. Remarquez que les résultats des requêtes sont enregistrés dans de nouveaux objets `sf` (couches géographiques) dénommés `Requete1` à `Requete5`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n\n## Sélection de l'axe cyclable de la Magog\n#############################################\n# Affichage des valeurs uniques pour le champ NOM de la couche PistesCyclables\nunique(PistesCyclables$NOM)\n## Requête attributaire et enregistrement du résultat dans un nouvel objet sf\nRequete1 <- subset(PistesCyclables, NOM == \"Axe de la Magog\")\ncat(nrow(Requete1), \"enregistrements sélectionnés sur\", nrow(PistesCyclables))\n## Si vous souhaitez connaître uniquement le nombre d'enregistrements sélectionnés\n## sans créer un nouvel objet sf, il suffit d'écrire :\nnrow(subset(PistesCyclables, NOM == \"Axe de la Magog\"))\n\n## Sélection des SR dont la moitié ou plus des logements sont en location\n##########################################################################\n## Sommaire statistique sur le champ pourcentage de locataires\nsummary(SR.RMRSherbDonnees$PctLocataire)\n## Requête attributaire et enregistrement du résultat dans un nouvel objet sf\nRequete2 <- subset(SR.RMRSherbDonnees, PctLocataire >= 50)\ncat(nrow(Requete2), \"enregistrements sélectionnés sur\", nrow(SR.RMRSherbDonnees))\n\n## Sélection des installations sportives avec un éclairage dans \n## l'arrondissement des Nations (deux critères dans la requête)\n##########################################################################\nunique(InstallS.join$NomArrondissement)\ntable(InstallS.join$ECLAIRAGE)\n## Requête attributaire avec un opérateur AND (&)\nRequete3 <- subset(InstallS.join,\n                   NomArrondissement == \"Arrondissement des Nations\" & \n                   ECLAIRAGE == \"Oui\")\ncat(nrow(Requete3), \"enregistrements sélectionnés sur\", nrow(InstallS.join))\n\n## Sélection des SR avec deux critères et un opérateur OR (|)\n##########################################################################\n## Sommaires statistiques sur deux champs\nsummary(SR.RMRSherbDonnees$LoyerMoyen)\nsummary(SR.RMRSherbDonnees$ValeurMedLog)\n\n## Requête attributaire avec un opérateur OR \nRequete4 <- subset(SR.RMRSherbDonnees,\n                   LoyerMoyen < 700 | ValeurMedLog < 250000)\ncat(nrow(Requete4), \"enregistrements sélectionnés sur\", nrow(SR.RMRSherbDonnees))\n\n## Sélection de différents types d'installations sportives\n##########################################################################\nunique(InstallS.join$TYPE)\n## Requête attributaire avec un opérateur %in%\nRequete5 <- subset(InstallS.join,\n                             TYPE %in% c(\"Aréna\", \"Piscine\", \"Jeu d'eau\"))\ncat(nrow(Requete5), \"enregistrements sélectionnés sur\", nrow(InstallS.join))\n```\n\n## Manipulation de données matricielles (*raster*) {#sec-013}\n\nEn géomatique, les données matricielles (*raster*) sont une représentation de l'information spatiale sous forme d'une grille rectangulaire composée de cellules élémentaires de taille identique appelées pixels, soit une image. Chaque pixel a une valeur pour une caractéristique spécifique, comme l'altitude, la température, l'utilisation du sol, etc. Les données matricielles sont couramment employées dans les systèmes d'information géographique (SIG) pour la cartographie, l'analyse et la prise de décision en géomatique.\n\nDans cette section, nous abordons uniquement des fonctions simples de manipulation de données matricielles, notamment le mosaïquage et découpage d'images, et les requêtes attributaires sur des images.\n\n### Mosaïquage et découpage d'images {#sec-0131}\n\nUne fois plusieurs images importées, il est fréquent de vouloir les fusionner. Pour ce faire, nous utilisons deux méthodes du *package* `terra` :\n\n-   `terra::merge` fusionne plusieurs images (objets de type `SpatRasters`) pour former un nouvel objet `SpatRasters` dont l'étendue est recalculée en fonction des images fusionnées. Par contre, quand les images se chevauchent, les valeurs des pixels dans les zones de chevauchement seront prises dans le même ordre que les images.\n\n-   `terra::mosaic` fusionne aussi plusieurs images. Toutefois, dans les zones de chevauchement, les moyennes des pixels sont calculées. Selon la documentation de `terra`, cette méthode serait plus rapide que la précédente. Dans le code ci-dessous, nous fusionnons les feuillets de modèles numériques d'altitude (MNA) importés dans la [section @sec-0112].\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Les GeoTIFF importés avec terra sont bien des SpatRaster\nclass(f21e05_101)\n## Création d'une liste pour les cinq feuillets SpatRaster\nrlist <- list(f21e05_101, f21e05_201, f31h08_102,\n              f31h08_202, f21e12_101)\nrsrc <- sprc(rlist)\n## Création de la mosaïque\nMosaicSherb <- mosaic(rsrc)\nMosaicSherb\n```\n\nVous constatez ci-dessus que la projection des images est lon/lat NAD83 (EPSG:4269).\n\nD'autres fonctions permettent de découper une image en fonction d'une autre image (objet `SpatRaster` de `terra`) ou d'un objet `terra` vectoriel (`SpatVector`) :\n\n-   `crop(x, y)` découpe une image `x` en prenant l'étendue de `y`.\n\n-   `mask(x, y)` découpe une image `x` en prenant la zone (pixels avec des valeurs non nulles ou objets vectoriels) de `y`. Les pixels en dehors de cette zone auront nulle comme valeur (`NA` dans R).\n\nEn guise d'exemple, découpons la mosaïque avec le polygone de la ville de Sherbrooke en utilisant la méthode `mask`. Attention, les deux sources de données doivent avoir la même projection et il faut préalablement convertir l'objet `sf` en objet `SpatVector` de `terra`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n\n## Changement de projection pour le polygone de la ville de Sherbrooke\n## Application de la même projection que celle de la mosaïque\nVilleSherb.EPSG4269 <- st_transform(Arrond.Union, crs(MosaicSherb))\n# Convertir l'objet sf en un objet SpatVector de terra\nVilleSherb.SpatVector = vect(VilleSherb.EPSG4269)\n## Découpage de la mosaïque avec le polygone de la ville de Sherbrooke\nMosaicSherbCrop <- terra::mask(MosaicSherb, VilleSherb.SpatVector)\nMosaicSherbCrop\n## Constatez ci-dessus que le nom de l'image est f21e05_101.\n## Pour le changer, utilisez la fonction names()\nnames(MosaicSherbCrop) = \"Elevation\"\nMosaicSherbCrop\n## Visualisation du résultat\nplot(MosaicSherbCrop)\n```\n\n### Requêtes attributaires sur des images {#sec-0132}\n\nAvant d'effectuer une requête, il est judicieux d'explorer les valeurs des pixels de l'image avec un histogramme et la fonction `summary(Nom de l'image)` (valeurs minimales, maximales, quartiles, moyenne et valeurs nulles -- `NA`).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n\n## Sommaire statistique des valeurs\nsummary(MosaicSherbCrop)\n## Histogramme\nhist(MosaicSherbCrop,\n     main = \"Mosaïque du MNA pour la ville de Sherbrooke\",\n     xlab = \"Élévation (mètres)\", ylab = \"Fréquence\",\n     col = \"lightgreen\")\n## Histogramme en barre de 125 à 400 avec un saut de 25 mètres \nhist(MosaicSherbCrop,\n     main = \"Mosaïque du MNA pour la ville de Sherbrooke\",\n     xlab = \"Élévation (mètres)\", ylab = \"Fréquence\",\n     breaks = seq(from = 125, to = 400, by = 25),\n     col = \"lightgreen\")\n```\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n\n## Sélection des pixels avec une élévation d'au moins 300 mètres\nMosaicSherbCrop300 = clamp(MosaicSherbCrop, lower = 300)\nplot(MosaicSherbCrop300, \n     main = \"Pixels avec une élévation d'au moins 300 mètres\")\n## Sélection des pixels avec une élévation de 200 à 300 mètres\nMosaicSherbCrop200_300 = clamp(MosaicSherbCrop, lower = 200, upper = 300)\nplot(MosaicSherbCrop200_300,\n     main = \"Pixels avec une élévation de 200 à 300 mètres\")\n```\n\n## Exportation de données spatiales de R vers des formats géographiques {#sec-014}\n\n### Exportation de données vectorielles `sf` {#sec-0141}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Pourquoi exporter des objets `sf` vers différents formats géographiques?**\n:::\n\n::: bloc_objectif-body\nPlusieurs méthodes d'analyse de données spatiales ne sont pas implémentées dans les logiciels de SIG comme ArcGIS Pro ou QGIS d'où l'intérêt de recourir à R ou à Python. La démarche méthodologique classique comprend alors trois étapes :\n\n-   Importer des données géographiques.\n\n-   Réaliser des analyses avancées dans R ou Python.\n\n-   Exporter les résultats finaux vers différents formats géographiques (*shapefile*, *GeoPackage*, *geodatabase* d'ESRI, etc.).\n\nTrois raisons majeures motivent l'exportation des données :\n\n-   Cartographier les résultats finaux dans votre logiciel SIG préféré.\n\n-   Partager les données avec des personnes n'utilisant pas R.\n\n-   Réaliser éventuellement d'autres analyses dans votre logiciel de SIG préféré.\n:::\n:::\n\nDans la [section @sec-011], nous avons vu que la fonction `st_read()` du *package* `sf` permet d'importer une multitude de formats géographiques. Pour exporter avec `sf`, utilisez simplement la fonction `st_write()`. Le code ci-dessous illustre comment exporter des objets `sf` aux formats *shapefile* (`shp`), *GeoPackage* (`GPKG`), *Keyhole Markup Language* (`kml`) et *GeoJSON*. Par défaut, `st_write()` n'écrase pas un fichier existant; pour l'écraser, ajoutez le paramètre `append = FALSE`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n## Exportation au format shapefile\nst_write(PointsGPS, # couche sf\n         \"data/chap01/export/PointsGPS.shp\",  # chemin et nom du fichier\n         append = FALSE, # pour écraser le fichier s'il existe\n         driver = \"ESRI Shapefile\")\n## Exportation dans une couche dans GPKG\nst_write(PointsGPS, \n         dsn = \"data/chap01/export/Data.gpkg\", \n         layer = \"PointsGPS\",\n         append = FALSE, \n         driver = \"GPKG\")\n## Exportation vers un fichier KML\nst_write(PointsGPS, \n         dsn = \"data/chap01/export/PointsGPS.kml\", \n         append = FALSE,\n         driver=\"KML\")\n## Exportation vers un fichier GeoJSON\nst_write(PointsGPS, \n         dsn = \"data/chap01/export/PointsGPS.geojson\", \n         append = FALSE,\n         driver=\"GeoJSON\")\n```\n\nLe paramètre `driver` de la fonction `st_write` permet de spécifier le format du fichier. Pour obtenir la liste des formats qu'il est possible d'importer et d'exporter, tapez dans la console `st_drivers()` ou consultez le @tbl-ListeDrivers.\n\n```{r}\n#| label: tbl-ListeDrivers\n#| tbl-cap: Liste des formats avec le *package* `sf` (`st_drivers`)\n#| echo: false\n\ntemp <- data.frame(st_drivers())\ntemp$copy <- NULL\ntemp$vsi <- NULL\nknitr::kable(temp, \n             format.args = list(decimal.mark = ',', big.mark = \" \"),\n\t\t\t       col.names = c(\"Nom\",\"Description\", \"Écriture\",\"Si vecteur\", \"Si raster\"),\n             align = c(\"l\", \"r\", \"r\", \"r\"),\n\t\t\t       format=\"markdown\")\n```\n\n### Exportation de données *raster* {#sec-0142}\n\nL'exportation d'objets `SpatRasters` de `terra` est très simple avec la méthode `terra::writeRaster`. En guise d'exemple, le code ci-dessous exporte la mosaïque de MNA dans un fichier GeoTIFF. Notez que le paramètre `filetype` permet de spécifier d'autres formats d'images de la liste qui est disponible au lien suivant : [*https://gdal.org/drivers/raster/index.html*](https://gdal.org/drivers/raster/index.html). En guise d'exemple, les paramètres `EIR`, `ENVI`, `RST`, `ERS` et `GRASS` permettent d'exporter vers les logiciels de télédétection ERDAS, ENVI, Idrisi, ERMapper et GRASS, tandis que le paramètre `GPKG` permet d'exporter vers un *GeoPackage* raster.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| eval: false\nterra::writeRaster(MosaicSherbCrop, \"data/chap01/export/MosaicSherb.tif\", \n                   filetype = \"GTiff\", \n                   overwrite = TRUE)\n```\n\n## Cartographie avec R {#sec-015}\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n\n**Pourquoi cartographier des données dans R?**\n:::\n\n::: bloc_objectif-body\nVous avez certainement un logiciel de SIG préféré pour construire une carte thématique (QGIS ou ArcGIS Pro par exemple). Puisqu'en quelques clics de souris, il est facile de réaliser une carte dans un SIG, quel est donc l'intérêt d'écrire des lignes de code pour afficher une carte dans R? Autrement dit, pourquoi devriez-vous vous compliquer la vie à apprendre de la syntaxe R pour produire une simple carte? Savoir cartographier dans R a plusieurs avantages :\n\n-   Cartographier rapidement les résultats d'une analyse dans R permet d'éviter des allers-retours (exportation et importation de données) entre R et un logiciel de SIG. Or, la cartographie fait partie intégrante d'une démarche méthodologique d'analyse ou de modélisation spatiale. Vous restez ainsi dans le même environnement de travail (R) jusqu'à l'obtention de vos résultats finaux. Une fois ces derniers obtenus, vous pouvez les exporter et construire une carte très élaborée dans un logiciel de SIG.\n\n-   La syntaxe R n'est pas si compliquée. Quelques lignes de code écrites pour une première analyse peuvent être réutilisées, modifiées et bonifiées pour une autre analyse. Au fil de vos projets, vous construirez des cartes de plus en plus élaborées. Autrement dit, après quelques heures d'investissement, vous deviendrez une personne experte en cartographie dans R!\n:::\n:::\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n\n**Quels *packages* utiliser pour la cartographie dans R?**\n:::\n\n::: bloc_package-body\nIl existe plusieurs *packages* R pour la cartographie, notamment :\n\n-   `ggplot2` est certainement le meilleur *package* R pour réaliser des graphiques [@ggplot2Package]. Il permet désormais de construire des cartes.\n\n-   `cartography` permet de construire efficacement des cartes thématiques [@cartographyPackage]. Pour avoir une idée de son potentiel, consultez cette [*Cheatsheet*](http://riatelab.github.io/cartography/vignettes/cheatsheet/cartography_cheatsheet.pdf).\n\n-   `tmap` [@tmapArticle] est actuellement l'un des *packages* les plus complets et les plus utilisés pour construire des cartes thématiques.\n\n-   Des *packages* spécifiques permettent de créer des cartes interactives sur Internet, notamment `mapview`, `mapdeck` et `leaflet`. Ce dernier est basé sur la librairie JavaScript, largement utilisée dans le domaine de la cartographie sur Internet.\n\nDans cette section, nous utilisons uniquement `tmap` dont plusieurs ressources sont disponibles sur Internet :\n\n-   Sur le [site CRAN de `tmap`](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html), une excellente vignette intitulée *tmap: get started!*\n\n-   [Un article dans Journal of Statistical Software](https://doi.org/10.18637/jss.v084.i06) de Martijn Tennekes, créateur du *package* `tmap`.\n\n-   La [documentation complète en PDF](https://cran.r-project.org/web/packages/tmap/tmap.pdf).\n:::\n:::\n\n### Manipulation des couches géométriques {#sec-0151}\n\n#### Principales fonctions de représentation de couches vectorielles et matricielles {#sec-01511}\n\nIl existe trois catégories de fonctions pour paramétrer l'affichage de couches géographiques (@tbl-TmapMiseGeometrie).\n\n```{r}\n#| label: tbl-TmapMiseGeometrie\n#| tbl-cap: Principales fonctions pour manipuler des couches vectorielles et matricielles\n#| echo: false\n#| warning: false\n#| message: false\n\ndf1 <- data.frame(\n  Fonction = c(\"tm_shape\",\n               \"tm_polygons\", \"tm_symbols\", \"tm_lines\", \"tm_text\", \"tm_raster\",\n               \"tm_fill\", \"tm_border\", \"tm_bubbles\", \"tm_squares\", \"tm_dots\", \"tm_markers\"),\n  Description = c(\"Crée un élément tmap à partir d'une couche géographique vectorielle (sf) ou matricielle (raster)\",\n                  \"Dessine des polygones (couleur et contour)\", \n                  \"Dessine des symboles\", \n                  \"Dessine des lignes\", \n                  \"Dessine des étiquettes à partir d'un champ\", \n                  \"Affiche un raster\",\n                  \"Dessine l'intérieur de polygones\", \n                  \"Dessine les contours\", \n                  \"Dessine des cercles (notamment proportionnels)\", \n                  \"Dessine des carrés (notamment proportionnels)\", \n                  \"Dessine des points\", \n                  \"Dessine des icones avec étiquettes\"),\n  Points  = c(\"X\",\n              \" \", \"X\", \" \", \"X\", \" \",\n              \" \", \" \", \"X\", \"X\", \"X\", \"X\"),\n  Lignes = c(\"X\",\n             \" \", \"X\", \"X\", \"X\", \" \",\n             \" \", \" \", \"X\", \"X\", \"X\", \"X\"),\n  Polyg = c(\"X\",\n             \"X\", \"X\", \" \", \"X\", \" \",\n             \"X\", \"X\", \"X\", \"X\", \"X\", \"X\"),\n  Raster = c(\"X\", \n             \" \", \" \", \" \", \" \", \"X\",\n             \" \", \" \", \" \", \" \", \" \", \" \"))\n\nmy_table <- knitr::kable(df1,\n            format.args = list(decimal.mark = ',', big.mark = \" \"),\n\t\t\tcol.names = c(\"Fonction\",\"Description\", \"Points\", \"Lignes\", \"Polyg.\", \"Raster\"),\n              align=c(\"l\", \"r\", \"c\", \"c\", \"c\", \"c\"))\n\nkableExtra::pack_rows(my_table,\n                      index = c(\"Fonction principale\" = 1,\n                                 \"Fonctions de base de manipulation\" = 5,\n                                 \"Autres fonctions de manipulation\" = 6))\n```\n\n**Construction d'une carte simple avec une couche vectorielle et une couche matricielle**\n\nLe code ci-dessous permet d'afficher deux couches avec la fonction `tm_shape` : l'une vectorielle, l'autre matricielle (@fig-ArrondRaster1).\n\n```{r}\n#| echo: true \n#| eval: false \ntmap_mode(\"plot\")\n# 1er objet tmap pour une couche raster\ntm_shape(MosaicSherbCrop)+\n  tm_raster(palette = terrain.colors(10))+\n# 1er objet tmap pour une couche vectorielle\ntm_shape(Arrondissements)+\n  tm_borders(col = \"black\", lwd = 3)+ # contour noir avec une épaisseur de trois points\n  tm_text(\"NUMERO\") # Étiquettes identifiant l'arrondissement\n```\n\n![Exemple de carte construite avec le *package* `tmap` avec une couche polygonale et une image](images/Chap01/Carte1.png){#fig-ArrondRaster1 width=\"50%\" fig-align=\"center\"}\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Ordre et hiérarchie des couches avec `tmap`**.\n:::\n\n::: bloc_attention-body\nVous avez compris qu'une couche est affichée avec la fonction `tm_shape` et que le `+` permet d'ajouter une ou plusieurs fonctions d'habillage à cette couche (`tm_polygons`, `tm_lines`, `tm_text`, `tm_raster`, etc.).\n\nIl est possible d'en superposer en utilisant plusieurs `tm_shape` comme suit :\n\n`tm_shape(Nom de la première couche)+` `... paramètres de la couche +` `tm_shape(Nom de la seconde couche)+` `... paramètres de la couche`\n\nNotez que la première couche est celle avec laquelle la projection et l'étendue de la carte sont définies. Il est toutefois possible de changer le tout en utilisant l'argument `is.master = TRUE` dans le `tm_shape` d'une couche donnée.\n:::\n:::\n\n**Construction d'une carte avec plusieurs couches vectorielles**\n\nLes lignes de code suivantes permettent de construire la @fig-fig2PolyPointsLignes avec trois couches `sf`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-fig2PolyPointsLignes\n#| fig-align: center\n#| fig-cap: \"Exemple de carte construite avec le *package* `tmap` avec plusieurs couches vectorielles (polygones, lignes, points)\"\n#| out-width: 85%\ntmap_mode(\"plot\")\n## Polygones\ntm_shape(Arrondissements)+\n  tm_text(\"NUMERO\")+ # Étiquettes identifiant l'arrondissement\n  tm_polygons(col=\"wheat\", border.col = \"black\", lwd = 3)+\n## Lignes\ntm_shape(Rues)+\n  tm_lines(col= \"gray\", lwd = 1)+\n## Points\ntm_shape(PointsGPS.Sherb)+\n  tm_dots(shape=21, col=\"blue\", size=.3)\n```\n\nLa @fig-fig3PointsEtMarkers illustre la différence entre les fonctions `tm_dots` et `tm_markers`.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-fig3PointsEtMarkers\n#| fig-align: center\n#| fig-cap: \"Exemple de carte `tmap` avec `tm_dots` et `tm_markers`\"\n#| out-width: 85%\n\n## Points avec tm_dots()\nCartePoints <- \n  tm_shape(Arrondissements) + tm_polygons(col=\"wheat\", border.col = \"black\") +\n  tm_shape(PointsGPS.Sherb) + tm_dots(shape=21, col=\"blue\", size=.3)\n## Icones avec tm_markers()\nCarteMarkers <- \n  tm_shape(Arrondissements) + tm_polygons(col=\"wheat\", border.col = \"black\") +\n  tm_shape(PointsGPS.Sherb) + tm_markers(size = 0.2, border.col = rgb(0,0,0,0))\n## Combinaison des deux cartes\ntmap_arrange(CartePoints, CarteMarkers, ncol=2, nrow=1)\n```\n\n#### Couleurs uniques et palette de couleurs dans `tmap` {#sec-01512}\n\nVous avez remarqué plus haut que plusieurs fonctions comprennent l'argument `col` pour spécifier une couleur. Pour connaître les trois manières de spécifier une couleur dans R -- nom de la couleur R (`lightblue` par exemple), code hexadécimal (`#f03b20` par exemple) ou notation RVBA (`rgb(0.2, 0.4, 0.4, 0)` par exemple) --, consultez [la section suivante](https://serieboldr.github.io/MethodesQuantitatives/03-magiedesgraphiques.html#sec-0315) [@RBoldAir].\n\nPour spécifier une palette de couleurs sur un champ dans différentes fonctions (entre autres, `tm_polygons`, `tm_lines`, `tm_fill`, `tm_dots`), il suffit d'utiliser deux arguments dans la fonction, soit `col=\"Nom du champ\"` et `palette=\"nom de la palette de couleurs\"`.\n\nLe *package* `tmap` intègre les palettes de deux autres *packages* : `viridisLite` [@viridisPackage] et `RColorBrewer` [@RColorBrewerPackage]. Le premier propose cinq palettes de couleurs : `viridis`, `magma`, `plasma`, `inferno`, `cividis`. Le second intègre une série de palettes de couleurs proposées par la géographe et cartographe Cynthia Brewer et ses collègues [@harrower2003colorbrewer; @brewer2003colorbrewer]. Vous avez probablement déjà exploré [leur site Internet](https://colorbrewer2.org/) où il est possible de sélectionner une palette en fonction du nombre de classes, de la nature des données et de la codification des couleurs (HEX, RGB, CMYK). Succinctement, `RColorBrewer` propose plusieurs palettes regroupées selon trois catégories :\n\n-   Palettes qualitatives à appliquer à une variable qualitative nominale comme son nom l'indique (@fig-ColorBrewerQual). Pour afficher les palettes et connaître leurs noms, tapez `display.brewer.all(type=\"qual\")` dans la console.\n\n-   Palettes séquentielles pour une variable continue avec des valeurs faibles à fortes (@fig-ColorBrewerSeq). Tapez `display.brewer.all(type=\"seq\")` dans la console.\n\n-   Palettes divergentes à appliquer à une variable continue dont les valeurs aux deux extrémités s'opposent (@fig-ColorBrewerDiv). Tapez `display.brewer.all(type=\"div\")` dans la console.\n\n![Palettes de couleurs qualitatives du *package* `RColorBrewer`](images/Chap01/RcolorBrewerQual.png){#fig-ColorBrewerQual width=\"40%\" fig-align=\"center\"}\n\n![Palettes de couleurs séquentielles du *package* `RColorBrewer`](images/Chap01/RcolorBrewerSeq.png){#fig-ColorBrewerSeq width=\"40%\" fig-align=\"center\"}\n\n![Palettes de couleurs divergentes du *package* `RColorBrewer`](images/Chap01/RcolorBrewerDiv.png){#fig-ColorBrewerDiv width=\"40%\" fig-align=\"center\"}\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Comparaison de palettes avec un nombre de classes défini**\n:::\n\n::: bloc_astuce-body\nSi vous connaissez le nombre de classes, mais que vous hésitez à choisir telle ou telle palette de couleurs, tapez dans la console :\n\n-   `display.brewer.all(n=5, type=\"seq\", exact.n=TRUE)`\n-   `display.brewer.all(n=5, type=\"div\", exact.n=TRUE)`\n-   `display.brewer.all(n=5, type=\"qual\", exact.n=TRUE)`\n\nD'autres arguments peuvent être ajoutés comme `colorblindFriendly=TRUE` qui renvoie uniquement des palettes de couleurs adaptées aux personnes daltoniennes. En guise d'exemple, avec cinq classes, il est possible de comparer neuf palettes divergentes et six autres adaptées aux personnes daltoniennes (@fig-RcolorBrewerAstuce).\n\n![Palettes de couleurs divergentes du *package* `RColorBrewer` avec cinq classes](images/Chap01/RcolorBrewerAstuce.png){#fig-RcolorBrewerAstuce width=\"60%\" fig-align=\"center\"}\n\nVous hésitez encore à choisir une palette de couleurs? Tapez la syntaxe ci-dessous dans la console pour afficher l'ensemble des palettes des *packages* `RColorBrewer` et `viridisLite`.\n\n`tmaptools::palette_explorer()`\n\nPour inverser les couleurs d'une palette, vous devez précéder le nom de la palette par un signe moins (exemple : `-Greens`).\n:::\n:::\n\n#### Cartographie d'une variable qualitative : valeurs uniques {#sec-01513}\n\n**Application à une couche de points**\n\nLe code ci-dessous illustre comment construire une carte thématique avec des couleurs appliquées à une variable qualitative nominale (champ `TYPE` de la couche `InstallationSport`) d'une couche de points (@fig-CarteVarQualPoints).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CarteVarQualPoints\n#| fig-align: center\n#| fig-cap: \"Exemple de cartographie d'une variable qualitative sur des points\"\n#| out-width: 85%\n## Carte\ntm_shape(Arrondissements)+\n  tm_borders()+\ntm_shape(InstallationSport)+\n  tm_dots(shape = 21,\n          size=.3,\n          col= \"TYPE\", \n          palette = \"Set1\", \n          title =\"Type d'installation\")+\ntm_layout(main.title = \"Installations sportives\",\n          frame=FALSE,\n          legend.position = c(\"left\", \"top\"),\n          legend.outside=TRUE)\n```\n\n**Application à une couche de lignes**\n\nLe code ci-dessous illustre comment construire une carte thématique avec des couleurs appliquées à une variable qualitative nominale (champ `TYPESEGMEN`) d'une couche de lignes (@fig-CarteVarQualLignes).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CarteVarQualLignes\n#| fig-align: center\n#| fig-cap: \"Exemple de cartographie d'une variable qualitative sur des lignes\"\n#| out-width: 85%\n## Listes des valeurs uniques\ntable(Rues$TYPESEGMEN)\n## Lignes\ntmap_mode(\"plot\")\ntm_shape(Rues)+\n  tm_lines(col= \"TYPESEGMEN\",\n           palette = c(\"red\", \"brown4\", \"cornsilk1\", \"lightpink\", \"gainsboro\"),\n           lwd = 2 \n           )\n```\n\n**Application à une couche de polygones**\n\nLe code ci-dessous illustre comment construire une carte thématique avec des couleurs appliquées à une variable qualitative nominale (champ `SDRNOM` de la couche `AD2021`) d'une couche de polygones (@fig-CarteVarQualPoly).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CarteVarQualPoly\n#| fig-align: center\n#| fig-cap: \"Exemple de cartographie d'une variable qualitative sur des polygones\"\n#| out-width: 85%\n\n## Importation de la couche des aires de diffusion de 2021 pour la RMR de Sherbrooke\nAD2021 <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                  layer = \"SherbAD\", \n                  quiet = TRUE)\n## Carte\ntmap_mode(\"plot\")\ntm_shape(AD2021)+\n  tm_fill(col= \"SDRNOM\", \n          palette = \"Set2\", \n          lwd = 1, \n          title =\"Municipalité\")+\n  tm_borders(col=\"black\")+\ntm_layout(main.title = \"Aires de diffusion de 2021\",\n          frame =FALSE,\n          legend.position = c(\"left\", \"top\"),\n          legend.outside=TRUE)\n```\n\n#### Cartographie d'une variable discrète : cercles proportionnels {#sec-01514}\n\nLa syntaxe ci-dessous permet de créer une carte avec des cercles proportionnels pour les municipalités de la région administrative de l'Estrie (@fig-CarteCerclesProport).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CarteCerclesProport\n#| fig-align: center\n#| fig-cap: \"Exemple de carte avec des cercles proportionnels\"\n#| out-width: 85%\n\n## Importation des municipalités (subdivisions de recensements - SDR) de l'Estrie\nSDR.Estrie <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                  layer = \"sdr_Estrie\", quiet = TRUE)\n## Importation des MRC (divisions de recensements - DR) de l'Estrie\nDR.Estrie <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                  layer = \"DREstrie2021\",  quiet = TRUE)\n## Importation des données sur la population\nPopSDR <- read.csv(\"data/chap01/tables/SDR_Estrie.csv\")\nPopSDR$SDRidu <- as.character(PopSDR$SDRidu)\n## Fusion des données\nSDR.Estrie <- merge(SDR.Estrie, PopSDR, by.x = \"SDRIDU\", by.y = \"SDRidu\")\n## Construction de la carte\ntmap_mode(\"plot\")\ntm_shape(SDR.Estrie)+\n  tm_polygons(col=\"whitesmoke\", border.col = \"grey30\", lwd = 1)+\n  tm_bubbles(size = \"SDRpop_2021\",\n             border.col = \"black\",\n             col = \"tomato1\",\n             title.size = \"Population\",\n             scale = 3)+ # facteur multiplicateur pour la taille du cercle\ntm_shape(DR.Estrie)+\n  tm_borders(col=\"black\", lwd = 2)\n```\n\n#### Cartographie d'une variable continue : cartes choroplèthes et méthodes de discrétisation {#sec-01515}\n\nL'argument `style`, qui est commun à plusieurs fonctions (`tm_polygons`, `tm_fill`, `tm_lines`, `tm_dots`, etc.), permet de choisir une méthode de discrétisation dont les principales sont :\n\n-   `fixed`: intervalles fixés par l'analyste.\n\n-   `equal`: intervalles égaux.\n\n-   `pretty`: intervalles arrondis aux nombres entiers.\n\n-   `quantile`: selon les quantiles (même nombre d'observations dans chaque classe).\n\n-   `jenks`: selon la méthode de Jenks.\n\n-   `sd`: selon l'écart-type.\n\nD'autres méthodes peuvent être utilisées comme `kmeans`, `hclust`, `bclust`, `fisher`, `dpih`, `headtails` et `log10_pretty.` En guise d'exemple, la @fig-CarteChropolete2 présente une discrétisation en cinq classes selon la méthode des quantiles. Notez aussi qu'il est possible de réaliser une carte avec un dégradé continu avec `style = \"cont\"` tel qu'illustré ci-dessous (@fig-CarteChropolete1).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CarteChropolete1\n#| fig-align: center\n#| fig-cap: \"Exemple de carte choroplèthe avec une palette continue\"\n#| out-width: 85%\n\n## Sélection des aires de diffusion de Sherbrooke\nAD2021.sherb <- subset(AD2021, SDRNOM == \"Sherbrooke\")\n## Carte\ntmap_mode(\"plot\")\ntm_shape(AD2021.sherb)+\n  tm_fill(col= \"HabKm2\", \n          palette = \"Reds\",  \n          style = \"cont\",\n          title =\"Hab./km2\")+\n  tm_borders(col=\"black\")\n```\n\nLa @fig-CarteChropolete2 utilise une discrétisation selon la méthode de quantiles avec cinq classes. Autrement dit, chaque classe comprend 20 % des aires de diffusion de la ville de Sherbrooke.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CarteChropolete2\n#| fig-align: center\n#| fig-cap: \"Exemple de carte choroplèthe avec une discrétisation selon les quantiles\"\n#| out-width: 85%\n\ntmap_mode(\"plot\")\ntm_shape(AD2021.sherb)+\n  tm_fill(col= \"HabKm2\",\n          palette = \"Reds\",  \n          n = 5, # nombre de classes\n          style = \"quantile\",\n\t\t  legend.format = list(text.separator = \"à\"),\n          title =\"Hab./km2\")+\n  tm_borders(col=\"black\", lwd = .5)\n```\n\nLa @fig-MethoDiscretisation présente quatre méthodes de discrétisation différentes appliquées au revenu médian des ménages par secteur de recensement dans la région métropolitaine de recensement de Sherbrooke en 2021.\n\n![Différentes méthodes de discrétisation](images/Chap01/MethodesDiscretisation.png){#fig-MethoDiscretisation width=\"75%\" fig-align=\"center\"}\n\n### Cartes interactives {#sec-0152}\n\nAvec la fonction `tmap_mode`, il est possible de choisir l'un des deux modes de visualisation suivants :\n\n-   statique avec `tmap_mode(\"plot\")`.\n-   interactif avec `tmap_mode(\"view\")`.\n\nVous constaterez ci-dessous que par défaut, trois fonds de carte sont disponibles dans la carte interactive, soit dans l'ordre `Esri.WorldGrayCanvas`, `OpenStreetMap` et `Esri.WorldTopoMap`.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| eval: false\n\n## Mode active tmap\ntmap_mode(\"view\")\n## Importation des couches\nArrond.sf = read_sf(\"data/chap01/shp/Arrondissements.shp\")\nInstallSR.sf = read_sf(\"data/chap01/shp/Installations_sportives_et_recreatives.shp\")\n## Carte\ntm_shape(InstallSR.sf)+ tm_dots(size = 0.05, shape = 21, col = \"red\")+\ntm_shape(Arrond.sf)+ tm_borders(col=\"black\", lwd= .5)\n```\n\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| eval: true\nlibrary(knitr)\n\nif(is_latex_output()) {\n  knitr::include_graphics(\"images/Chap01/interactif_a.jpg\")\n}else{\n  ## Mode active tmap\n  tmap_mode(\"view\")\n  ## Importation des couches\n  Arrond.sf = read_sf(\"data/chap01/shp/Arrondissements.shp\")\n  InstallSR.sf = read_sf(\"data/chap01/shp/Installations_sportives_et_recreatives.shp\")\n  ## Carte\n  tm_shape(InstallSR.sf)+ tm_dots(size = 0.05, shape = 21, col = \"red\")+\n  tm_shape(Arrond.sf)+ tm_borders(col=\"black\", lwd= .5)\n}\n```\n\n\n\nIl est aussi possible de changer les fonds de carte avec la fonction `tm_basemap` tandis que la fonction `tm_tiles` permet de superposer une tuile (pour la toponymie par exemple) (@tbl-TmapCarteInteractive).\n\n```{r}\n#| label: tbl-TmapCarteInteractive\n#| tbl-cap: Fonctions pour des cartes interactives\n#| echo: false\n#| message: false\n#| warning: false\n\ndf2 <- data.frame(\n  Fonction = c(\"`tmap_mode`\", \n               \"`tm_basemap`\", \n               \"`tm_tiles`\"),\n  Description = c(\"Choisir le mode statique ou interactive\", \n                  \"Spécifier un fond de carte\", \n                  \"Spécifier une tuile de fond\")\n  )\nknitr::kable(df2, \n             col.names = c(\"Fonction\",\"Description\"),\n             align=c(\"l\", \"l\"),\n\t\t\t       format=\"markdown\")\n```\n\nDans le code ci-dessous, nous utilisons uniquement deux fonds de carte. Remarquez les lignes avec l'argument `popup.vars` qui permet de définir les champs visibles dans la fenêtre surgissante (*pop-up*). Cliquez sur une installation sportive pour activer la fenêtre surgissante.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n#| eval: false\n## Carte\ntm_basemap(c(\"OpenStreetMap\", \"Esri.WorldTopoMap\"))+\ntm_shape(InstallSR.sf)+ \n  tm_dots(size = 0.05, shape = 21, col = \"red\",\n          # définition pour le pop-up (clic sur une installation)\n          popup.vars=c(\"Nom : \"=\"NOM\",\n                       \"Type : \" = \"TYPE\",\n                       \"Éclairage : \" = \"ECLAIRAGE\",\n                       \"Éclairage : \" = \"SURFACE\"),\n          id = \"OBJECTID\")+\ntm_shape(Arrond.sf)+ tm_borders(col=\"black\", lwd= .5)\n```\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| eval: true\nlibrary(knitr)\n\nif(is_latex_output()) {\n  knitr::include_graphics(\"images/Chap01/gps.jpg\")\n}else{\n  tm_basemap(c(\"OpenStreetMap\", \"Esri.WorldTopoMap\"))+\n  tm_shape(InstallSR.sf)+ \n    tm_dots(size = 0.05, shape = 21, col = \"red\",\n            # définition pour le pop-up (clic sur une installation)\n            popup.vars=c(\"Nom : \"=\"NOM\",\n                         \"Type : \" = \"TYPE\",\n                         \"Éclairage : \" = \"ECLAIRAGE\",\n                         \"Éclairage : \" = \"SURFACE\"),\n            id = \"OBJECTID\")+\n  tm_shape(Arrond.sf)+ tm_borders(col=\"black\", lwd= .5)\n}\n```\n\n\n::: bloc_astuce\n::: bloc_astuce-header\n::: bloc_astuce-icon\n:::\n\n**Où trouver des fonds de carte?**\n:::\n\n::: bloc_astuce-body\nUne liste des fonds de carte **Leaflet** est disponible au [lien suivant](https://leaflet-extras.github.io/leaflet-providers/preview/).\n:::\n:::\n\n### Mise en page d'une carte {#sec-0153}\n\nLes principales fonctions de mise en page d'une carte sont présentées au @tbl-TmapMiseEnMap.\n\n```{r}\n#| label: tbl-TmapMiseEnMap\n#| tbl-cap: Fonctions d'habillage d'une carte\n#| echo: false\n#| warning: false\n#| message: false\n\n\ndf3 <- data.frame(\n  Fonction = c(\"`tm_facets`\", \"`tmap_arrange`\", \"`tm_grid`\", \"`tm_credits`\"),\n\n  Description = c(\"Créer un élément `tmap` avec plusieurs vignettes\",\n                  \"Fusionner plusieurs cartes dans une mise en page\",\n                  \"Ajouter une grille de lignes de coordonnées (ex. long/lat)\",\n                  \"Créer un texte pour spécifier l'auteur.e ou la source de la carte\"\n                  ),\n  \n  Arguments = c(\"`by`: groupé par colonne. `nrow` et `ncol`: nombres de lignes et de colonnes\",\n                \"`nrow` et `ncol`: nombre de lignes et de colonnes\",\n                \"`x` et `y`: vecteurs pour les coordonnées\",\n                \"`text`: texte. `size`: taille du texte. `fontfamily`: police du texte\")\n  )\n\n\ndf3 <- data.frame(\n  Fonction = c(\"`tm_facets`\", \"`tmap_arrange`\", \"`tm_grid`\", \"`tm_credits`\", \"`tm_scale_bar`\",\"`tm_compass`\", \"`tm_logo`\", \"`tm_xlab`\", \"`tm_ylab`\",\"`tm_layout`\", \"`tm_legend`\", \"`tmap_options`\"),\n\n  Description = c(\"Créer un élément `tmap` avec plusieurs  vignettes\",\n                  \"Fusionner plusieurs cartes dans une mise en page\",\n\n                  \"Ajouter une grille de lignes de coordonnées (ex. long/lat)\",\n                  \"Créer un texte pour spéficier l'auteur.e ou la source de la carte\",\n                  \"Créer une échelle\",\n                  \"Créer une flèche du nord\",\n                  \"Ajouter un logo à une carte\",\n                  \"Ajouter un titre sur l'axe des X de la carte\",\n                  \"Ajouter un titre sur l'axe des Y de la carte\",\n                  \"Spécifier des éléments de mise en page de la carte\",\n                  \"Paramétrer la légende de la carte\",\n                  \"Paramétrer et conserver plusieurs options sur la carte\"),\n\n  Arguments = c(\"`by`: groupé par colonne. `nrow` et `ncol`: nombres de lignes et de colonnes\",\n                \"`nrow` et `ncol`: nombre de lignes et de colonnes\",\n\n                \"`x` et `y`: vecteurs pour les coordonnées\",\n                \"`text`: texte. `size`: taille du texte. `fontfamily`: police du texte\",\n                \"`break`: vecteur numérique pour l'échelle. `position`: position de l'échelle avec les valeurs `left`, `center`, `right`, `bottom`, `top`. Par exemple c('left', 'bottom')\",\n                \"`type`: type de flèche du Nord ('arrow', '4star', '8star', 'radar', 'rose')\",\n                \"`file`: chemin et nom du fichier ou URL\",\n                \"`text`: nom de l'axe\",\n                \"`text`: nom de l'axe\",\n                \"`title`: titre de la carte\",\n                \"`position`: position de la légende avec les valeurs `left`, `center`, `right`, `bottom`, `top`\",\n                \"`unit`: unités de mesures ('imperial', 'km', 'm', 'mi', and 'ft')\")\n)\n\nknitr::kable(df3,\n             col.names = c(\"Fonction\",\"Description\", \"Principaux arguments\"),\n             align=c(\"l\", \"l\", \"l\"),\n\t\t\t       format=\"markdown\")\n```\n\n#### Combinaison de plusieurs cartes {#sec-01531}\n\nTel que décrit dans le @tbl-TmapMiseEnMap, il existe deux fonctions pour combiner deux cartes : `tmap_arrange` et `tm_facets`.\n\nPour ceux et celles réalisant régulièrement des graphiques dans R avec `ggplot2`, `tmap_arrange` est très similaire à la fonction `ggarrange` du *package* `ggpubr` qui permet de fusionner plusieurs graphiques. Globalement, le principe est le suivant : vous réalisez deux cartes ou plus que vous combinez dans une même sortie avec `tmap_arrange`. Vous trouverez ci-dessous un exemple avec deux cartes (@fig-CombinaisonAvecTmapArrange).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CombinaisonAvecTmapArrange\n#| fig-align: center\n#| fig-cap: \"Exemple de combinaisons de carte avec `tmap_arrange`\"\n#| out-width: 85%\n\ntmap_mode(\"plot\")\n## Carte 1\nCarte1 =  tm_shape(SDR.Estrie)+\n            tm_polygons(col=\"whitesmoke\", border.col = \"grey30\", lwd = 1)+\n            tm_bubbles(size = \"SDRpop_2021\",\n                       border.col = \"black\",\n                       col = \"tomato1\",\n                       title.size = \"Population\",\n                       scale = 3)+ # facteur multiplicateur pour la taille du cercle\n          tm_shape(DR.Estrie)+ tm_borders(col=\"black\", lwd = 2)\n## Calcul de la densité de population\nSDR.Estrie$HabKm2 <- as.numeric(SDR.Estrie$SDRpop_2021 / (st_area(SDR.Estrie) / 1000000))\n## Carte 2\nCarte2 =  tm_shape(SDR.Estrie)+\n              tm_fill(col= \"HabKm2\", \n                    palette = \"Reds\",  \n                    style = \"quantile\", n = 4,\n                    title =\"Hab./km2\",\n                    legend.format = list(text.separator = \"à\"))+\n              tm_borders(col=\"black\")+\n          tm_shape(DR.Estrie)+ tm_borders(col=\"black\", lwd = 2)\n## Combinaison des deux cartes\ntmap_arrange(Carte1, Carte2, ncol = 2, nrow = 1)\n```\n\nQuant à la fonction `tm_facets`, elle permet de créer plusieurs cartes avec l'argument `by`. Prenons un exemple concret : vous disposez d'une couche géographique des municipalités du Québec et vous souhaitez réaliser une carte pour chaque région administrative. L'argument `by = \"Region\"` vous permet alors d'avoir une vignette par région. Dans l'exemple ci-dessous, nous avons cartographié la même variable (densité de population) pour différentes zones de la région métropolitaine de Sherbrooke (@fig-CombinaisonAvecFacets1).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CombinaisonAvecFacets1\n#| fig-align: center\n#| fig-cap: \"Premier exemple de combinaison de cartes avec `tm_facets`\"\n#| out-width: 85%\ntmap_mode(\"plot\")\n## Création d'une variable zone basée sur les noms des municipalités\nAD2021$Zone <- ifelse(AD2021$SDRNOM == \"Sherbrooke\", \"A. Sherbrooke\", \"\") \nAD2021$Zone <- ifelse(AD2021$SDRNOM %in% c(\"Compton\", \"Waterville\", \"Hatley\", \"North Hatley\"), \n                      \"B. Sud\", AD2021$Zone) \nAD2021$Zone <- ifelse(AD2021$SDRNOM %in% c(\"Orford\", \"Magog\", \"Saint-Denis-de-Brompton\"), \n                      \"C. Est\", AD2021$Zone) \nAD2021$Zone <- ifelse(AD2021$SDRNOM %in% c(\"Ascot Corner\", \"Val-Joli\", \"Stoke\"), \n                      \"C. Nord\", AD2021$Zone) \n## Création des cartes avec tm_facets\ntmap_mode(\"plot\")\ntm_shape(AD2021)+\n  tm_fill(col= \"HabKm2\",\n          palette = \"Reds\",  \n          n = 5, # nombre de classes\n          style = \"quantile\",\n          title =\"Hab./km2\",\n          legend.format = list(text.separator = \"à\"))+\n  tm_borders(col=\"black\", lwd = .5)+\n  tm_facets(by = \"Zone\")\n```\n\nL'utilisation de `tm_facets` peut être également très utile pour comparer les distributions spatiales de points à différentes années (@fig-CombinaisonAvecFacets2).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-CombinaisonAvecFacets2\n#| fig-align: center\n#| fig-cap: \"Deuxième exemple de combinaisons de carte avec `tm_facets`\"\n#| out-width: 85%\ntmap_mode(\"plot\")\n## Importation des incidents\nIncidents <- st_read(\"data/chap01/shp/IncidentsSecuritePublique.shp\", quiet = TRUE)\n## Création des cartes avec tm_facets\ntmap_mode(\"plot\")\ntm_shape(Arrondissements) + \n  tm_polygons(col=\"wheat\", border.col = \"black\") +\ntm_shape(Incidents) +\n  tm_dots(shape=21, col=\"blue\", size=.2) +\ntm_facets(by = \"ANNEE\")\n```\n\n#### Mise en page d'une carte {#sec-01532}\n\nNous reprenons la @fig-HabillageDuneCarte et l'habillons en ajoutant une échelle (`tm_scale_bar`), une flèche du Nord (`tm_compass`), la source et l'auteur (`tm_credits`) et un titre (`tm_layout`) (@fig-HabillageDuneCarte).\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n#| label: fig-HabillageDuneCarte\n#| fig-align: center\n#| fig-cap: \"Habillage d'une carte\"\n#| out-width: 85%\n## Carte 1\ntmap_mode(\"plot\")\ntm_shape(SDR.Estrie)+\n            tm_fill(col= \"HabKm2\", palette = \"Greens\",  \n                    style = \"quantile\", n = 4,\n                    title =\"Hab./km2\",\n                    legend.format = list(text.separator = \"à\"))+\n            tm_bubbles(size = \"SDRpop_2021\", border.col = \"black\", col = \"tomato1\", scale = 3,\n                       title.size = \"Population\")+ \n            tm_borders(col=\"black\")+\n## Ajout de de la flèche du Nord\ntm_compass(position = c(\"right\", \"bottom\"), \n           size = 2)+\n## Ajout de l'échelle\ntm_scale_bar(breaks  = c(0, 25, 50),\n             position = c(\"right\", \"bottom\"))+\n## Ajout de la source\ntm_credits(\"Source : recensement de 2021, Statistique Canada\\nAuteur : Jéremy Lacartemplace.\", \n           position = c(\"right\", \"bottom\"),\n           size = 0.7,\n           align = \"right\") +\n## Légende  \ntm_legend(position = c(\"left\", \"top\"), \n          frame = FALSE, bg.color = \"white\")+\n## Modification de la mise en page\ntm_layout(main.title = \"Municipalités de l'Estrie\",\n          legend.outside = TRUE,\n          frame = FALSE)\n```\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Aller plus loin avec `tmap`?**\n:::\n\n::: bloc_aller_loin-body\nNous avons abordé uniquement les principales fonctions et arguments pour l'habillage d'une carte. Plusieurs exemples de très belles cartes créées avec `tmap` sont disponibles aux ressources suivantes :\n\n-   L'excellente vignette intitulée [*`tmap`: get started!*](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)\n\n-   [*Visualizing Spatial Data in R with tmap*](http://www.wvview.org/os_sa/10_Maps_with_tmap.html#visualizing-spatial-data-in-r-with-tmap).\n\n-   [*Making Maps with R*](https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html).\n\n-   Le chapitre [*Making maps with R*](https://geocompr.robinlovelace.net/adv-map.html) du livre [*Geocomputation with R*](https://geocompr.robinlovelace.net/index.html).\n:::\n:::\n\n### Exportation d'une carte {#sec-0154}\n\nUne fois la carte finalisée, il est possible de l'exporter dans différents formats avec la fonction `tmap_save` :\n\n-   En mode image (png, jpg, bmp, tiff) pour l'insérer dans un logiciel de traitement de texte (Word ou OpenOffice Writer) ou dans un éditeur LaTeX ([Overleaf](https://fr.overleaf.com/) par exemple).\n\n-   En mode vectoriel (PDF ou SVG) pour finaliser l'édition de la carte dans un logiciel de création graphique vectorielle (Illustrator par exemple).\n\n-   En HTML dans lequel la carte sera intégrée selon le mode de visualisation interactive, sous la forme d'un *widget* Leaflet.\n\n```{r}\n#| echo: true \n#| message: false \n#| warning: false\n\n## Transformation en long/lat\n## Carte 1\ntmap_mode(\"plot\")\nCarte1 <- tm_shape(SDR.Estrie)+\n  tm_fill(col= \"HabKm2\", palette = \"Greens\", style = \"quantile\", n = 4, title =\"Hab./km2\")+\n  tm_bubbles(size = \"SDRpop_2021\", border.col = \"black\", col = \"tomato1\", scale = 3,\n                       title.size = \"Population\")+ \n  tm_borders(col=\"black\")+\n  tm_compass(position = c(\"right\", \"bottom\"), size = 2)+\n  tm_scale_bar(breaks  = c(0, 25, 50), position = c(\"right\", \"bottom\"))+\n  tm_credits(\"Source : recensement de 2021, Statistique Canada\\nAuteur : Jéremy Lacartemplace.\", \n           position = c(\"right\", \"bottom\"), size = 0.7, align = \"right\") +\n  tm_legend(position = c(\"left\", \"top\"), frame = FALSE, bg.color = \"white\")+\n  tm_layout(main.title = \"Municipalités de l'Estrie\", legend.outside = TRUE, frame = FALSE)\n\n## Exportation de la Carte1 au format png\ntmap_save(Carte1, filename = \"data/chap01/export/Carte1.png\", dpi = 600)\n## Exportation de la Carte1 au format PDF\ntmap_save(Carte1, filename = \"data/chap01/export/Carte1.pdf\")\n## Exportation de la Carte1 au format HTML\ntmap_save(Carte1, filename = \"data/chap01/export/Carte1.html\")\n```\n\n## Quiz de révision du chapitre {#sec-016}\n\n```{r}\n#| label: quizChapitre01\n#| echo: false \n#| eval: true \n#| message: false \n#| warning: false \n#| results: asis\n\nsource(\"code_complementaire/QuizzFunctions.R\")\nChap01Quiz <- quizz(\"quiz/Chap01.yml\", \"Chap01\")\nrender_quizz(Chap01Quiz)\n```\n\n## Exercices de révision {#sec-017}\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 1.** Découpage des rues de l'arrondissement des Nations de la ville de Sherbrooke\n:::\n\n::: bloc_exercice-body\nComplétez le code ci-dessous avec les étapes suivantes :\n\n-   Requête attributaire pour créer un objet `sf` avec uniquement l'arrondissement des Nations à partir de la couche `Arrondissements` et le champ `NOM` (voir la [section @sec-01274]).\n\n-   Découpez les rues (`Rues`) sur le nouvel objet `sf` (voir la [section @sec-01213]).\n\n```{r}\n#| echo: true\n#| eval: false\n#| message: false\n#| warning: false\nlibrary(sf)\n## Importation des deux couches\nArrond <- st_read(\"data/chap01/shp/Arrondissements.shp\", quiet = TRUE)\nRues <- st_read(\"data/chap01/shp/Segments_de_rue.shp\", quiet = TRUE)\n## Requête attributaire : création d'un objet sf pour l'arrondissement des Nations\ntable(Arrond$NOM)\nArrond.DesNations <- subset(À compléter)\n## Découper les rues avec le polygone de l'arrondissement des Nations\nRues.DesNations <- À compléter\n```\n\nCorrection à la [section @sec-12011].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 2.** Calcul d'un nouveau champ\n:::\n\n::: bloc_exercice-body\nCalculez un nouveau champ (`DistHVKM`) dans la couche des aires de diffusion (AD) (`AD.RMRSherb`) qui représente la distance en kilomètres entre l'hôtel de ville de Sherbrooke et les points des AD. Puis, cartographiez le champ `DistHVKM` en quatre classes selon la méthode de discrétisation par quantiles. Complétez le code ci-dessous avec les étapes suivantes :\n\n-   Ajoutez un champ pour la distance (`DistHVKM`) dans la couche `AD.RMRSherb` (voir la [section @sec-0124]).\n\n-   Cartographiez le champ `DistHVKM` en quatre classes selon la méthode des quantiles (voir la [section @sec-01515]).\n\n```{r}\n#| echo: true\n#| eval: false\n#| message: false\n#| warning: false\nlibrary(sf)\nlibrary(tmap)\n## Importation des deux couches\nAD.RMRSherb <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                       layer = \"SherbAD\", quiet = TRUE)\nHotelVille <- data.frame(ID = 1, Nom = \"Hôtel de ville\",\n                         lon = -71.89306, lat = 45.40417)\nHotelVille <- st_as_sf(HotelVille, coords = c(\"lon\",\"lat\"), crs = 4326)\n## Changement de projection avant de s'assurer que les deux couches ont la même\nHotelVille <- st_transform(HotelVille, st_crs(AD.RMRSherb))\n## Ajout d'un champ pour la distance en km à l'hôtel de ville pour les secteurs de recensement\nAD.RMRSherb$DistHVKM <- À compléter\n## Cartographie en quatre classes selon les quantiles\ntmap_mode(\"plot\")\ntm_shape(À compléter)+\n  tm_fill(À compléter)+\n  tm_borders(col=\"black\")\n```\n\nCorrection à la [section @sec-12012].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 3.** Importation d'une couche *shapefile*\n:::\n\n::: bloc_exercice-body\nImportez une couche *shapefile* pour les divisions de recensement et calculez la densité de population (nombre d'habitants au km^2^). Complétez le code ci-dessous avec les étapes suivantes :\n\n-   Faites une jointure attributaire entre la couche `DR.Qc` et la table `DR.Data` (voir la [section @sec-01272]).\n\n-   Calculez le champ `HabKm2`, soit la division entre les champs `DRpop_2021` et `SUPTERRE` (voir la [section @sec-01515]).\n\n```{r}\n#| echo: true\n#| eval: false\n#| message: false\n#| warning: false\nlibrary(sf)\n## Importation de la couche des divisions de recensement du Québec\nDR.Qc <- st_read(dsn = \"data/chap01/gpkg/Recen2021Sherbrooke.gpkg\", \n                 layer = \"DivisionsRecens2021\", quiet = TRUE)\n## Importation du fichier csv des divisions de recensement\nDR.Data <- read.csv(\"data/chap01/tables/DRQC2021.csv\")\n## Jointure attributaire avec le champ IDUGD\nDR.Qc <- A compléter\n## Il y a déjà deux champs dans la table pour calculer la densité de population :\n## SUPTERRE : superficie en km2\n## DRpop_2021 : population en 2021\nDR.Qc$HabKm2 <- A compléter\nhead(DR.Qc, n=2)\nsummary(DR.Qc$HabKm2)\n```\n\nCorrection à la [section @sec-12013].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 4.** Coordonnées géographiques\n:::\n\n::: bloc_exercice-body\nVous recevez les coordonnées en degrés (WGS84, EPSG : 4326) : -71.91688, 45.37579. Créez un point pour cette localisation et calculez la distance la séparant du tronçon autoroutier le plus proche. Complétez le code ci-dessous avec les étapes suivantes :\n\n-   Faites une requête attributaire pour créer un objet `sf` avec uniquement les tronçons autoroutiers à partir de la couche `Rues` et le champ `TYPESEGMEN` (voir la [section @sec-01274]).\n\n-   Trouvez l'identifiant du tronçon le plus proche avec la fonction `st_nearest_feature` (voir la [section @sec-0126]).\n\n```{r}\n#| echo: true\n#| eval: false\n#| message: false\n#| warning: false\n\nlibrary(sf)\n## Importation du réseau de rues\nRues <- st_read(\"data/chap01/shp/Segments_de_rue.shp\", quiet=TRUE)\nunique(Rues$TYPESEGMEN)\n## Sélection des tronçons autoroutiers\nAutoroutes <- À compléter\n## Création d'une couche sf pour le point avec les coordonnées\n## en degrés (WGS84, EPSG : 4326) : -71.91688, 45.37579\nPoint1_sf <- À compléter\n## Changement de projection avant de s'assurer que les deux couches ont la même\nPoint1_sf <- st_transform(Point1_sf, st_crs(Autoroutes))\n## Trouver le tronçon autoroutier le plus proche avec la fonction st_nearest_feature\nPlusProche <- À compléter\nprint(PlusProche)\nPoint1_sf$AutoroutePlusProche <- as.numeric(st_distance(Point1_sf,\n                                                        Autoroutes[PlusProche,]))\ncat(\"Distance à l'autoroute la plus proche :\", Point1_sf$AutoroutePlusProche, \"m.\")\n## Zone tampon\nZoneTampon <- st_buffer(Point1_sf, Point1_sf$AutoroutePlusProche)\n## Cartographie\ntmap_mode(\"view\")\ntm_shape(ZoneTampon)+\n  tm_borders(col= \"black\")+\ntm_shape(Autoroutes)+\n  tm_lines(col=\"red\")+\ntm_shape(Point1_sf)+\n  tm_dots(col= \"blue\", shape=21, size = .2)\n```\n\nCorrection à la [section @sec-12014].\n:::\n:::\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["css/quizlib.min.css"],"output-file":"01-ManipulationDonneesSpatiales.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.6.42","license":"CC BY-SA","crossref":{"lof-title":"Liste des figures","lot-title":"Listes des tableaux","fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleRefs.csl","colorlinks":true,"theme":{"light":["cosmo","css/r4ds.scss"]},"fontsize":"11pt","mainfont":"Helvetica Neue,Helvetica,Arial,sans-serif","monofont":"SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":100,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"pdflatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","filters":["lua/callout_custom_pdf.lua"],"output-file":"Méthodes_analyses_spatiales.pdf","toc":true,"toc-depth":4,"include-in-header":["tex-hacks/color-tables.tex","tex-hacks/code-font.tex","tex-hacks/fix-unicode-chars.tex","tex-hacks/image-on-title-page.tex","tex-hacks/callout.tex"]},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"block-headings":true,"license":"CC BY-SA","lang":"fr","crossref":{"lof-title":"Liste des figures","lot-title":"Listes des tableaux","fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleRefs.csl","documentclass":"scrbook","papersize":"letter","classoption":["open=any","twoside=false","french"],"hyperrefoptions":["pdfpagemode=UseOutlines","pdfdisplaydoctitle=true","pdfpagelayout=SinglePage","pdfstartpage=1"],"geometry":["top=20mm","left=15mm","right=15mm","heightrounded"],"fontfamily":"libertinus","fontfamilyoptions":["p"],"lof":true,"lot":true,"code-block-border-left":false,"fontsize":"11pt","urlcolor":"Green4","citecolor":"violet","linkcolor":"violet","colorlinks":true,"header-includes":["\\usepackage{xparse}","\\renewcommand{\\thepart}{} % Enlever numérotation des parties","\\setcounter{secnumdepth}{3} % Activer la numérotation des sections jusqu'au niveau des sous-sections"]},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}