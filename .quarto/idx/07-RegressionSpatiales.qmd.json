{"title":"Introduction aux modèles de régression spatiale","markdown":{"headingText":"Introduction aux modèles de régression spatiale","headingAttr":{"id":"sec-chap07","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nDepuis une trentaine d'années, économètres, épidémiologistes et géographes développent et utilisent abondamment des méthodes de régression intégrant l'espace : modèles économétriques spatiaux, modèles géographiquement pondérés, analyses multiniveaux, etc. L'objectif de ce chapitre est de donner un aperçu de ces méthodes. Nous y décrivons principalement les différents modèles économétriques spatiaux, les modèles généralisés additifs avec une *spline* bivariée sur les coordonnées géographiques et les modèles géographiquement pondérés. Afin d'explorer un plus large éventail de méthodes de régression spatiale, nous vous recommandons la lecture d’un autre ouvrage de la Série *Un grand Bol d'R* intitulé [*Méthodes de régression spatiale : un grand bol d’R*](https://serieboldr.com/RegressionsSpatiales/) [@RBoldAirRegSpatiales].\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n\n::: bloc_package-body\n-   Pour importer et manipuler des fichiers géographiques :\n    -   `sf` pour importer et manipuler des données vectorielles.\n    -   `raster` et `terra` pour manipuler des données matricielles.\n-   Pour construire des cartes et des graphiques :\n    -   `tmap` est certainement le meilleur *package* pour la cartographie.\n    -   `ggplot2` pour construire des graphiques.\n-   Pour construire des modèles spatiaux :\n    -   `spdep` pour construire des matrices de pondération spatiales et calculer le *I* de Moran.\n    -   `spatialreg` pour construire des modèles économétriques spatiaux.\n    -   `mgcv` pour construire des modèles généralisés additifs avec une *spline* sur les coordonnées géographiques.\n    -   `spgwr` pour construire des régressions géographiquement pondérées.\n:::\n:::\n\nPour décrire les différents modèles, nous proposons d'utiliser le jeu de données spatiales `LyonIris` du *package* `geocmeans`. Ce jeu de données spatiales pour l'agglomération lyonnaise (France) comprend dix variables, dont quatre environnementales (EN) et six socioéconomiques (SE), pour les îlots regroupés pour l'information statistique (IRIS) de l'agglomération lyonnaise (@tbl-datageocmeans et @fig-datacarto).\n\n```{r}\n#| label: tbl-datageocmeans\n#| tbl-cap: Statistiques descriptives du jeu de données LyonIris\n#| echo: false\n#| message: false\n#| warning: false\nlibrary(sf)\nload(\"data/chap07/DonneesLyon.Rdata\")\nData <- st_drop_geometry(LyonIris)\nData <-  Data[c(\"Lden\",\"NO2\",\"PM25\",\"VegHautPrt\",\n                        \"Pct0_14\",\"Pct_65\",\"Pct_Img\",\n                        \"TxChom1564\",\"Pct_brevet\",\"NivVieMed\")]\n\nintitule <- c(\"Bruit routier (Lden dB(A))\",\n              \"Dioxyde d'azote (ug/m^3^)\",\n              \"Particules fines (PM$_{2,5}$)\",\n              \"Canopée (%)\",\n              \"Moins de 15 ans (%)\",\n              \"65 ans et plus (%)\",\n              \"Immigrants (%)\",\n              \"Taux de chômage\",\n              \"Personnes à faible scolarité (%)\",\n              \"Médiane du niveau de vie (milliers d'euros)\")\n\nstats <- data.frame(variable = names(Data),\n                    nom = intitule,\n                    type = c(\"EN\",\"EN\",\"EN\",\"EN\",\"SE\",\"SE\",\"SE\",\"SE\",\"SE\",\"SE\"),\n                    moy = round(sapply(Data, mean),2),\n                    et = round(sapply(Data, sd),2), \n                    minimum =round(sapply(Data, min),2), \n                    maximum =round(sapply(Data, max),2)\n                    )\n\nknitr::kable(stats,\n\t\t\tdigits = 1,\n\t\t\tformat.args = list(decimal.mark = ',', big.mark = \" \"),\n\t\t\tcol.names=c(\"Nom\",\"Intitulé\",\"Type\",\"Moy.\", \"E.-T.\", \"Min.\", \"Max.\"),\n\t\t\talign= c(\"l\",\"l\", \"c\",\"r\", \"r\", \"r\", \"r\"),\n\t\t\tformat = \"markdown\")\n```\n\n![Cartographie des variables du jeu de données LyonIris](images/Chap07/FigureDataLyon.png){#fig-datacarto width=\"100%\" fig-align=\"center\"}\n\n## Modèles économétriques spatiaux {#sec-071}\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Régression linéaire multiple et modèles économétriques spatiaux**\n:::\n\n::: bloc_attention-body\nDans cette section, nous décrivons uniquement les modèles économétriques spatiaux dont la variable dépendante est continue. Sommairement, ces modèles sont des extensions de la régression linéaire multiple dans laquelle est intégrée l'autocorrélation spatiale. Avant de lire cette section, il faut donc bien maîtriser la régression linéaire multiple. Si ce n'est pas le cas, nous vous invitons vivement à lire le [chapitre suivant](https://serieboldr.github.io/MethodesQuantitatives/07-regressionlineaire.html) [@RBoldAir].\n\nCes deux dernières décennies, plusieurs ouvrages traitant des modèles économétriques spatiaux ont été publiés, surtout en anglais [@lesage2008introduction; @anselin2014modern; @bivand2008applied]. Ils méritent grandement d'être consultés, tout comme l'excellent livre en français de Jean Dubé et Diègo Legros [-@dube2014econometrie].\n:::\n:::\n\n**Pourquoi recourir à des modèles économétriques spatiaux?**\n\nDans un modèle, les résidus ($\\epsilon$) sont la différence entre les valeurs observées ($y_i$) et les valeurs prédites par le modèle ($\\widehat{y_i}$). Une des hypothèses de la régression linéaire multiple est que les observations doivent être indépendantes les unes des autres (*indépendance du terme d'erreur*). Le non-respect de cette hypothèse produit des résultats biaisés, notamment pour les coefficients de régression.\n\nLorsque les observations sont des entités spatiales (polygones, points par exemple), si les résidus du modèle sont autocorrélés spatialement, il y a un problème de dépendance spatiale du modèle. Autrement dit, les observations ne sont pas spatialement indépendantes les unes des autres. Pour vérifier la dépendance spatiale d'un modèle, il suffit de calculer le *I* de Moran sur les résidus du modèle, comme décrit au chapitre 2 ([section @sec-023]).\n\nAutrement dit, un modèle de régression construit avec des données spatiales ne devrait pas avoir des résidus spatialement autocorrélés. Or, les modèles économétriques spatiaux permettent justement d'intégrer l'autocorrélation spatiale de différentes manières afin de s'assurer que l'hypothèse de l'indépendance du terme d'erreur est respectée.\n\n### Bref retour sur la régression linéaire multiple {#sec-0711}\n\nÀ titre de rappel, la régression linéaire multiple permet de prédire et d'expliquer une variable dépendante ($Y$) en fonction de plusieurs variables indépendantes ($X$). L'équation de régression s'écrit alors :\n\n$$\ny_i = \\beta_{0} + \\beta_{1}x_{1i} + \\beta_{2}x_{2i} +\\ldots+ \\beta_{k}x_{ki} + \\epsilon_{i}\n$$ {#eq-regmultiple1}\n\navec :\n\n-   $y_i$, la valeur de la variable dépendante *Y* pour l'observation *i*.\n-   $\\beta_{0}$, la constante, soit la valeur prédite pour *Y* quand toutes les variables indépendantes sont égales à 0.\n-   $k$ le nombre de variables indépendantes.\n-   $\\beta_{1}$ à $\\beta_{k}$, les coefficients de régression pour les variables indépendantes de 1 à *k* ($X_{1}$ à $X_{k}$).\n-   $\\epsilon_{i}$, le résidu pour l'observation de *i*, soit la partie de la valeur de $y_i$ qui n'est pas expliquée par le modèle de régression.\n\nIl existe plusieurs écritures simplifiées de cette équation. Dans le cadre de ce chapitre, nous utilisons la forme matricielle suivante :\n\n$$\ny = X\\beta + \\epsilon\n$$ {#eq-MCO}\n\navec :\n\n-   $y$, un vecteur de dimension $n \\times 1$ pour la variable dépendante, soit une colonne avec *n* observations.\n-   $X$, une matrice de dimension $n \\times (k + 1)$ pour les *k* variables indépendantes, incluant une autre colonne (avec la valeur de 1 pour les *n* observations) pour la constante, d'où $k + 1$.\n-   $\\beta$, un vecteur de dimension $k + 1$, soit les coefficients de régression pour les *k* variables et la constante.\n-   $\\epsilon$, un vecteur de dimension $n \\times 1$ pour les résidus.\n\n**Construction du modèle MCO dans R**\n\nAvec la fonction `lm()`, il est facile de construire un modèle de régression linéaire multiple basé sur la méthode des moindres carrés ordinaires (MCO). Dans le code ci-dessous, la formule de l'équation du modèle est donc `NO2 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed`. Notez que la variable dépendante et les variables indépendantes sont séparées avec un tilde (`~`). Quant à la fonction `summary(NomDuModèle)`, elle affiche les résultats du modèle.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n#| warning: false\n# Appel des différents packages utilisés dans le chapitre\nlibrary(spdep)\n## Construction du modèle\nModele.MCO <- lm(NO2 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                 data = LyonIris)\n## Résultats du modèle\nsummary(Modele.MCO)\n```\n\n**Dépendance spatiale du modèle MCO?**\n\nPour vérifier si ce modèle linéaire multiple a un problème de dépendance spatiale, nous calculons le *I* de Moran sur ses résidus avec la fonction `lm.morantest`, puis nous les cartographions.\n\n```{r}\n#| echo: true \n#| message: true \n#| eval: true\n\n## Matrice de contiguïté selon le partage d'un segment (Rook)\nRook <- poly2nb(LyonIris, queen=FALSE)\nW.Rook <- nb2listw(Rook, zero.policy=TRUE, style = \"W\")\n# Autocorrélation spatiale globale des résidus\nlm.morantest(Modele.MCO, W.Rook, alternative=\"two.sided\")\n```\n\nAvec une valeur du *I* de Moran de 0,587 (*p* \\< 0,001), les résidus sont fortement autocorrélés spatialement, traduisant ainsi un problème de dépendance spatiale du modèle MCO et la nécessité de recourir à des modèles économétriques spatiaux. La cartographie des résidus à la @fig-figCartoResMCO corrobore ce résultat.\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-figCartoResMCO\n#| fig-align: center\n#| fig-cap: Cartographie des résidus du modèle de régression multiple\n#| out-width: 85%\n\nlibrary(tmap)\n## Ajout de la colonne dans LyonIris avec les valeurs des résidus\nLyonIris$ModeleMCO.Residus <- residuals(Modele.MCO)\n## Cartographie\ntmap_mode(\"plot\")\ntm_shape(LyonIris)+\n  tm_fill(col=\"ModeleMCO.Residus\", n = 5, style = \"quantile\", \n          legend.format = list(text.separator = \"à\"),\n          palette = \"-RdBu\", title = \"Résidus\") +\n  tm_layout(frame=FALSE) + \n  tm_scale_bar(breaks = c(0,5))\n```\n\n### Les différents modèles spatiaux autorégressifs {#sec-0712}\n\nSelon Jean Dubé et Diègo Legros, « cinq raisons peuvent motiver le choix d'un modèle autorégressif : la présence d'externalités, les effets d'entraînement, l'omission de variables importantes, la présence d'hétérogénéité spatiale des comportements, les effets mixtes » [-@dube2014econometrie, p. 120]. Les effets mixtes peuvent être la combinaison d'externalités avec des effets d'entraînement ou encore d'externalités avec l'omission d'une ou de plusieurs variables importantes spatialement structurées.\n\n#### Modèle SLX : autocorrélation spatiale sur les variables indépendantes {#sec-07121}\n\nDans un modèle SLX, l'autocorrélation spatiale est intégrée au niveau des variables indépendantes. Autrement dit, les variables indépendantes spatialement décalées ($WX$) sont introduites aussi dans le modèle. Par conséquent, la valeur de chaque unité spatiale du modèle est ainsi expliquée à la fois par ses propres caractéristiques et celles dans le voisinage ou à proximité en fonction de la matrice de pondération spatiale ($W$).\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Rappel sur les variables spatialement décalées**\n:::\n\n::: bloc_aller_loin-body\nDans le chapitre 2 sur l'autocorrélation spatiale, nous avons vu comment calculer une variable spatialement décalée avec une matrice de pondération spatiale (@fig-Chap02FigureVariableSpatialementDecalee). À titre de rappel, lorsque cette dernière est standardisée en ligne, elle correspond à la valeur moyenne dans le voisinage.\n:::\n:::\n\nL'idée est alors d'introduire des **externalités** puisque les caractéristiques des entités spatiales proches ou voisines peuvent avoir un effet sur la variable dépendante [@dube2014econometrie]. L'équation du modèle SLX, qui est estimée selon la méthode des moindres carrés ordinaires (comme la régression linéaire multiple), s'écrit alors :\n\n$$\ny = X\\beta + WX\\theta + \\epsilon\n$$ {#eq-SLX}\n\navec :\n\n-   $y$, la variable dépendante.\n-   $X$, les variables indépendantes.\n-   $\\beta$, les coefficients des variables indépendantes.\n-   $W$, la matrice de pondération spatiale.\n-   $WX$, les variables indépendantes spatiales décalées.\n-   $\\theta$, les coefficients des variables indépendantes spatiales décalées.\n-   $\\epsilon$, les résidus.\n\n**Construction du modèle SLX dans R**\n\nLe modèle SLX est construit avec la fonction `lmSLX` du *package* `spatialreg` [@bivand2021review]. Remarquez, dans le code ci-dessous, le paramètre `listw=W.Rook` qui est utilisé pour spécifier la matrice de pondération spatiale.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nlibrary(spatialreg)\n## Construction du modèle\nModele.SLX <- lmSLX(NO2 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                   listw=W.Rook,     # matrice de pondération spatiale\n                   data = LyonIris)  # dataframe\n## Résultats du modèle\nsummary(Modele.SLX)\n```\n\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Effets directs, indirects et totaux**\n:::\n\n::: bloc_attention-body\nLa formulation d'un modèle SLX implique deux types d'effets pour les variables indépendantes ($X$) : \n\n-   les **effets directs**, soit ceux des caractéristiques des entités spatiales. Ils correspondent aux coefficients $\\beta$ des variables indépendantes ($X$). Autrement dit, pour une observation $i$, à chaque augmentation d'une unité d'une caractéristique $X$, la valeur de $y_i$ va varier (augmenter ou diminuer) en fonction du coefficient $\\beta$.\n\n-   les **effets indirects**, soit ceux des caractéristiques des entités spatiales voisines ou proches définies selon la matrice de pondération spatiale. Ils correspondent aux coefficients $\\theta$ des variables indépendantes spatialement décalées ($WX$). Autrement dit, les valeurs de $WX$ des entités spatiales proches ou voisines $j$ de $i$ vont aussi être amenées à varier, impactant alors les valeurs $y_j$ selon les coefficients $\\theta$.\n\n\nPrenons l'exemple d'un modèle visant à prédire le prix de vente des maisons dans une ville en fonction de leurs caractéristiques des maisons, dont la superficie du jardin. Il est probable que plus la superficie du jardin de la maison $i$ augmente, plus le prix de vente augmente également (**effet direct**, coefficient $\\beta$). Cette augmentation de la taille du jardin aura aussi un impact sur le prix des maisons voisines puisque leur prix est dépendant de la taille des jardins des maisons voisines. Ainsi, chaque maison $j$, voisine de $i$ verra son prix augmenter à cause de l'augmentation de la taille du jardin de la maison $i$ (**effet indirect**).\n\n\nPour capturer l'impact total sur le prix des maisons d'une augmentation de la superficie du jardin de la maison $i$, il suffit de sommer son effet direct (augmentation du prix de la maison $i$) et son effet indirect (augmentation du prix des maisons $j$) pour obtenir son effet total.\n\nLe code suivant permet de calculer ces effets directs et indirects.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Effets directs, indirects et totaux (uniquement les coefficients)\nimpacts(Modele.SLX)\n## Effets directs, indirects et totaux (coefficients, valeurs de z et de p)\nsummary(impacts(Modele.SLX))\n```\n\nÀ la lecture des valeurs de *p*, nous constatons que seule la variable `Pct0_14` a un impact direct et indirect significatif au seuil 0,01. L'augmentation d'un point de pourcentage de la population de moins de 15 ans est associé localement à une réduction de 0,20 de la concentration annuelle du dioxyde d'azote. Chez les entités voisines, cette réduction est de 0,78 et l'effet total est donc une réduction de 0,98.\n\n:::\n:::\n\n\n**Dépendance spatiale du modèle SLX?**\n\nCe modèle a-t-il corrigé le problème de dépendance spatiale du modèle de régression linéaire classique? Avec une valeur du *I* de Moran de 0,605 (*p* \\< 0,001), les résidus sont toujours fortement autocorrélés spatialement (@fig-figCartoResSLX).\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-figCartoResSLX\n#| fig-align: center\n#| fig-cap: Cartographie des résidus du modèle SLX\n#| out-width: 85%\n\nlm.morantest(Modele.SLX, W.Rook, alternative=\"two.sided\")\nLyonIris$SLX.Residus <- residuals(Modele.SLX)\ntm_shape(LyonIris)+\n  tm_fill(col=\"SLX.Residus\", n = 5, style = \"quantile\", \n          legend.format = list(text.separator = \"à\"),\n          palette = \"-RdBu\", title = \"Résidus\") +\n  tm_layout(frame=FALSE) + \n  tm_scale_bar(breaks = c(0,5))\n```\n\n#### Modèle SAR : autocorrélation spatiale sur la variable dépendante {#sec-07122}\n\nDans le modèle SAR (aussi appelé SAR-LAG), l'autocorrélation spatiale est intégrée au niveau de la variable dépendante ($Wy$), qui est ainsi spatialement décalée. L'idée générale est que la valeur de la variable dépendante pour une observation ($y_i$) peut être influencée par les valeurs de $y$ des observations voisines et proches. L'exemple le plus classique est le prix de vente des maisons : il est influencé à la fois par les caractéristiques intrinsèques de la maison ($X$, par exemple, la superficie habitable, le nombre de chambres à coucher, de salles de bains, etc.) et par le prix de vente des maisons voisines ($Wy$). Jean Dubé et Diègo Legros [-@dube2014econometrie] qualifient ce phénomène « **d'effets d'entraînement ou d'effets de débordement** (*spillover effects*) » [-@dube2014econometrie, p. 123]. L'équation du modèle SAR s'écrit alors :\n\n$$\ny = Wy\\rho + X\\beta + \\epsilon\n$$ {#eq-SLM}\n\navec :\n\n-   $y$, la variable dépendante.\n-   $W$, la matrice de pondération spatiale.\n-   $Wy$, la variable dépendante spatialement décalée.\n-   $\\rho$ (prononcez *rho*), le coefficient de la variable dépendante spatialement décalée. Il varie de -1 à 1.\n-   $X$, les variables indépendantes.\n-   $\\beta$, les coefficients des variables indépendantes.\n-   $\\epsilon$, les résidus.\n\n**Construction du modèle SAR dans R**\n\nLe modèle SAR est construit avec la fonction `lagsarlm` du *package* `spatialreg`.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Construction du modèle\nModele.SAR <- lagsarlm(NO2 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                              listw=W.Rook,    # matrice de pondération spatiale\n                              data = LyonIris, # dataframe\n                              type = 'lag')    # Modèle lag par défaut\n## Résultats du modèle\nsummary(Modele.SAR, Nagelkerke=TRUE)\n```\n\nDans les résultats ci-dessus, la valeur de *rho* est de 0,88 (LR = 620, *p* \\< 0,001), traduisant un très fort effet d'entraînement. Autrement dit, lorsqu'en moyenne la concentration de dioxyde d'azote augmente dans les IRIS voisines ($Wy$), elle augmente aussi fortement chaque IRIS ($y$).\n\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Effets directs, indirects et totaux**\n:::\n\n::: bloc_attention-body\nTout comme le modèle SLX vu précédemment, la formulation du modèle SAR-LAG implique des effets particuliers. Reprenons l'exemple d'un modèle prédisant le prix de vente des maisons avec cette fois-ci un modèle de type SAR-LAG :\n\n1. L'augmentation de la superficie du jardin de la maison $i$ va faire augmenter le prix de la maison $i$ ($y_i$).\n2. Cette augmentation de prix de la maison $i$ aura un impact sur les voisins de $i$, soit les maisons $j$, car leur prix dépend du prix de la maison $i$ au travers du terme $Wy\\rho$ du modèle. Par exemple, si $\\rho$ vaut 0,8, alors 80% de l'augmentation du prix de $i$ va se répercuter sur le prix des maisons $j$.\n3. De même, les voisines des maisons $j$, les maisons $k$ vont aussi être impactées par le changement de prix des maisons $j$ et ainsi de suite de voisins en voisins.\n4. Au final, la maison $i$ verra son prix augmenter encore plus, car le prix de ses voisines aura augmenté par effet de rétroaction.\n\nNotez que puisque $-1 < \\rho < 1$, l'effet de déversement décroit à mesure qu'il se transmet de voisins en voisins jusqu'à disparaitre, un peu à l'image d'une onde se propageant sur une surface d'eau.\n\nCe processus de propagation est appelé l'effet d'entraînement ou de débordement (*spillover*) en économétrie. \n\nL'effet original de l'augmentation de la taille du jardin sur la maison $i$, combiné à l'augmentation par rétroaction, est appelé l'effet direct. L'effet cumulé de l'augmentation de la taille du jardin sur toutes les autres maisons ($\\neq i$) est appelé l'effet indirect. La somme des effets indirects et des directs est appelée effets totaux.\n\nÀ nouveau, il est possible d'utiliser la fonction `impacts` pour calculer ces effets directs et indirects.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Effets directs, indirects et totaux (uniquement les coefficients)\nimpacts(Modele.SAR, listw = W.Rook, R = 999)\n## Effets directs, indirects et totaux (coefficients, valeurs de z et de p)\nsummary(impacts(Modele.SAR, listw = W.Rook, R = 999), zstats = TRUE, short = TRUE)\n```\n\nL'interprétation des effets directs se rapproche de celle des coefficients classiques. Ainsi, selon ce modèle, l'augmentation du niveau de vie médian de 1000 € dans un IRIS est associée avec une diminution moyenne de la concentration de dioxyde d'azote de 0,14 dans cet IRIS. L'effet total est de -0.82, indiquant qu'en moyenne, l'augmentation de 1000 € du niveau de vie médian dans un IRIS est associée avec une diminution totale de 0,82 de la concentration de dioxyde d'azote dans l'ensemble des IRIS. Au final, l'effet indirect est simplement la différence entre l'effet total et l'effet direct. Nous pouvons constater ici que les effets indirects sont plus importants que les effets directs.\n\n:::\n:::\n\n**Dépendance spatiale du modèle SAR?**\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-figCartoResSAR\n#| fig-align: center\n#| fig-cap: Cartographie des résidus du modèle SAR\n#| out-width: 85%\n\n## Autocorrélation spatiale des résidus\ntest <- moran.mc(resid(Modele.SAR), W.Rook, nsim=999)\nprint(test)\n## Cartographie des résidus\nLyonIris$SAR.Residus <- resid(Modele.SAR)\ntm_shape(LyonIris)+\n  tm_fill(col=\"SAR.Residus\", n = 5, style = \"quantile\", \n          legend.format = list(text.separator = \"à\"),\n          palette = \"-RdBu\", title = \"Résidus\") +\n  tm_layout(frame=FALSE) + \n  tm_scale_bar(breaks = c(0,5))\n```\nCe modèle a-t-il corrigé le problème de dépendance spatiale du modèle de régression linéaire classique? Avec une valeur du *I* de Moran de `{r} round(as.numeric(test$statistic),3)` (*p* = `{r} round(as.numeric(test$p.value),3)`), les résidus ne sont plus spatialement autocorrélés (@fig-figCartoResSAR).\n\n\n\n#### Modèle SEM : autocorrélation spatiale sur le terme d'erreur {#sec-07123}\n\nDans le modèle SEM (*Spatial Error Model*, appelé aussi *SAR-ERROR*), l'intégration de l'autocorrélation spatiale est réalisée sur le terme d'erreur, ce qui pourrait se justifier par l'omission d'une variable dépendante spatialement structurée [@dube2014econometrie, p. 126]. L'équation du modèle SEM s'écrit :\n\n$$\ny = X\\beta + u \\textrm{, } u = \\lambda Wu + \\epsilon\n$$ {#eq-SEM}\n\navec :\n\n-   $y$, la variable dépendante.\n-   $W$, la matrice de pondération spatiale.\n-   $\\lambda$ (prononcez *lambda*), le coefficient sur le terme d'erreur spatialement décalé. Il varie de -1 à 1.\n-   $X$, les variables indépendantes.\n-   $\\beta$, les coefficients des variables indépendantes.\n-   $\\epsilon$, les résidus.\n\n**Construction du modèle SAR dans R**\n\nLe modèle SEM est construit avec la fonction `errorsarlm` du *package* `spatialreg`.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Construction du modèle\nModele.SEM <- errorsarlm(NO2 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                         listw=W.Rook,    # matrice de pondération spatiale\n                         data = LyonIris) # dataframe\n## Résultats du modèle\nsummary(Modele.SEM, Nagelkerke=TRUE)\n```\n\nDans les résultats ci-dessus, la valeur de *lambda* est de 0,91 (LR = 613, *p* \\< 0,001), traduisant une très forte autocorrélation spatiale sur le terme d'erreur.\n\n**Dépendance spatiale du modèle SEM?**\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Autocorrélation spatiale des résidus\ntest <- moran.mc(resid(Modele.SEM), W.Rook, nsim=999)\nprint(test)\n```\n\n\nCe modèle a-t-il corrigé le problème de dépendance spatiale du modèle de régression linéaire classique? Avec une valeur du *I* de Moran de `{r} round(as.numeric(test$statistic),3)` (*p* = `{r} round(as.numeric(test$p.value),3)`), les résidus ne sont plus spatialement autocorrélés.\n\n#### Modèle SDM : autocorrélation spatiale sur la variable dépendante et les variables indépendantes {#sec-07124}\n\nLe modèle SDM (*Spatial Durbin Model*) est un modèle mixte qui intègre à la fois l'autocorrélation spatiale sur la variable dépendante ($Wy$, **effets d'entraînement ou de débordement**) et sur les variables indépendantes ($WX$, **externalités**). Il s'écrit alors :\n\n$$\ny = Wy\\rho + X\\beta + WX\\theta + \\epsilon\n$$ {#eq-SDM}\n\navec :\n\n-   $y$, la variable dépendante.\n-   $W$, la matrice de pondération spatiale.\n-   $Wy$, la variable dépendante spatialement décalée.\n-   $\\rho$, le coefficient de la variable dépendante spatialement décalée.\n-   $X$, les variables indépendantes.\n-   $\\beta$, les coefficients des variables indépendantes.\n-   $WX$, les variables indépendantes spatiales décalées.\n-   $\\theta$, les coefficients des variables indépendantes spatiales décalées.\n-   $\\epsilon$, les résidus.\n\n**Construction du modèle SDM dans R**\n\nLe modèle SDM est construit avec la fonction `lagsarlm` du *package* `spatialreg`. Notez que le paramètre `type = \"mixed\"` spécifie l'utilisation d'un modèle mixte.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Construction du modèle\nModele.DurbinSpatial <- lagsarlm(NO2 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                       listw = W.Rook,    # matrice de pondération spatiale\n                       data = LyonIris,   # dataframe\n                       type = \"mixed\")\n## Résultats du modèles\nsummary(Modele.DurbinSpatial, Nagelkerke=TRUE)\n```\n\n**Effets directs, indirects et totaux**\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n# Effets directs, indirects et totaux (uniquement les coefficients)\nimpacts(Modele.DurbinSpatial, listw = W.Rook, R = 999)\n# Effets directs, indirects et totaux (coefficients, valeurs de z et de p)\nsummary(impacts(Modele.DurbinSpatial, listw = W.Rook, R = 999), zstats = TRUE, short = TRUE)\n```\n\nNotez que les effets ci-dessus sont différents de ceux que nous avions obtenus pour le simple modèle SAR-LAG car les effets des variables *X* laguées entrainent également des effets de déversement qui viennent se combiner aux effets de déversement du terme *Wy*.\n\n**Dépendance spatiale du modèle SDM?**\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\ntest <- moran.mc(resid(Modele.DurbinSpatial), W.Rook, nsim=999)\nprint(test)\n```\n\nCe modèle a-t-il corrigé le problème de dépendance spatiale du modèle de régression linéaire classique? Avec une valeur du *I* de Moran de `{r} round(as.numeric(test$statistic),3)` (*p* = `{r} round(as.numeric(test$p.value),3)`), les résidus ne sont plus spatialement autocorrélés.\n\n\n#### Modèle SDEM : autocorrélation spatiale sur les variables indépendantes et sur le terme d'erreur {#sec-07125}\n\nLe modèle SDEM (*Spatial Durbin Error Model* en anglais) est un autre modèle mixte qui intègre à la fois l'autocorrélation spatiale sur les valeurs indépendantes ($WX$, **externalités**) et sur le terme d'erreur ($u = \\lambda Wu + \\epsilon$). Il s'écrit alors :\n\n$$\ny = X\\beta + WX\\theta + u \\textrm{, } u = \\lambda Wu + \\epsilon\n$$ {#eq-SDEM}\n\navec :\n\n-   $y$, la variable dépendante.\n-   $W$, la matrice de pondération spatiale.\n-   $X$, les variables indépendantes.\n-   $\\beta$, les coefficients des variables indépendantes.\n-   $WX$, les variables dépendantes spatiales décalées.\n-   $\\theta$, les coefficients des variables indépendantes spatiales décalées.\n-   $\\lambda$ (prononcez *lambda*), le coefficient sur le terme d'erreur spatialement décalé.\n-   $\\epsilon$, les résidus.\n\n**Construction du modèle SDEM dans R**\n\nLe modèle SDEM est construit avec la fonction `errorsarlm` du *package* `spatialreg`. Notez que le paramètre `etype = \"mixed\"` spécifie l'utilisation d'un modèle mixte.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Construction du modèle\nModele.DurbinErreur <- errorsarlm(NO2 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                                  listw=W.Rook,    # matrice de pondération spatiale\n                                  data = LyonIris, # dataframe\n                                  etype = 'emixed')\n## Résultats du modèle\nsummary(Modele.DurbinErreur, Nagelkerke=TRUE)\n```\n\n**Effets directs, indirects et totaux**\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Effets directs, indirects et totaux (uniquement les coefficients)\nimpacts(Modele.DurbinErreur, listw = W.Rook, R = 999)\n## Effets directs, indirects et totaux (coefficients, valeurs de z et de p)\nsummary(impacts(Modele.DurbinErreur, listw = W.Rook, R = 999), zstats = TRUE, short = TRUE)\n```\n\n**Dépendance spatiale du modèle SDEM?**\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\ntest <- moran.mc(resid(Modele.DurbinErreur), W.Rook, nsim=999)\nprint(test)\n```\n\nAvec une valeur du *I* de Moran de `{r} round(as.numeric(test$statistic),3)` (*p* = `{r} round(as.numeric(test$p.value),3)`), les résidus du modèle SDEM ne sont pas spatialement autocorrélés.\n\n\n### Quel modèle choisir? {#sec-0713}\n\n#### Tests du multiplicateur de Lagrange sur le modèle MCO {#sec-07131}\n\nL'utilisation des tests du multiplicateur de Lagrange (simple et robuste) a été largement popularisée par Anselin *et al.* [-@anselin1996simple] pour vérifier si le recours à un modèle autorégressif est nécessaire, comparativement à un modèle de régression classique (MCO). Les tests sont calculés sur le modèle MCO avec la fonction `lm.LMtests` et une matrice de pondération spatiale. Ces tests permettent aussi de choisir entre les modèles SAR et SEM. La démarche suivante peut être utilisée pour choisir un modèle :\n\n1.  Si toutes les valeurs des tests (simples et robustes) sont non significatives (*p* \\> 0,05), alors le recours à un modèle autorégressif n'est pas nécessaire. Nous pouvons conserver le modèle de régression classique (MCO).\n2.  Si les valeurs de `LMlag` ou `RLMlag` sont non significatives (*p* \\> 0,05), alors le recours au modèle SAR n'est pas nécessaire.\n3.  Si les valeurs de `LMerr` ou `RLMerr` sont non significatives (*p* \\> 0,05), alors le recours au modèle SEM n'est pas nécessaire.\n4.  Si les valeurs de `RLMlag` et `RLMerr` sont significatives (*p* \\< 0,001), nous choisissons le modèle ayant la plus forte statistique.\n\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nlag_test <- lm.LMtests(model = Modele.MCO,\n                   listw = W.Rook,\n                   test = c(\"LMlag\",\"LMerr\",\"RLMlag\",\"RLMerr\"))\nsummary(lag_test)\n```\n\n\nDans les résultats ci-dessous, nous ne retenons pas le modèle SEM car la valeur de `{r} round(as.numeric(lag_test$adjRSerr$statistic),3)` pour le `adjRSerr` n'est pas significative (*p* = `{r} round(as.numeric(lag_test$adjRSerr$p.value),3)`). En revanche, les valeurs de `RSlag` et de `adjRSlag` (`{r} round(as.numeric(lag_test$RSlag$statistic),0)` et `RLMlag` (`{r} round(as.numeric(lag_test$adjRSlag$statistic),0)`) sont significatives, ce qui justifie la sélection du modèle SAR.\n\n#### Comparaison des modèles mixtes et non mixtes {#sec-07132}\n\nNous avons vu qu'il existe deux modèles mixtes (SDM et SDEM). Il convient alors de vérifier si le recours d'un modèle mixte est justifié comparativement à un modèle non mixte. Dans le code ci-dessous, nous vérifions si le modèle SDM est statistiquement différent du modèle SAR avec les fonctions `LR.Sarlm` et `anova`. Les résultats signalent un écart significatif des valeurs du log-vraisemblance (26,101, *p* \\< 0,001). Par conséquent, ce modèle mixte a un apport significatif.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## SDM et SEM sont-ils significativement différents?\nLR.Sarlm(Modele.DurbinSpatial, Modele.SAR)\nanova(Modele.DurbinSpatial, Modele.SAR)\n```\n\nÀ l'inverse, la différence entre les valeurs du log-vraisemblance des modèles SDEM et SEM n'est pas significative (4,9728, *p* = 0,42), signalant que l'utilisation d'un modèle SDEM comparativement à un modèle SEM n'est pas nécessaire.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## SDEM et SEM sont-ils significativement différents?\nLR.Sarlm(Modele.DurbinErreur, Modele.SEM)\nanova(Modele.DurbinErreur, Modele.SEM)\n```\n\n#### Mesures AIC et BIC et dépendance spatiale {#sec-07133}\n\nLe critère d'information d'Akaike (AIC) et le critère d'information bayésien (BIC) sont largement utilisés pour évaluer la qualité d'ajustement du modèle. Plus leurs valeurs sont faibles, meilleur est le modèle. Il est donc possible de comparer leurs valeurs pour les différents modèles (MCO, SLX, SAR, SEM, SDM et SDEM). Nous pouvons aussi comparer l'autocorrélation spatiale des résidus des modèles avec le *I* de Moran.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Valeurs d'AIC et de BIC\nAICs <- AIC(Modele.MCO, Modele.SLX, Modele.SAR, Modele.SEM, \n            Modele.DurbinSpatial, Modele.DurbinErreur)\nBICs <- BIC(Modele.MCO, Modele.SLX, Modele.SAR, Modele.SEM, \n            Modele.DurbinSpatial, Modele.DurbinErreur)\n## Autocorrélation spatiale des résidus\nIMoran.MCO <- moran.mc(resid(Modele.MCO), W.Rook, nsim=999)\nIMoran.SLX <- moran.mc(resid(Modele.SLX), W.Rook, nsim=999)\nIMoran.SLM <- moran.mc(resid(Modele.SAR), W.Rook, nsim=999)\nIMoran.SEM <- moran.mc(resid(Modele.SEM), W.Rook, nsim=999)\nIMoran.DurbinS <- moran.mc(resid(Modele.DurbinSpatial), W.Rook, nsim=999)\nIMoran.DurbinE <- moran.mc(resid(Modele.DurbinErreur), W.Rook, nsim=999)\nMoranI.s <- c(IMoran.MCO$statistic, IMoran.SLX$statistic,\n             IMoran.SLM$statistic, IMoran.SEM$statistic,\n             IMoran.DurbinS$statistic, IMoran.DurbinE$statistic)\nMoranI.p <- c(IMoran.MCO$p.value, IMoran.SLX$p.value,\n             IMoran.SLM$p.value, IMoran.SEM$p.value,\n             IMoran.DurbinS$p.value, IMoran.DurbinE$p.value)\n## Tableau\nComparaison <- data.frame(Modele = c(\"MCO\", \"SLX\", \"SAR\", \"SEM\", \"Durbin S\", \"Durbin E\"),\n                          AIC = AICs$AIC,\n                          BIC = BICs$BIC,\n                          dl = AICs$df,\n                          MoranI = MoranI.s,\n                          MoranIp = MoranI.p)\nComparaison\n```\n\nQuelques lignes de code suffisent pour créer deux graphiques permettant de comparer visuellement les résultats des différents modèles (@fig-GraphComparaison). Les résultats démontrent que :\n\n-   Les modèles MCO et SLX ont un problème de dépendance spatiale puisque leurs résidus sont significativement autocorrélés spatialement. Par conséquent, ils ne devraient pas être retenus.\n-   Les modèles SDM, SAR et SEM sont les plus performants avec les valeurs d'AIC les plus faibles.\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-GraphComparaison\n#| fig-align: center\n#| fig-cap: Comparaison des différents modèles\n#| out-width: 85%\n\nlibrary(ggplot2)\nlibrary(ggpubr)\n## Graphique pour l'autocorrélation spatiale\ng1 <- ggplot(data=Comparaison, aes(x=reorder(Modele,MoranI), y=MoranI)) +\n      geom_segment(aes(x=reorder(Modele, MoranI),\n                   xend=reorder(Modele, MoranI),\n                   y=0, yend=MoranI)) +\n  geom_point( size=4,fill=\"red\",shape=21)+\n  xlab(\"Modèle\") + ylab(\"I de Moran\")+\n  labs(title=\"Autocorrélation spatiale des résidus\",\n       caption=\"Plus la valeur du I de Moran est faible, \\nmoins il y a d'autocorrélation spatiale.\")\n## Graphique pour les valeurs d'AIC\ng2 <- ggplot(data=Comparaison, aes(x=reorder(Modele,AIC), y=AIC)) +\n  geom_segment(aes(x=reorder(Modele, AIC),\n                   xend=reorder(Modele, AIC),\n                   y=0, yend=AIC)) +\n  geom_point( size=4,fill=\"red\",shape=21)+\n  xlab(\"Modèle\") + ylab(\"AIC\")+\n  labs(title=\"Qualité d'ajustement du modèle\",\n       caption=\"Plus la valeur d'AIC est faible, \\nplus le modèle est performant.\")\n## Figure avec les deux graphiques\nggarrange(g1, g2)\n```\n\n## Modèles généralisés additifs (GAM) avec une *spline* bivariée sur les coordonnées géographiques {#sec-072}\n\nLes modèles généralisés additifs (*Generalized additive models* en anglais) permettent d'intégrer à la fois des effets linéaires et des effets non linéaires avec des *splines*. Ils peuvent alors être utilisés en intégrant une *spline* bivariée sur les coordonnées géographiques des centroïdes des entités spatiales.\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n\n**Modèles généralisés additifs**\n:::\n\n::: bloc_attention-body\nPour une description détaillée des modèles généralisés additifs, nous vous invitons vivement à lire le [chapitre suivant](https://serieboldr.github.io/MethodesQuantitatives/11-GAM.html) [@RBoldAir].\n:::\n:::\n\n### Principe de base d'un GAM intégrant l'espace {#sec-0721}\n\nAvec une *spline* bivariée sur les coordonnées géographiques, l'équation d'un modèle généralisé additif s'écrit :\n\n$$\ng(Y) \\ = \\beta_{0} \\ + X\\beta + s(CoordX,CoordY) \\ + \\epsilon\n$$ {#eq-GAM}\n\navec :\n\n-   $y$, la variable dépendante.\n-   $\\beta_{0}$, la constante.\n-   $X$, les variables indépendantes.\n-   $\\beta$, les coefficients des variables dépendantes.\n-   $s(CoordX,CoordY)$, *spline* bivariée sur les coordonnées *x* et *y*.\n-   $\\epsilon$, les résidus.\n\nL'intérêt de recourir à une *spline* bivariée sur les coordonnées géographiques est double :\n\n1.  Contrôler l'effet de la localisation sur la variable dépendante ($y$). Les coefficients des autres variables indépendantes sont ainsi obtenus une fois l'espace pris en compte.\n\n2.  Évaluer l'effet de la localisation (patron spatial), une fois les autres variables indépendantes contrôlées. Autrement dit, toutes choses étant égales par ailleurs, quel est l'effet de la localisation sur la variable dépendante?\n\n### Construction d'un modèle GAM dans R {#sec-0722}\n\n#### Réalisation du modèle GAM {#sec-07221}\n\nPour construire des modèles GAM dans R, nous utilisons la fonction `gam` du *package* `mgcv` [@wood2011fast].\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n#| warning: false\nlibrary(mgcv)\n## Ajout des coordonnées X et Y dans LyonIris \nxy <- st_coordinates(st_centroid(LyonIris))\nLyonIris$X <- xy[,1]\nLyonIris$Y <- xy[,2]\n## Construction du modèle GAM\nModele.GAM1 <- gam(NO2 ~  Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed+\n                          s(X, Y),    # spline sur les coordonnées X, Y\n                    data = LyonIris)  # dataframe\n## Résultats du modèle\nsummary(Modele.GAM1)\n```\n\nLes résultats ci-dessus signalent que la localisation a un effet très significatif puisque (s(X,Y) = 26,5 avec *p* \\< 0,001). Notez que la valeur de *p* permet de déterminer si la *spline* bivariée (et donc l'espace) a ou non un effet significatif. Si la valeur de *p* est supérieure à 0,05, alors il n'est pas nécessaire de conserver la *spline* bivariée sur les coordonnées géographiques.\n\nDe plus, le code ci-dessous permet de constater que le modèle GAM est plus performant que le modèle linéaire multiple classique (MCO).\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nanova(Modele.MCO, Modele.GAM1)\n```\n\nNous pouvons aussi introduire une *spline* plus complexe en augmentant le nombre de nœuds à 40.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nModele.GAM2 <- gam(NO2 ~  Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed+\n                          s(X, Y, k= 40), data = LyonIris)\nsummary(Modele.GAM2)\n```\n\nLa valeur plus faible d'AIC pour le second modèle GAM signale qu'il est plus performant que le premier.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nAIC(Modele.MCO, Modele.GAM1, Modele.GAM2)\n\n```\n\n#### Visualisation de l'effet de l'espace {#sec-07222}\n\nPour visualiser les prédictions du modèle dans l'espace, toutes choses étant égales par ailleurs, nous utilisons la fonction `vis.gam` (@fig-EffetLocalisation1). Les contours signalent qu'au centre de Lyon, les valeurs de dioxyde d'azote sont les plus élevées et dépassent même 40 $\\mu$g/m^3^.\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-EffetLocalisation1\n#| fig-align: center\n#| fig-cap: \"Visualisation des prédictions dans l'espace avec la fonction `vis.gam`\"\n#| out-width: 85%\n\nvis.gam(Modele.GAM2, view=c(\"X\", \"Y\"), plot.type = \"contour\", color=\"terrain\")\n```\n\nToutefois, il est plus intéressant de la représenter dans un *raster*, une fois contrôlées les autres variables indépendantes. Pour ce faire, six étapes sont nécessaires :\n\n1.  Créer une *grid*.\n2.  Fixer les autres paramètres à leur moyenne respective.\n3.  Calculer la prédiction pour la localisation.\n4.  Centrer la prédiction.\n5.  Construire le *raster* avec les prédictions.\n6.  Découper et cartographier le *raster*.\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-EffetLocalisation2\n#| fig-align: center\n#| fig-cap: \"Visualisation de l'effet de la localisation centrée sur zéro\"\n#| out-width: 85%\n\nlibrary(raster)\nlibrary(terra)\n## Étape 1 : création d'une grid pour la prédiction de 100 mètres de résolution spatiale\nXcoords <- seq(min(LyonIris$X-100), max(LyonIris$X+100), by=100)\nYcoords <- seq(min(LyonIris$Y-100), max(LyonIris$Y+100), by=100)\nPredDF <- expand.grid(Xcoords,Ycoords)\nnames(PredDF) <- c(\"X\",\"Y\")\n## Étape 2 : fixation de tous les autres paramètres à leur moyenne\nfor(Var in c(\"VegHautPrt\",\"Pct0_14\",\"Pct_65\",\"Pct_Img\",\"Pct_brevet\", \"NivVieMed\")){\n  PredDF[[Var]] <- mean(LyonIris[[Var]])\n}\n## Étape 3 : calcul de la prédiction\nPredDF$PM25 <- predict(Modele.GAM2,newdata=PredDF)\n## Étape 4 : centrage de la prédiction (sans la constante)\nPredDF$CenterPredPM25 <- PredDF$PM25 - mean(PredDF$PM25)\n### Étape 5 : construction du raster\nrasterGAM <- rasterFromXYZ(PredDF[, c(\"X\", \"Y\", \"CenterPredPM25\")])\ncrs(rasterGAM) <- crs(as(LyonIris, \"Spatial\"))\nrasterGAM <- rast(rasterGAM)\n### Étape 6 : découpage et cartographie du raster\nLyonIris.SpatVector <- vect(LyonIris)\nrasterGAM <- terra::mask(rasterGAM, LyonIris.SpatVector)\nterra::plot(rasterGAM)\n```\n\nLa @fig-EffetLocalisation2 signale que dans le centre de Lyon, le dioxyde d'azote est plus élevé de 10 à 20 $\\mu$g/m^3^, toutes choses étant égales par ailleurs. À l'inverse, dans les zones périphériques, il est faible. Cela signale un net patron spatial décroissant du centre vers la périphérie.\n\n#### Dépendance spatiale du modèle GAM {#sec-07223}\n\nPar contre, bien que l'autocorrélation spatiale des résidus du modèle GAM soit plus faible que pour le modèle MCO (*I* de Moran de 0,337 contre 0,570 avec *p* \\< 0,001), il reste que le problème de la dépendance spatiale n'est pas corrigé.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nmoran.mc(resid(Modele.GAM2), W.Rook, nsim=999)\n```\n\n## Régression géographiquement pondérée {#sec-073}\n\nLa régression géographiquement pondérée (*geographically weighted regression* - GWR, en anglais) a été proposée par Fotheringham *et al.* [-@fotheringham2003geographically] pour modéliser une variable continue. Depuis, plusieurs extensions ont été proposées, notamment des GWR mixtes, des GWR logistiques ou Poisson. Dans le cadre de cette section, nous abordons uniquement sa forme classique (variable dépendante continue).\n\n### Principe de base {#sec-0731}\n\n**Pourquoi recourir à la GWR?**\n\nDans la [section @sec-071], nous avons vu que les modèles autorégressifs visent à contrôler la **dépendance spatiale** d'un modèle de régression classique (MCO), afin d'améliorer l'estimation des coefficients de régression. L'objectif des modèles de régression géographiquement pondérée est différent : ils visent à analyser les variations spatiales de la relation entre la variable dépendante et les variables indépendantes.\n\nAutrement dit, les modèles GWR visent à explorer **l'instabilité spatiale du modèle MCO** afin d'analyser localement la relation entre la variable dépendante et les variables indépendantes. Pour une description détaillée en français de la GWR, consultez Apparicio *et al.* [-@apparicio2007modelisation].\n\n**Formulation de la GWR**\n\nContrairement à la régression linéaire classique et aux modèles spatiaux autorégressifs qui produisent une équation pour l'ensemble du tableau de données, la GWR produit une équation pour chaque unité spatiale *i* et ainsi, des valeurs locales de R^2^, $\\beta_0$, $\\beta_k$, *t* de Student, etc. La résolution de cette équation de régression locale est aussi basée sur la méthode des moindres carrés et sur une matrice de pondération W(i) dont les valeurs décroissent en fonction de la distance séparant les unités *i* et *j*. Autrement dit, plus *j* est proche de *i*, plus sa pondération est élevée et donc plus son « rôle » dans la détermination de l'équation de régression locale de *i* est important.\n\nDe la sorte, la GWR est une extension de la régression linéaire multiple classique où $(u_i, v_i)$ représente les coordonnées géographiques du centroïde de l'unité spatiale et où les paramètres $\\beta_0$ et $\\beta_k$ peuvent varier dans l'espace (@eq-GWR).\n\n$$\ny_i = \\beta_0(u_i, v_i)+ \\sum_{j=1}^k \\beta_j(u_i, v_i)x_{ij}+ \\epsilon_i\n$$ {#eq-GWR}\n\navec :\n\n-   $(u_i, v_i)$, les coordonnées géographiques de l'unité spatiale *i*.\n-   $y_i$, la variable dépendante pour l'unité spatiale *i*.\n-   $\\beta_0(u_i, v_i)$, la constante pour l'unité spatiale *i* aux coordonnées géographiques $(u_i, v_i)$.\n-   $\\beta_j(u_i, v_i)$, le coefficient de régression pour la variable $x_j$ (avec *k* variables indépendantes) pour l'unité spatiale *i* aux coordonnées géographiques $(u_i, v_i)$.\n-   $x_{ij}$, la valeur de la variable indépendante $x_j$ pour l'unité spatiale *i*.\n-   $\\epsilon_i$, le terme d'erreur pour l'unité spatiale *i*.\n\nFotheringham *et al.* [-@fotheringham2003geographically] proposent deux fonctions *kernel* pour définir la pondération W(i) dans le modèle GWR : une fonction gaussienne (@eq-kernelgaussien) et une fonction bicarrée (@eq-kernelbicarree) où $d_{ij}$ représente la distance euclidienne entre les points *i* et *j* et *b*, le rayon de zone d'influence autour du point *i* (*bandwidth*). Il existe une différence fondamentale entre les deux : la fonction gaussienne accorde un poids non nul à tous les points de l'espace d'étude aussi loin soient-ils, tandis que la fonction bicarrée ne tient pas compte des points distants à plus de *b* mètres de *i*, tel qu'illustré à la @fig-GWRKernels avec une valeur fixée à 5000 mètres en guise d'exemple.\n\n$$\nw_{ij} = exp[-.5(d_{ij}/b)^2]\n$$ {#eq-kernelgaussien}\n\n$$\nw_{ij} = [1-(d_{ij}/b)^2]^2 \\text{ si } d_{ij}< b \\text{, sinon } w_{ij}=0 \n$$ {#eq-kernelbicarree}\n\n```{r}\n#| echo: false \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-GWRKernels\n#| fig-align: center\n#| fig-cap: \"Fonctions kernel pour définir la matrice de pondération W(i)\"\n#| out-width: 75%\n\nlibrary(ggplot2)\nb <- 5000\ndf1 <- data.frame(Distance= 1:15000, kernel = \"Fonction gaussienne\")\ndf2 <- data.frame(Distance= 1:15000, kernel = \"Fonction bicarrée\")\ndf1$Ponderation <- exp(-.5*(df1$Distance/b)^2)\ndf2$Ponderation  <- ifelse(df2>b, 0, 1-((df2$Distance/b)^2)^2)\ndf3 <- rbind(df1, df2)\n\nggplot(data = df3)+\n  geom_path(aes(x = Distance, y = Ponderation, color = kernel), linewidth = 1)+\n  labs(x = \"Distance (en mètres)\",\n       y = \"Pondération\",\n       color = \"\",\n       title = '') +\n   geom_vline(xintercept = b, linewidth = 1, col=\"gray50\") +\n   annotate(geom=\"text\", x = b + 250, y=.75,\n            label=paste0(\"b = \",as.character(b)), color=\"black\", hjust = 0, size = 4)\n```\n\nDans le modèle GWR, la valeur de *b* est soit fixée par la personne utilisatrice, soit optimisée avec la valeur de CV (*cross-validation*) ou celle de l'AIC. Notez qu'il est possible d'optimiser la taille de la zone d'influence à partir de la distance euclidienne ou du nombre de plus proches voisins.\n\n### Construction et analyse du modèle GWR dans R {#sec-0732}\n\nPour construire un modèle GWR dans R, nous utilisons le *package* `spgwr` [@packagesGWR]. La construction d'un modèle GWR comprend les étapes suivantes :\n\n1.  Sélection de la taille de la zone d'influence (*bandwidth*) optimale.\n\n2.  Réalisation de la GWR avec la taille de la zone d'influence optimale.\n\n3.  Comparaison des modèles MCO et GWR.\n\n4.  Cartographie des résultats du modèle GWR (R^2^, coefficients, valeurs de *t*, etc.).\n\n#### Définition de la taille de la zone d'influence {#sec-07321}\n\nLa sélection de la taille de la zone d'influence optimale est réalisée avec la fonction `gwr.sel` pour laquelle :\n\n-   le paramètre `gweight` permet de spécifier une fonction *kernel* gaussienne (`gwr.gauss`) ou bicarrée (`gwr.gauss`).\n\n-   le paramètre `adapt` permet de spécifier si vous optimisez le nombre de plus proches voisins (`adapt=TRUE`) ou la distance (`adapt=FALSE`).\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nlibrary(spgwr)\n## Optimisation du nombre de voisins avec le CV\nbwaCV.voisins  <- gwr.sel(NO2 ~  Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                          data = LyonIris,\n                          method = \"cv\",          # Méthode cv ou AIC\n                          gweight=gwr.bisquare,   # gwr.gauss ou gwr.bisquare\n                          adapt=TRUE,\n                          verbose = FALSE,\n                          RMSE = TRUE,\n                          longlat = FALSE,\n                          coords=cbind(LyonIris$X,LyonIris$Y))\n## Optimisation du nombre de voisins avec l'AIC\nbwaAIC.voisins <- gwr.sel(NO2 ~  Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                          data = LyonIris,\n                          method = \"AIC\",          # Méthode cv ou AIC\n                          gweight=gwr.bisquare,    # gwr.gauss ou gwr.bisquare\n                          adapt=TRUE,              # adaptatif\n                          verbose = FALSE,\n                          RMSE = TRUE,\n                          longlat = FALSE,\n                          coords=cbind(LyonIris$X,LyonIris$Y))\n## Optimisation de la distance avec le CV\nbwnaCV.dist <- gwr.sel(NO2 ~  Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                           data = LyonIris,\n                           method = \"cv\",     # méthode cv ou AIC\n                           gweight=gwr.Gauss, # gwr.gauss ou gwr.bisquare\n                           adapt=FALSE,       # non adaptatif\n                           verbose = FALSE,\n                           RMSE = TRUE,\n                           longlat = FALSE,\n                           coords=cbind(LyonIris$X,LyonIris$Y))\n## Optimisation de la distance avec l'AIC\nbwnaAIC.dist <- gwr.sel(NO2 ~  Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n                          data = LyonIris,\n                          method = \"AIC\",      # méthode cv ou AIC\n                          gweight=gwr.Gauss,   # gwr.gauss ou gwr.bisquare\n                          adapt=FALSE,         # non adaptatif\n                          RMSE = TRUE,\n                          verbose = FALSE,\n                          longlat = FALSE,\n                          coords=cbind(LyonIris$X,LyonIris$Y))\n## Affichage des résultats d'optimisation \ncat(\"Sélection de la taille de la zone optimale (bandwidth)\",\n    \"\\n avec le nombre de plus proches voisins :\",\n    \"\\n  CV =\", round(bwaCV.voisins,4), \"nombre de voisins =\", \n    round(bwaCV.voisins*nrow(LyonIris)),\n    \"\\n  AIC =\", round(bwaAIC.voisins,4), \"nombre de voisins =\", \n    round(bwaAIC.voisins*nrow(LyonIris)),\n    \"\\nSélection de la taille de la zone optimale (bandwidth) avec la distance :\",\n    \"\\n  CV =\", round(bwnaCV.dist, 0),  \"mètres\",\n    \"\\n  AIC =\", round(bwnaAIC.dist, 0), \"mètres\")\n```\n\nLes résultats ci-dessus montrent que le nombre de plus proches voisins pourrait être de 92 selon l'approche *cross-validation* et de 54 selon la méthode basée sur l'AIC. Si la valeur de *b* est basée sur la distance, elle serait alors optimale à 1315 et 1662 mètres selon les deux méthodes.\n\n#### Réalisation de la GWR {#sec-07322}\n\nAvec la fonction `gwr`, nous estimons un modèle GWR avec un *kernel* bicarré et un nombre optimisé de plus voisins selon la méthode CV, soit 92.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nModele.GWR <- gwr(NO2 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed,\n              data = LyonIris,\n              adapt=bwaCV.voisins,\n              gweight=gwr.bisquare,\n              hatmatrix=TRUE,\n              se.fit=TRUE,\n              coords=cbind(LyonIris$X,LyonIris$Y),\n              longlat=F)\n```\n\nLe code ci-dessous permet de renvoyer les statistiques univariées des coefficients des 506 régressions locales, réalisées pour chacune des 506 entités spatiales (IRIS), et les statistiques d'ajustement du modèle (AIC, R^2^ global, etc.)\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nModele.GWR\n```\n\n#### Comparaison des modèles MCO et GWR {#sec-07323}\n\nLe R^2^ global du modèle GWR est bien supérieur au modèle classique MCO (0,783 contre 0,283). Fotheringham *et al.* [-@fotheringham2003geographically] proposent plusieurs tests pour comparer les modèles GWR et classique qui sont implémentés dans le *package* `spgwr` (fonctions `anova(Modele.GWR)`, `anova(Modele.GWR, approx=TRUE)`, `LMZ.F1GWR.test(Modele.GWR)`, `LMZ.F2GWR.test(Modele.GWR)`.\n\nSi les valeurs de *p* de ces tests sont inférieures à 0,05, alors le modèle GWR améliore de façon significative la capacité prédictive du modèle de régression globale, ce que confirment les résultats ci-dessous.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nanova(Modele.GWR)\nanova(Modele.GWR, approx=TRUE)\nLMZ.F1GWR.test(Modele.GWR)\nLMZ.F2GWR.test(Modele.GWR)\n```\n\nUn autre test (`LMZ.F3GWR.test`) permet de répondre à la question suivante : est-ce que les coefficients de régression du modèle GWR varient spatialement de façon significative? Les résultats ci-dessous démontrent que c'est le cas pour toutes les variables indépendantes et la constante (*p* \\< 0,001).\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\nLMZ.F3GWR.test(Modele.GWR)\n```\n\n#### Cartographie des résultats du modèle GWR {#sec-07324}\n\nDans un premier temps, nous ajoutons les valeurs locales des R^2^, des coefficients de régression et des valeurs de *t* dans la couche `sf`. Notez que les résultats locaux de la GWR sont stockés dans l'objet `Modele.GWR$SDF`.\n\n```{r}\n#| echo: true \n#| message: false \n#| eval: true\n## Récupération du R carré local\nLyonIris$GWR.R2 <- Modele.GWR$SDF$localR2\n## Récupération des coefficients de régression et calcul des valeurs de t locales\nnames(Modele.GWR$SDF)\nVarsIndep <- c(\"Pct0_14\", \"Pct_65\", \"Pct_Img\", \"Pct_brevet\", \"NivVieMed\")\nfor(e in VarsIndep){\n  # Nom des nouvelles variables\n  var.coef <- paste0(\"GWR.\", \"B_\", e)\n  var.t    <- paste0(\"GWR.\", \"T_\", e)\n  # Récupération des coefficients pour les variables indépendantes\n  LyonIris[[var.coef]] <- Modele.GWR$SDF[[e]]\n  # Calcul des valeurs de t pour les variables indépendantes\n  LyonIris[[var.t]]    <- Modele.GWR$SDF[[e]] / Modele.GWR$SDF[[paste0(e, \"_se\")]]\n}\n```\n\n**Cartographie des R^2^ locaux**\n\nLe code ci-dessous permet ensuite de cartographier les R^2^ locaux de la GWR (@fig-GWRR2).\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-GWRR2\n#| fig-align: center\n#| fig-cap: \"Cartographie des R carrés locaux de la GWR\"\n#| out-width: 85%\n\nlibrary(tmap)\ntm_shape(LyonIris)+\n  tm_borders(col=\"gray25\", lwd=.5)+\n  tm_fill(col=\"GWR.R2\", \n\t\t  palette=\"YlOrBr\", \n\t\t  n=5, style=\"quantile\",\n\t\t  legend.format = list(text.separator = \"à\"),\n\t\t  title = \"R2 locaux\")+\n  tm_layout(frame=FALSE)+\n  tm_scale_bar(breaks=c(0,5))\n```\n\n**Cartographie des coefficients de régression**\n\nLe code ci-dessous permet ensuite de cartographier les coefficients locaux de la GWR (@fig-GWRCoeffReg).\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-GWRCoeffReg \n#| fig-align: center\n#| fig-cap: Cartographie des coefficients de régression de la GWR\n#| out-width: 100%\n\nCarte1 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.B_Pct0_14\", palette=\"YlOrBr\", n=4, style=\"pretty\",\n\t\t          legend.format = list(text.separator = \"à\"),\n                  title = \"Moins de 15 ans (%)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)+tm_scale_bar(breaks=c(0,5))\nCarte2 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.B_Pct_65\", palette=\"YlOrBr\", n=4, style=\"pretty\", \n\t\t          legend.format = list(text.separator = \"à\"),\n                  title = \"65 ans et plus (%)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)+tm_scale_bar(breaks=c(0,5))\nCarte3 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.B_Pct_Img\", palette=\"YlOrBr\", n=4, style=\"pretty\", \n\t\t          legend.format = list(text.separator = \"à\"),\n                  title = \"Immigrants (%)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)+tm_scale_bar(breaks=c(0,5))\nCarte4 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.B_Pct_brevet\", palette=\"YlOrBr\", n=4, style=\"pretty\", \n\t\t          legend.format = list(text.separator = \"à\"),\n                  title = \"Faible scolarité (%)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)+tm_scale_bar(breaks=c(0,5))\nCarte5 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.B_NivVieMed\", palette=\"YlOrBr\", n=4, style=\"pretty\", \n\t\t          legend.format = list(text.separator = \"à\"),\n                  title = \"Niveau de vie (€1000)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)+tm_scale_bar(breaks=c(0,5))\ntmap_arrange(Carte1, Carte2, Carte3, Carte4, Carte5, ncol = 2, nrow=3)\n```\n\n**Cartographie des valeurs de *t***\n\nPour cartographier les valeurs de *t*, nous utilisons les seuils de ± 1,96, 2,58 et 3,29, indiquant des seuils de signification à 5 %, 1 % et 0,1 % (@fig-GWRValT).\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-GWRValT\n#| fig-align: center\n#| fig-cap: \"Cartographie des valeurs de *t* de la GWR\"\n#| out-width: 100%\n\nclasses.intervalles = c(-Inf, -3.29, -2.58, -1.96, 1.96, 2.58, 3.29, Inf)\nCarte1 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.T_Pct0_14\", palette=\"-RdBu\", \n                  breaks = classes.intervalles,\n\t\t          legend.format = list(text.separator = \"à\"),\n                  title = \"Moins de 15 ans (%)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)\nCarte2 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.T_Pct_65\", palette=\"-RdBu\",\n                  breaks = classes.intervalles,\n\t\t          legend.format = list(text.separator = \"à\"),\n                  title = \"65 ans et plus (%)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)\nCarte3 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.T_Pct_Img\", palette=\"-RdBu\", \n                  breaks = classes.intervalles,\n\t\t          legend.format = list(text.separator = \"à\"),\n                  title = \"Immigrants (%)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)\nCarte4 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.B_Pct_brevet\", palette=\"-RdBu\", \n                  breaks = classes.intervalles,\n\t\t          legend.format = list(text.separator = \"à\"),\n                  title = \"Faible scolarité (%)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)\nCarte5 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"GWR.T_NivVieMed\", palette=\"-RdBu\", \n                 breaks = classes.intervalles,\n\t\t          legend.format = list(text.separator = \"à\"),\n                 title = \"Niveau de vie (€1000)\")+\n          tm_layout(frame=FALSE, legend.outside = TRUE)+\n          tm_scale_bar(breaks=c(0,5))\ntmap_arrange(Carte1, Carte2, Carte3, Carte4, Carte5, ncol = 2, nrow=3)\n```\n\n**Cartographie du nombre de variables significatives**\n\nNous pouvons aussi cartographier le nombre de variables localement significatives aux seuils de 5 % et 1 %.\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-GWRNNsign\n#| fig-align: center\n#| fig-cap: \"Nombre de variables significatives aux seuils de 5% et 1%\"\n#| out-width: 85%\n\n## Identifier la variable plus significative avec les valeurs de t\nVarsT <- paste0(\"GWR.T_\", c(\"Pct0_14\", \"Pct_65\", \"Pct_Img\", \"Pct_brevet\", \"NivVieMed\"))\nLyon.df  <- st_drop_geometry(LyonIris)\nLyon.df <- abs(Lyon.df[,VarsT])\nPlusSign <- VarsT[apply(Lyon.df[VarsT],1,which.max)]\nPlusSign <- substr(PlusSign, 7, nchar(PlusSign))\nMaxAbsTvalue <- apply(Lyon.df[VarsT], 1, max)\nPlusSign <- ifelse(MaxAbsTvalue<1.96, \"Aucune\", PlusSign)\n## Nombre de variables significatives au seuil de 5%, soit abs(t)= 1,96)\nLyonIris$NbSignif_1.96 <- as.factor(rowSums(Lyon.df > 1.96))\nLyonIris$NbSignif_2.58 <- as.factor(rowSums(Lyon.df > 2.58))\nLyonIris$PlusSign      <- as.factor(PlusSign)\n## Cartographie\nCarte1 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"NbSignif_1.96\", palette=\"Reds\",\n                 title = \"Sign. au seuil de 5%\")+\n          tm_layout(frame=FALSE)+ tm_scale_bar(breaks=c(0,5))\nCarte2 <- tm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"NbSignif_2.58\", palette=\"Reds\", \n                 title = \"Sign. au seuil de 1%\")+\n          tm_layout(frame=FALSE)\ntmap_arrange(Carte1, Carte2, ncol=2, nrow=1)\n```\n\n**Cartographie de la variable la plus significative avec la valeur de *t***\n\nFinalement, le code ci-dessous permet de repérer la variable la plus significative au seuil de 5 %, c'est-à-dire avec la plus forte valeur absolue pour la valeur de *t*.\n\n```{r}\n#| echo: true \n#| eval: true \n#| message: false \n#| warning: false\n#| label: fig-GWRPlussign\n#| fig-align: center\n#| fig-cap: \"Variable indépendante la plus significative au seuil de 5 %\"\n#| out-width: 85%\n\ntm_shape(LyonIris)+ tm_borders(col=\"gray25\", lwd=.5)+\n          tm_fill(col=\"PlusSign\", palette=\"Set1\", \n                 title = \"Variable la plus significative\")+\n          tm_layout(frame=FALSE)+ tm_scale_bar(breaks=c(0,5))\n```\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Extensions de la GWR classique**\n:::\n\n::: bloc_aller_loin-body\nÀ titre de rappel, la GWR classique permet de modéliser une variable dépendante continue. Plusieurs extensions ont été proposées, notamment :\n\n- La GWR mixte qui permet de spécifier des variables indépendantes variant spatialement et d'autres étant fixes [@fotheringham2003geographically].\n\n- Les GWR logistique (pour une variable dépendante binaire) et Poisson (pour une variable dépendante de comptage) [@fotheringham2003geographically].\n\n- La régression géographiquement et temporellement pondérée (*Geographical and temporal weighted regression* – GTWR) [@fotheringham2015geographical].\n\n- La régression géographiquement pondérée multiéchelle (*Multiscale geographically weighted regression* – MGWR) [@fotheringham2017multiscale].\n\n- L'analyse en composantes principales géographiquement pondérée (*Geographically weighted principal components analysis* – GWR PCA)  [@harris2011geographically].\n\n:::\n:::\n\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n**Autres méthodes de régression spatiales**\n:::\n::: bloc_aller_loin-body\nComme signalé en introduction, si vous souhaitez maîtriser une plus large éventail de méthodes de régression spatiale, nous vous recommandons la lecture d’un autre ouvrage de la Série *Un grand Bol d'R* intitulé [**Méthodes de régression spatiale : un grand bol d’R**](https://serieboldr.com/RegressionsSpatiales/) [@RBoldAirRegSpatiales].\n:::\n:::\n\n\n\n## Quiz de révision du chapitre {#sec-074}\n\n```{r}\n#| label: quizChapitre07\n#| echo: false \n#| eval: true \n#| message: false \n#| warning: false \n#| results: asis\n\nsource(\"code_complementaire/QuizzFunctions.R\")\nChap07Quiz <- quizz(\"quiz/Chap07.yml\", \"Chap07\")\nrender_quizz(Chap07Quiz)\n```\n\n## Exercices de révision {#sec-075}\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 1.** Réalisation de modèles de régression autorégressifs spatiaux\n:::\n\n::: bloc_exercice-body\n```{r}\n#| echo: true \n#| message: false \n#| warning: false \n#| eval: false\nlibrary(sf)\nlibrary(spatialreg)\n# Matrice de contiguïté selon le partage d'un segment (Rook)\nload(\"data/chap07/DonneesLyon.Rdata\")\nRook <- poly2nb(LyonIris, queen=FALSE)\nRook <- poly2nb(LyonIris, queen=FALSE)\nW.Rook <- nb2listw(Rook, zero.policy=TRUE, style = \"W\")\n# Modèles\nformule <- \"PM25 ~  Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed\"\nModele.SLX <- à compléter\nModele.SAR <- à compléter\nModele.SEM <- à compléter\nModele.DurbinSpatial <- à compléter\nModele.DurbinErreur <- à compléter\n```\n\nCorrection à la [section @sec-12071].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 2.** Réalisation d'un modèle GAM\n:::\n\n::: bloc_exercice-body\n```{r}\n#| echo: true \n#| message: false \n#| warning: false \n#| eval: false\nlibrary(sf)\nlibrary(mgcv)\nload(\"data/chap07/DonneesLyon.Rdata\")\n# Ajout des coordonnées x et y\nxy <- à compléter\nLyonIris$X <- à compléter\nLyonIris$Y <- à compléter\n# Construction du modèle\nformule <- \"PM25 ~  Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed\"\nModele.GAM2 <- gam(NO2 ~  à compléter\n                          à compléter,\n                          data = LyonIris)\nsummary(Modele.GAM2)\n```\n\nCorrection à la [section @sec-12072].\n:::\n:::\n\n::: bloc_exercice\n::: bloc_exercice-header\n::: bloc_exercice-icon\n:::\n\n**Exercice 2.** Réalisation d'un modèle GWR\n:::\n\n::: bloc_exercice-body\n```{r}\n#| echo: true \n#| message: false \n#| warning: false \n#| eval: false\nlibrary(sf)\nlibrary(spgwr)\nload(\"data/chap07/DonneesLyon.Rdata\")\n# Ajout des coordonnées x et y\nxy <- à compléter\nLyonIris$X <- à compléter\nLyonIris$Y <- à compléter\n# Optimisation du nombre de voisins avec le CV\nformule <- \"PM25 ~ Pct0_14+Pct_65+Pct_Img+Pct_brevet+NivVieMed\"\nbwaCV.voisins  <- gwr.sel(à compléter)\n# Optimisation du nombre de voisins avec l'AIC\nbwaCV.voisins  <- gwr.sel(à compléter)\n# Réalisation de la GWR\nModele.GWR <- gwr(à compléter)\n# Affichage des résultats\nModele.GWR\n```\n\nCorrection à la [section @sec-12073].\n:::\n:::\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["css/quizlib.min.css"],"output-file":"07-RegressionSpatiales.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.6.42","license":"CC BY-SA","crossref":{"lof-title":"Liste des figures","lot-title":"Listes des tableaux","fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleRefs.csl","colorlinks":true,"theme":{"light":["cosmo","css/r4ds.scss"]},"fontsize":"11pt","mainfont":"Helvetica Neue,Helvetica,Arial,sans-serif","monofont":"SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":100,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"pdflatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","filters":["lua/callout_custom_pdf.lua"],"output-file":"Méthodes_analyses_spatiales.pdf","toc":true,"toc-depth":4,"include-in-header":["tex-hacks/color-tables.tex","tex-hacks/code-font.tex","tex-hacks/fix-unicode-chars.tex","tex-hacks/image-on-title-page.tex","tex-hacks/callout.tex"]},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"block-headings":true,"license":"CC BY-SA","lang":"fr","crossref":{"lof-title":"Liste des figures","lot-title":"Listes des tableaux","fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleRefs.csl","documentclass":"scrbook","papersize":"letter","classoption":["open=any","twoside=false","french"],"hyperrefoptions":["pdfpagemode=UseOutlines","pdfdisplaydoctitle=true","pdfpagelayout=SinglePage","pdfstartpage=1"],"geometry":["top=20mm","left=15mm","right=15mm","heightrounded"],"fontfamily":"libertinus","fontfamilyoptions":["p"],"lof":true,"lot":true,"code-block-border-left":false,"fontsize":"11pt","urlcolor":"Green4","citecolor":"violet","linkcolor":"violet","colorlinks":true,"header-includes":["\\usepackage{xparse}","\\renewcommand{\\thepart}{} % Enlever numérotation des parties","\\setcounter{secnumdepth}{3} % Activer la numérotation des sections jusqu'au niveau des sous-sections"]},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}